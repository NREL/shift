{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Shift Generate distribution feeder model from OpenStreet data. Getting free distribution feeder models for your reasearch has never been easier. SHIFT helps you build synthetic distribution feeders models using just the OpenStreet data e.g. buildings and road network. You can configure lots of parameters and design choices when building these models and even create multiple versions of them and choose the one that fits your needs. If you are utility no worries we have you covered as well. As a utility you can also integrate your data when building these models. Installation Instruction We are in the processing of releasing a stable version to PyPI. Until it is ready for installing via pip, you can install this tool by cloning or downloading code from here . We recommend using Anaconda or Miniconda to create the environment for windows user. Use the commands below to create environment and install the shift tool. Windows 10 Mac OS & linux conda create -n shift python==3.9 conda install osmnx cd <cloned_repo> pip install -e. conda create -n shift python==3.9 cd <cloned_repo> pip install -e.","title":"Welcome"},{"location":"#shift","text":"Generate distribution feeder model from OpenStreet data. Getting free distribution feeder models for your reasearch has never been easier. SHIFT helps you build synthetic distribution feeders models using just the OpenStreet data e.g. buildings and road network. You can configure lots of parameters and design choices when building these models and even create multiple versions of them and choose the one that fits your needs. If you are utility no worries we have you covered as well. As a utility you can also integrate your data when building these models.","title":"Shift"},{"location":"#installation-instruction","text":"We are in the processing of releasing a stable version to PyPI. Until it is ready for installing via pip, you can install this tool by cloning or downloading code from here . We recommend using Anaconda or Miniconda to create the environment for windows user. Use the commands below to create environment and install the shift tool. Windows 10 Mac OS & linux conda create -n shift python==3.9 conda install osmnx cd <cloned_repo> pip install -e. conda create -n shift python==3.9 cd <cloned_repo> pip install -e.","title":"Installation Instruction"},{"location":"clustering/","text":"Contains abstract and concrete classes for implementing clustering. This module contains classes for managing clustering of location pairs. The cluster center is used as reference location to figure out transformer siting. In the process mapping between cluster center and locations is also created. Examples: Get the clusters from given list of location pairs and plot it. >>> from shift.clustering import KmeansClustering >>> import numpy as np >>> x_array = np . array ([[ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ]]) >>> cluster = KmeansClustering ( 2 ) >>> cluster . get_clusters ( x_array ) >>> cluster . plot_clusters () Clustering Bases: ABC Abstract interface for implementing clustering subclass Source code in shift\\clustering.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class Clustering ( ABC ): \"\"\"Abstract interface for implementing clustering subclass\"\"\" @abstractmethod def get_clusters ( self , x_array : List [ list ]) -> dict : \"\"\"Method for creating and returning clusters. Subclass inhereting this class must implement this method and should return the clusters in the following format. ```json {\"labels\": [0,1,1], \"centre\": [(0,0), (2,2)]} ``` Returns: dict: A dictionary containing cluster labels and cluster centers \"\"\" pass @abstractmethod def plot_clusters ( self ) -> None : \"\"\"Method to plot clusters Raises: EarlyMethodCallError: If this method is called before calling `get_clusters` method. \"\"\" pass get_clusters ( x_array ) abstractmethod Method for creating and returning clusters. Subclass inhereting this class must implement this method and should return the clusters in the following format. { \"labels\" : [ 0 , 1 , 1 ], \"centre\" : [ ( 0 , 0 ) , ( 2 , 2 ) ]} Returns: Name Type Description dict dict A dictionary containing cluster labels and cluster centers Source code in shift\\clustering.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 @abstractmethod def get_clusters ( self , x_array : List [ list ]) -> dict : \"\"\"Method for creating and returning clusters. Subclass inhereting this class must implement this method and should return the clusters in the following format. ```json {\"labels\": [0,1,1], \"centre\": [(0,0), (2,2)]} ``` Returns: dict: A dictionary containing cluster labels and cluster centers \"\"\" pass plot_clusters () abstractmethod Method to plot clusters Raises: Type Description EarlyMethodCallError If this method is called before calling get_clusters method. Source code in shift\\clustering.py 84 85 86 87 88 89 90 91 @abstractmethod def plot_clusters ( self ) -> None : \"\"\"Method to plot clusters Raises: EarlyMethodCallError: If this method is called before calling `get_clusters` method. \"\"\" pass KmeansClustering Bases: Clustering Class implementing Kmeans clustering. Attributes: Name Type Description num_of_clusters Union [ str , int ] Number of clusters to be used cluster_centers List [ Sequece ] List of cluster center labels list Integer label for each location indicating which cluster they belong to xarray List [ Sequece ] List of location pairs for which clustering is performed optimal_clusters int Optimal number of clusters created if num_of_clusters passed is optimal Source code in shift\\clustering.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 class KmeansClustering ( Clustering ): \"\"\"Class implementing Kmeans clustering. Attributes: num_of_clusters (Union[str, int]): Number of clusters to be used cluster_centers (List[Sequece]): List of cluster center labels (list): Integer label for each location indicating which cluster they belong to xarray (List[Sequece]): List of location pairs for which clustering is performed optimal_clusters (int): Optimal number of clusters created if `num_of_clusters` passed is `optimal` \"\"\" def __init__ ( self , num_of_clusters : Union [ str , int ] = \"optimal\" ) -> None : \"\"\"Constructor for `KmeansClustering` class. Args: num_of_clusters (Union[str, int]): Number of clusters to be used Raises: NumberOfClusterNotInRangeError: if `num_of_clusters` speecified is less than MIN_NUM_CLUSTER constants module. \"\"\" self . num_of_clusters = num_of_clusters if isinstance ( self . num_of_clusters , int ): if self . num_of_clusters < MIN_NUM_CLUSTER : raise NumberOfClusterNotInRangeError ( self . num_of_clusters ) def plot_clusters ( self ): \"\"\"Refer to the base class for details.\"\"\" if ( hasattr ( self , \"x_array\" ) and hasattr ( self , \"labels\" ) and hasattr ( self , \"clsuter_centers\" ) ): plot_data = { \"x\" : [], \"y\" : [], \"label\" : []} for d , label in zip ( self . x_array , self . labels ): plot_data [ \"x\" ] . append ( d [ 0 ]) plot_data [ \"y\" ] . append ( d [ 1 ]) plot_data [ \"label\" ] . append ( label ) fig = px . scatter ( pd . DataFrame ( plot_data ), x = \"x\" , y = \"y\" , color = \"label\" ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot clusters method!\" ) def plot_scores ( self ): \"\"\"Method for plotting scores Note: Only use this method if `num_of_clusters` passed is `optimal`. Raises: EarlyMethodCallError: If called before calling `get_clusters` method. \"\"\" if hasattr ( self , \"sil_scores\" ): plot_data = { \"Number of clusters\" : [ x [ 0 ] for x in self . sil_scores ], \"Silhouette Value\" : [ x [ 1 ] for x in self . sil_scores ], } fig = px . line ( pd . DataFrame ( plot_data ), x = \"Number of clusters\" , y = \"Silhouette Value\" , ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot scores method!\" ) def get_clusters ( self , x_array : list ) -> dict : \"\"\"Refer to the base class for details. Raises: WrongInputUsed: If the number of clusters passed is invalid. \"\"\" self . x_array = x_array if isinstance ( self . num_of_clusters , int ): kmeans = KMeans ( n_clusters = self . num_of_clusters , random_state = 0 ) . fit ( x_array ) else : if self . num_of_clusters == \"optimal\" : \"\"\"Let's try to find optimal number of clusters\"\"\" self . sil_scores = [] for k in range ( 2 , MAX_KMEANS_LOOP ): kmeans = KMeans ( n_clusters = k ) . fit ( x_array ) labels = kmeans . labels_ self . sil_scores . append ( ( k , silhouette_score ( x_array , labels , metric = \"euclidean\" ), ) ) # Break the loop if Silhouette score starts to decrease if k > 2 : if ( self . sil_scores [ k - 2 ][ 1 ] < self . sil_scores [ k - 3 ][ 1 ] ): break if k == MAX_KMEANS_LOOP - 1 : raise MaxLoopReachedForKmeans () kmeans = KMeans ( n_clusters = k - 1 , random_state = 0 ) . fit ( x_array ) self . optimal_clusters = k - 1 else : raise WrongInputUsed ( f \"For now number of clusters can be either integer number or 'optimal' ! You provided { self . num_of_clusters } \" ) self . labels = kmeans . labels_ self . cluster_centers = kmeans . cluster_centers_ return { \"labels\" : self . labels , \"centre\" : self . cluster_centers } __init__ ( num_of_clusters = 'optimal' ) Constructor for KmeansClustering class. Parameters: Name Type Description Default num_of_clusters Union [ str , int ] Number of clusters to be used 'optimal' Raises: Type Description NumberOfClusterNotInRangeError if num_of_clusters speecified is less than MIN_NUM_CLUSTER constants module. Source code in shift\\clustering.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def __init__ ( self , num_of_clusters : Union [ str , int ] = \"optimal\" ) -> None : \"\"\"Constructor for `KmeansClustering` class. Args: num_of_clusters (Union[str, int]): Number of clusters to be used Raises: NumberOfClusterNotInRangeError: if `num_of_clusters` speecified is less than MIN_NUM_CLUSTER constants module. \"\"\" self . num_of_clusters = num_of_clusters if isinstance ( self . num_of_clusters , int ): if self . num_of_clusters < MIN_NUM_CLUSTER : raise NumberOfClusterNotInRangeError ( self . num_of_clusters ) get_clusters ( x_array ) Refer to the base class for details. Raises: Type Description WrongInputUsed If the number of clusters passed is invalid. Source code in shift\\clustering.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def get_clusters ( self , x_array : list ) -> dict : \"\"\"Refer to the base class for details. Raises: WrongInputUsed: If the number of clusters passed is invalid. \"\"\" self . x_array = x_array if isinstance ( self . num_of_clusters , int ): kmeans = KMeans ( n_clusters = self . num_of_clusters , random_state = 0 ) . fit ( x_array ) else : if self . num_of_clusters == \"optimal\" : \"\"\"Let's try to find optimal number of clusters\"\"\" self . sil_scores = [] for k in range ( 2 , MAX_KMEANS_LOOP ): kmeans = KMeans ( n_clusters = k ) . fit ( x_array ) labels = kmeans . labels_ self . sil_scores . append ( ( k , silhouette_score ( x_array , labels , metric = \"euclidean\" ), ) ) # Break the loop if Silhouette score starts to decrease if k > 2 : if ( self . sil_scores [ k - 2 ][ 1 ] < self . sil_scores [ k - 3 ][ 1 ] ): break if k == MAX_KMEANS_LOOP - 1 : raise MaxLoopReachedForKmeans () kmeans = KMeans ( n_clusters = k - 1 , random_state = 0 ) . fit ( x_array ) self . optimal_clusters = k - 1 else : raise WrongInputUsed ( f \"For now number of clusters can be either integer number or 'optimal' ! You provided { self . num_of_clusters } \" ) self . labels = kmeans . labels_ self . cluster_centers = kmeans . cluster_centers_ return { \"labels\" : self . labels , \"centre\" : self . cluster_centers } plot_clusters () Refer to the base class for details. Source code in shift\\clustering.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def plot_clusters ( self ): \"\"\"Refer to the base class for details.\"\"\" if ( hasattr ( self , \"x_array\" ) and hasattr ( self , \"labels\" ) and hasattr ( self , \"clsuter_centers\" ) ): plot_data = { \"x\" : [], \"y\" : [], \"label\" : []} for d , label in zip ( self . x_array , self . labels ): plot_data [ \"x\" ] . append ( d [ 0 ]) plot_data [ \"y\" ] . append ( d [ 1 ]) plot_data [ \"label\" ] . append ( label ) fig = px . scatter ( pd . DataFrame ( plot_data ), x = \"x\" , y = \"y\" , color = \"label\" ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot clusters method!\" ) plot_scores () Method for plotting scores Note Only use this method if num_of_clusters passed is optimal . Raises: Type Description EarlyMethodCallError If called before calling get_clusters method. Source code in shift\\clustering.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def plot_scores ( self ): \"\"\"Method for plotting scores Note: Only use this method if `num_of_clusters` passed is `optimal`. Raises: EarlyMethodCallError: If called before calling `get_clusters` method. \"\"\" if hasattr ( self , \"sil_scores\" ): plot_data = { \"Number of clusters\" : [ x [ 0 ] for x in self . sil_scores ], \"Silhouette Value\" : [ x [ 1 ] for x in self . sil_scores ], } fig = px . line ( pd . DataFrame ( plot_data ), x = \"Number of clusters\" , y = \"Silhouette Value\" , ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot scores method!\" )","title":"clustering"},{"location":"clustering/#shift.clustering.Clustering","text":"Bases: ABC Abstract interface for implementing clustering subclass Source code in shift\\clustering.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class Clustering ( ABC ): \"\"\"Abstract interface for implementing clustering subclass\"\"\" @abstractmethod def get_clusters ( self , x_array : List [ list ]) -> dict : \"\"\"Method for creating and returning clusters. Subclass inhereting this class must implement this method and should return the clusters in the following format. ```json {\"labels\": [0,1,1], \"centre\": [(0,0), (2,2)]} ``` Returns: dict: A dictionary containing cluster labels and cluster centers \"\"\" pass @abstractmethod def plot_clusters ( self ) -> None : \"\"\"Method to plot clusters Raises: EarlyMethodCallError: If this method is called before calling `get_clusters` method. \"\"\" pass","title":"Clustering"},{"location":"clustering/#shift.clustering.Clustering.get_clusters","text":"Method for creating and returning clusters. Subclass inhereting this class must implement this method and should return the clusters in the following format. { \"labels\" : [ 0 , 1 , 1 ], \"centre\" : [ ( 0 , 0 ) , ( 2 , 2 ) ]} Returns: Name Type Description dict dict A dictionary containing cluster labels and cluster centers Source code in shift\\clustering.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 @abstractmethod def get_clusters ( self , x_array : List [ list ]) -> dict : \"\"\"Method for creating and returning clusters. Subclass inhereting this class must implement this method and should return the clusters in the following format. ```json {\"labels\": [0,1,1], \"centre\": [(0,0), (2,2)]} ``` Returns: dict: A dictionary containing cluster labels and cluster centers \"\"\" pass","title":"get_clusters()"},{"location":"clustering/#shift.clustering.Clustering.plot_clusters","text":"Method to plot clusters Raises: Type Description EarlyMethodCallError If this method is called before calling get_clusters method. Source code in shift\\clustering.py 84 85 86 87 88 89 90 91 @abstractmethod def plot_clusters ( self ) -> None : \"\"\"Method to plot clusters Raises: EarlyMethodCallError: If this method is called before calling `get_clusters` method. \"\"\" pass","title":"plot_clusters()"},{"location":"clustering/#shift.clustering.KmeansClustering","text":"Bases: Clustering Class implementing Kmeans clustering. Attributes: Name Type Description num_of_clusters Union [ str , int ] Number of clusters to be used cluster_centers List [ Sequece ] List of cluster center labels list Integer label for each location indicating which cluster they belong to xarray List [ Sequece ] List of location pairs for which clustering is performed optimal_clusters int Optimal number of clusters created if num_of_clusters passed is optimal Source code in shift\\clustering.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 class KmeansClustering ( Clustering ): \"\"\"Class implementing Kmeans clustering. Attributes: num_of_clusters (Union[str, int]): Number of clusters to be used cluster_centers (List[Sequece]): List of cluster center labels (list): Integer label for each location indicating which cluster they belong to xarray (List[Sequece]): List of location pairs for which clustering is performed optimal_clusters (int): Optimal number of clusters created if `num_of_clusters` passed is `optimal` \"\"\" def __init__ ( self , num_of_clusters : Union [ str , int ] = \"optimal\" ) -> None : \"\"\"Constructor for `KmeansClustering` class. Args: num_of_clusters (Union[str, int]): Number of clusters to be used Raises: NumberOfClusterNotInRangeError: if `num_of_clusters` speecified is less than MIN_NUM_CLUSTER constants module. \"\"\" self . num_of_clusters = num_of_clusters if isinstance ( self . num_of_clusters , int ): if self . num_of_clusters < MIN_NUM_CLUSTER : raise NumberOfClusterNotInRangeError ( self . num_of_clusters ) def plot_clusters ( self ): \"\"\"Refer to the base class for details.\"\"\" if ( hasattr ( self , \"x_array\" ) and hasattr ( self , \"labels\" ) and hasattr ( self , \"clsuter_centers\" ) ): plot_data = { \"x\" : [], \"y\" : [], \"label\" : []} for d , label in zip ( self . x_array , self . labels ): plot_data [ \"x\" ] . append ( d [ 0 ]) plot_data [ \"y\" ] . append ( d [ 1 ]) plot_data [ \"label\" ] . append ( label ) fig = px . scatter ( pd . DataFrame ( plot_data ), x = \"x\" , y = \"y\" , color = \"label\" ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot clusters method!\" ) def plot_scores ( self ): \"\"\"Method for plotting scores Note: Only use this method if `num_of_clusters` passed is `optimal`. Raises: EarlyMethodCallError: If called before calling `get_clusters` method. \"\"\" if hasattr ( self , \"sil_scores\" ): plot_data = { \"Number of clusters\" : [ x [ 0 ] for x in self . sil_scores ], \"Silhouette Value\" : [ x [ 1 ] for x in self . sil_scores ], } fig = px . line ( pd . DataFrame ( plot_data ), x = \"Number of clusters\" , y = \"Silhouette Value\" , ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot scores method!\" ) def get_clusters ( self , x_array : list ) -> dict : \"\"\"Refer to the base class for details. Raises: WrongInputUsed: If the number of clusters passed is invalid. \"\"\" self . x_array = x_array if isinstance ( self . num_of_clusters , int ): kmeans = KMeans ( n_clusters = self . num_of_clusters , random_state = 0 ) . fit ( x_array ) else : if self . num_of_clusters == \"optimal\" : \"\"\"Let's try to find optimal number of clusters\"\"\" self . sil_scores = [] for k in range ( 2 , MAX_KMEANS_LOOP ): kmeans = KMeans ( n_clusters = k ) . fit ( x_array ) labels = kmeans . labels_ self . sil_scores . append ( ( k , silhouette_score ( x_array , labels , metric = \"euclidean\" ), ) ) # Break the loop if Silhouette score starts to decrease if k > 2 : if ( self . sil_scores [ k - 2 ][ 1 ] < self . sil_scores [ k - 3 ][ 1 ] ): break if k == MAX_KMEANS_LOOP - 1 : raise MaxLoopReachedForKmeans () kmeans = KMeans ( n_clusters = k - 1 , random_state = 0 ) . fit ( x_array ) self . optimal_clusters = k - 1 else : raise WrongInputUsed ( f \"For now number of clusters can be either integer number or 'optimal' ! You provided { self . num_of_clusters } \" ) self . labels = kmeans . labels_ self . cluster_centers = kmeans . cluster_centers_ return { \"labels\" : self . labels , \"centre\" : self . cluster_centers }","title":"KmeansClustering"},{"location":"clustering/#shift.clustering.KmeansClustering.__init__","text":"Constructor for KmeansClustering class. Parameters: Name Type Description Default num_of_clusters Union [ str , int ] Number of clusters to be used 'optimal' Raises: Type Description NumberOfClusterNotInRangeError if num_of_clusters speecified is less than MIN_NUM_CLUSTER constants module. Source code in shift\\clustering.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def __init__ ( self , num_of_clusters : Union [ str , int ] = \"optimal\" ) -> None : \"\"\"Constructor for `KmeansClustering` class. Args: num_of_clusters (Union[str, int]): Number of clusters to be used Raises: NumberOfClusterNotInRangeError: if `num_of_clusters` speecified is less than MIN_NUM_CLUSTER constants module. \"\"\" self . num_of_clusters = num_of_clusters if isinstance ( self . num_of_clusters , int ): if self . num_of_clusters < MIN_NUM_CLUSTER : raise NumberOfClusterNotInRangeError ( self . num_of_clusters )","title":"__init__()"},{"location":"clustering/#shift.clustering.KmeansClustering.get_clusters","text":"Refer to the base class for details. Raises: Type Description WrongInputUsed If the number of clusters passed is invalid. Source code in shift\\clustering.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def get_clusters ( self , x_array : list ) -> dict : \"\"\"Refer to the base class for details. Raises: WrongInputUsed: If the number of clusters passed is invalid. \"\"\" self . x_array = x_array if isinstance ( self . num_of_clusters , int ): kmeans = KMeans ( n_clusters = self . num_of_clusters , random_state = 0 ) . fit ( x_array ) else : if self . num_of_clusters == \"optimal\" : \"\"\"Let's try to find optimal number of clusters\"\"\" self . sil_scores = [] for k in range ( 2 , MAX_KMEANS_LOOP ): kmeans = KMeans ( n_clusters = k ) . fit ( x_array ) labels = kmeans . labels_ self . sil_scores . append ( ( k , silhouette_score ( x_array , labels , metric = \"euclidean\" ), ) ) # Break the loop if Silhouette score starts to decrease if k > 2 : if ( self . sil_scores [ k - 2 ][ 1 ] < self . sil_scores [ k - 3 ][ 1 ] ): break if k == MAX_KMEANS_LOOP - 1 : raise MaxLoopReachedForKmeans () kmeans = KMeans ( n_clusters = k - 1 , random_state = 0 ) . fit ( x_array ) self . optimal_clusters = k - 1 else : raise WrongInputUsed ( f \"For now number of clusters can be either integer number or 'optimal' ! You provided { self . num_of_clusters } \" ) self . labels = kmeans . labels_ self . cluster_centers = kmeans . cluster_centers_ return { \"labels\" : self . labels , \"centre\" : self . cluster_centers }","title":"get_clusters()"},{"location":"clustering/#shift.clustering.KmeansClustering.plot_clusters","text":"Refer to the base class for details. Source code in shift\\clustering.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def plot_clusters ( self ): \"\"\"Refer to the base class for details.\"\"\" if ( hasattr ( self , \"x_array\" ) and hasattr ( self , \"labels\" ) and hasattr ( self , \"clsuter_centers\" ) ): plot_data = { \"x\" : [], \"y\" : [], \"label\" : []} for d , label in zip ( self . x_array , self . labels ): plot_data [ \"x\" ] . append ( d [ 0 ]) plot_data [ \"y\" ] . append ( d [ 1 ]) plot_data [ \"label\" ] . append ( label ) fig = px . scatter ( pd . DataFrame ( plot_data ), x = \"x\" , y = \"y\" , color = \"label\" ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot clusters method!\" )","title":"plot_clusters()"},{"location":"clustering/#shift.clustering.KmeansClustering.plot_scores","text":"Method for plotting scores Note Only use this method if num_of_clusters passed is optimal . Raises: Type Description EarlyMethodCallError If called before calling get_clusters method. Source code in shift\\clustering.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def plot_scores ( self ): \"\"\"Method for plotting scores Note: Only use this method if `num_of_clusters` passed is `optimal`. Raises: EarlyMethodCallError: If called before calling `get_clusters` method. \"\"\" if hasattr ( self , \"sil_scores\" ): plot_data = { \"Number of clusters\" : [ x [ 0 ] for x in self . sil_scores ], \"Silhouette Value\" : [ x [ 1 ] for x in self . sil_scores ], } fig = px . line ( pd . DataFrame ( plot_data ), x = \"Number of clusters\" , y = \"Silhouette Value\" , ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot scores method!\" )","title":"plot_scores()"},{"location":"developers-guide/","text":"","title":"Guide to Developers"},{"location":"explanation/","text":"","title":"Theoritical Explanation"},{"location":"geometry/","text":"Handles creation and management of geometries. This module manages creation of geometries from csv file as well as openstreet data. Contains abstract as well as concrete classes for creating geometries. Examples: Get the buildings from chennai and prints one of the building geometry. >>> from shift.geometry import BuildingsFromPlace >>> g = BuildingsFromPlace ( \"Chennai, India\" ) >>> geometries = g . get_geometries () >>> print ( geometries [ 0 ]) BuildingGeometry Bases: Geometry Implementation for Building geometry. Source code in shift\\geometry.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class BuildingGeometry ( Geometry ): \"\"\"Implementation for Building geometry.\"\"\" @property def area ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _area @area . setter def area ( self , area : float ) -> None : \"\"\"Setter method for area property of a building\"\"\" if area < 0 : raise NegativeAreaError ( area ) self . _area = area def __repr__ ( self ): return f \"Building( Latitude = { self . latitude } , Longitude = { self . longitude } , Area = { self . area } )\" area () writable property float: Area property of a building Source code in shift\\geometry.py 111 112 113 114 @property def area ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _area BuildingsFromPlace Bases: OpenStreetBuildingGeometries Getting building geometries from a place address within bounding box. Attributes: Name Type Description place str Any place in string format e.g. chennai, india max_dist float Distance in meter from the point to create a bounding box Source code in shift\\geometry.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 class BuildingsFromPlace ( OpenStreetBuildingGeometries ): \"\"\"Getting building geometries from a place address within bounding box. Attributes: place (str): Any place in string format e.g. chennai, india max_dist (float): Distance in meter from the point to create a bounding box \"\"\" def __init__ ( self , place : str , max_dist = 1000 ) -> None : \"\"\"Instantiating the class. Args: place (str): Any place in string format e.g. chennai, india max_dist (float): Distance in meter from the place to create a bounding box \"\"\" # e.g. Chennai, India self . place = place self . max_dist = max_dist def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_address ( self . place , { \"building\" : True }, dist = self . max_dist ) __init__ ( place , max_dist = 1000 ) Instantiating the class. Parameters: Name Type Description Default place str Any place in string format e.g. chennai, india required max_dist float Distance in meter from the place to create a bounding box 1000 Source code in shift\\geometry.py 312 313 314 315 316 317 318 319 320 321 322 323 def __init__ ( self , place : str , max_dist = 1000 ) -> None : \"\"\"Instantiating the class. Args: place (str): Any place in string format e.g. chennai, india max_dist (float): Distance in meter from the place to create a bounding box \"\"\" # e.g. Chennai, India self . place = place self . max_dist = max_dist get_gdf () Refer to base class for details. Source code in shift\\geometry.py 325 326 327 328 329 def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_address ( self . place , { \"building\" : True }, dist = self . max_dist ) BuildingsFromPoint Bases: OpenStreetBuildingGeometries Getting building geometries from single point within bounding box. Attributes: Name Type Description point Sequence Point in (longitude, latitude) format max_dist float Distance in meter from the point to create a bounding box Source code in shift\\geometry.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 class BuildingsFromPoint ( OpenStreetBuildingGeometries ): \"\"\"Getting building geometries from single point within bounding box. Attributes: point (Sequence): Point in (longitude, latitude) format max_dist (float): Distance in meter from the point to create a bounding box \"\"\" def __init__ ( self , point : Sequence , max_dist : float = 1000 ) -> None : \"\"\"Instantiating the class. Args: point (Sequence): Point in (longitude, latitude) format max_dist (float): Distance in meter from the point to create a bounding box \"\"\" # e.g. (13.242134, 80.275948) self . point = point self . max_dist = max_dist def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_point ( self . point , { \"building\" : True }, dist = self . max_dist ) __init__ ( point , max_dist = 1000 ) Instantiating the class. Parameters: Name Type Description Default point Sequence Point in (longitude, latitude) format required max_dist float Distance in meter from the point to create a bounding box 1000 Source code in shift\\geometry.py 285 286 287 288 289 290 291 292 293 294 295 def __init__ ( self , point : Sequence , max_dist : float = 1000 ) -> None : \"\"\"Instantiating the class. Args: point (Sequence): Point in (longitude, latitude) format max_dist (float): Distance in meter from the point to create a bounding box \"\"\" # e.g. (13.242134, 80.275948) self . point = point self . max_dist = max_dist get_gdf () Refer to base class for details. Source code in shift\\geometry.py 297 298 299 300 301 def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_point ( self . point , { \"building\" : True }, dist = self . max_dist ) BuildingsFromPolygon Bases: OpenStreetBuildingGeometries Getting building geometries from a given polygon. Attributes: Name Type Description polygon List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] Source code in shift\\geometry.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 class BuildingsFromPolygon ( OpenStreetBuildingGeometries ): \"\"\"Getting building geometries from a given polygon. Attributes: polygon: List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] \"\"\" def __init__ ( self , polygon : List [ list ]) -> None : \"\"\"Instantiating the class. Args: polygon: List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] \"\"\" self . polygon = polygon def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_polygon ( self . polygon , { \"building\" : True }) __init__ ( polygon ) Instantiating the class. Parameters: Name Type Description Default polygon List [ list ] List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] required Source code in shift\\geometry.py 339 340 341 342 343 344 345 346 def __init__ ( self , polygon : List [ list ]) -> None : \"\"\"Instantiating the class. Args: polygon: List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] \"\"\" self . polygon = polygon get_gdf () Refer to base class for details. Source code in shift\\geometry.py 348 349 350 def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_polygon ( self . polygon , { \"building\" : True }) GeometriesFromCSV Bases: ABC Interface for getting geometries from CSV file Attributes: Name Type Description csv_file str Path to csv file df pd . DataFrame dataframe holding the content of csv file Source code in shift\\geometry.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class GeometriesFromCSV ( ABC ): \"\"\"Interface for getting geometries from CSV file Attributes: csv_file (str): Path to csv file df (pd.DataFrame): dataframe holding the content of csv file \"\"\" def __init__ ( self , csv_file : str ) -> None : \"\"\"Method for instantiationg the class. Args: csv_file (str): Path to valid csv file Raises: FileNotFoundError: If csv file is not found NotCompatibleFileError: If the file pssed is not csv \"\"\" self . csv_file = csv_file if not os . path . exists ( csv_file ): raise FileNotFoundError ( csv_file ) else : if not csv_file . endswith ( \".csv\" ): raise NotCompatibleFileError ( csv_file , \".csv\" ) self . df = pd . read_csv ( csv_file ) self . validate () @abstractmethod def validate ( self ) -> bool : \"\"\"Child class must implement validate method.\"\"\" pass @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Child class must implement method to return list of geometries.\"\"\" pass __init__ ( csv_file ) Method for instantiationg the class. Parameters: Name Type Description Default csv_file str Path to valid csv file required Raises: Type Description FileNotFoundError If csv file is not found NotCompatibleFileError If the file pssed is not csv Source code in shift\\geometry.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def __init__ ( self , csv_file : str ) -> None : \"\"\"Method for instantiationg the class. Args: csv_file (str): Path to valid csv file Raises: FileNotFoundError: If csv file is not found NotCompatibleFileError: If the file pssed is not csv \"\"\" self . csv_file = csv_file if not os . path . exists ( csv_file ): raise FileNotFoundError ( csv_file ) else : if not csv_file . endswith ( \".csv\" ): raise NotCompatibleFileError ( csv_file , \".csv\" ) self . df = pd . read_csv ( csv_file ) self . validate () get_geometries () abstractmethod Child class must implement method to return list of geometries. Source code in shift\\geometry.py 179 180 181 182 @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Child class must implement method to return list of geometries.\"\"\" pass validate () abstractmethod Child class must implement validate method. Source code in shift\\geometry.py 174 175 176 177 @abstractmethod def validate ( self ) -> bool : \"\"\"Child class must implement validate method.\"\"\" pass Geometry Bases: ABC Interface for Geometry object. Source code in shift\\geometry.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class Geometry ( ABC ): \"\"\"Interface for Geometry object.\"\"\" @property def latitude ( self ) -> float : \"\"\"float: Latitude property of a building\"\"\" return self . _latitude @latitude . setter def latitude ( self , latitude : float ) -> None : \"\"\"Setter method for latitude property of a building\"\"\" if latitude < MIN_LATITUDE or latitude > MAX_LATITUDE : raise LatitudeNotInRangeError ( latitude ) self . _latitude = latitude @property def longitude ( self ) -> float : \"\"\"float: Longitude property of a building\"\"\" return self . _longitude @longitude . setter def longitude ( self , longitude : float ) -> None : \"\"\"Setter method for longitude property of a building\"\"\" if longitude < MIN_LONGITUDE or longitude > MAX_LONGITUDE : raise LongitudeNotInRangeError ( longitude ) self . _longitude = longitude def __eq__ ( self , other ): return ( self . latitude == other . latitude and self . longitude == other . longitude ) def __hash__ ( self ): return hash (( self . latitude , self . longitude )) latitude () writable property float: Latitude property of a building Source code in shift\\geometry.py 74 75 76 77 @property def latitude ( self ) -> float : \"\"\"float: Latitude property of a building\"\"\" return self . _latitude longitude () writable property float: Longitude property of a building Source code in shift\\geometry.py 86 87 88 89 @property def longitude ( self ) -> float : \"\"\"float: Longitude property of a building\"\"\" return self . _longitude OpenStreetBuildingGeometries Bases: OpenStreetGeometries Concrete implementations of open street building geometries Source code in shift\\geometry.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 class OpenStreetBuildingGeometries ( OpenStreetGeometries ): \"\"\"Concrete implementations of open street building geometries\"\"\" def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Refer to base class for details.\"\"\" # Create container for holding list of geometries concrete_geometries = [] # Get geo dataframe object implemented by child OpenStreet Geometries subclass gdf_data = self . get_gdf () . to_dict ( orient = \"records\" ) # Loop through all the rows in geo dataframe to create list of concrete geometries for row in gdf_data : # Looping through only either point or polygon geometries if row [ \"geometry\" ] . geom_type in [ \"Point\" , \"Polygon\" ]: if row [ \"geometry\" ] . geom_type == \"Point\" : centre = list ( row [ \"geometry\" ] . coords )[ 0 ] area = 0 else : centre = list ( row [ \"geometry\" ] . centroid . coords )[ 0 ] # By default shapely gives area in square degrees # By assuming the earth to be a perfect square of 6370 meter square # area can be computed as below but it's not accurate however does the job for now area = row [ \"geometry\" ] . area * 6370 ** 2 # Create individual geometry geometry = BuildingGeometry () geometry . latitude = centre [ 1 ] geometry . longitude = centre [ 0 ] geometry . area = round ( area , 2 ) if geometry not in concrete_geometries : concrete_geometries . append ( geometry ) return concrete_geometries get_geometries () Refer to base class for details. Source code in shift\\geometry.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Refer to base class for details.\"\"\" # Create container for holding list of geometries concrete_geometries = [] # Get geo dataframe object implemented by child OpenStreet Geometries subclass gdf_data = self . get_gdf () . to_dict ( orient = \"records\" ) # Loop through all the rows in geo dataframe to create list of concrete geometries for row in gdf_data : # Looping through only either point or polygon geometries if row [ \"geometry\" ] . geom_type in [ \"Point\" , \"Polygon\" ]: if row [ \"geometry\" ] . geom_type == \"Point\" : centre = list ( row [ \"geometry\" ] . coords )[ 0 ] area = 0 else : centre = list ( row [ \"geometry\" ] . centroid . coords )[ 0 ] # By default shapely gives area in square degrees # By assuming the earth to be a perfect square of 6370 meter square # area can be computed as below but it's not accurate however does the job for now area = row [ \"geometry\" ] . area * 6370 ** 2 # Create individual geometry geometry = BuildingGeometry () geometry . latitude = centre [ 1 ] geometry . longitude = centre [ 0 ] geometry . area = round ( area , 2 ) if geometry not in concrete_geometries : concrete_geometries . append ( geometry ) return concrete_geometries OpenStreetGeometries Bases: ABC Interface for getting geometries from OpenStreet data. Source code in shift\\geometry.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 class OpenStreetGeometries ( ABC ): \"\"\"Interface for getting geometries from OpenStreet data.\"\"\" @abstractmethod def get_gdf ( self ) -> pd . DataFrame : \"\"\"Method to return the geo dataframe containing all the buildings. Returns: pd.DataFrame: Geo dataframe containing all the buildings. \"\"\" pass @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Method to return all the geometry objects. Returns: List[Geometry]: list of all the building geometry objects. \"\"\" pass get_gdf () abstractmethod Method to return the geo dataframe containing all the buildings. Returns: Type Description pd . DataFrame pd.DataFrame: Geo dataframe containing all the buildings. Source code in shift\\geometry.py 217 218 219 220 221 222 223 224 @abstractmethod def get_gdf ( self ) -> pd . DataFrame : \"\"\"Method to return the geo dataframe containing all the buildings. Returns: pd.DataFrame: Geo dataframe containing all the buildings. \"\"\" pass get_geometries () abstractmethod Method to return all the geometry objects. Returns: Type Description List [ Geometry ] List[Geometry]: list of all the building geometry objects. Source code in shift\\geometry.py 226 227 228 229 230 231 232 233 @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Method to return all the geometry objects. Returns: List[Geometry]: list of all the building geometry objects. \"\"\" pass SimpleLoadGeometriesFromCSV Bases: GeometriesFromCSV Concrete implementations for getting simple load geometries from CSV file. Refer to the base class for more deatils on how to construct the object. Source code in shift\\geometry.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 class SimpleLoadGeometriesFromCSV ( GeometriesFromCSV ): \"\"\"Concrete implementations for getting simple load geometries from CSV file. Refer to the base class for more deatils on how to construct the object. \"\"\" def get_geometries ( self ): \"\"\"Method to get all the gepmetries from csv.\"\"\" # Let's loop through all records and create all the geometries concrete_geometries = [] for record in self . df . to_dict ( orient = \"records\" ): geometry = SimpleLoadGeometry () geometry . latitude = record [ \"latitude\" ] geometry . longitude = record [ \"longitude\" ] geometry . kw = record [ \"kw\" ] concrete_geometries . append ( geometry ) return concrete_geometries def validate ( self ): \"\"\"Method to validate the content of csv file.\"\"\" return df_validator ( SIMPLELOADGEOMETRY_SCHEMA , self . df ) get_geometries () Method to get all the gepmetries from csv. Source code in shift\\geometry.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def get_geometries ( self ): \"\"\"Method to get all the gepmetries from csv.\"\"\" # Let's loop through all records and create all the geometries concrete_geometries = [] for record in self . df . to_dict ( orient = \"records\" ): geometry = SimpleLoadGeometry () geometry . latitude = record [ \"latitude\" ] geometry . longitude = record [ \"longitude\" ] geometry . kw = record [ \"kw\" ] concrete_geometries . append ( geometry ) return concrete_geometries validate () Method to validate the content of csv file. Source code in shift\\geometry.py 209 210 211 def validate ( self ): \"\"\"Method to validate the content of csv file.\"\"\" return df_validator ( SIMPLELOADGEOMETRY_SCHEMA , self . df ) SimpleLoadGeometry Bases: Geometry Implementation for simple load point geometry Source code in shift\\geometry.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 class SimpleLoadGeometry ( Geometry ): \"\"\"Implementation for simple load point geometry\"\"\" @property def kw ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _kw @kw . setter def kw ( self , kw : float ) -> None : \"\"\"Setter method for area property of a building\"\"\" self . _kw = kw def __repr__ ( self ): return f \"Building( Latitude = { self . latitude } , Longitude = { self . longitude } , kW = { self . kw } )\" kw () writable property float: Area property of a building Source code in shift\\geometry.py 130 131 132 133 @property def kw ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _kw","title":"geometry"},{"location":"geometry/#shift.geometry.BuildingGeometry","text":"Bases: Geometry Implementation for Building geometry. Source code in shift\\geometry.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class BuildingGeometry ( Geometry ): \"\"\"Implementation for Building geometry.\"\"\" @property def area ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _area @area . setter def area ( self , area : float ) -> None : \"\"\"Setter method for area property of a building\"\"\" if area < 0 : raise NegativeAreaError ( area ) self . _area = area def __repr__ ( self ): return f \"Building( Latitude = { self . latitude } , Longitude = { self . longitude } , Area = { self . area } )\"","title":"BuildingGeometry"},{"location":"geometry/#shift.geometry.BuildingGeometry.area","text":"float: Area property of a building Source code in shift\\geometry.py 111 112 113 114 @property def area ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _area","title":"area()"},{"location":"geometry/#shift.geometry.BuildingsFromPlace","text":"Bases: OpenStreetBuildingGeometries Getting building geometries from a place address within bounding box. Attributes: Name Type Description place str Any place in string format e.g. chennai, india max_dist float Distance in meter from the point to create a bounding box Source code in shift\\geometry.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 class BuildingsFromPlace ( OpenStreetBuildingGeometries ): \"\"\"Getting building geometries from a place address within bounding box. Attributes: place (str): Any place in string format e.g. chennai, india max_dist (float): Distance in meter from the point to create a bounding box \"\"\" def __init__ ( self , place : str , max_dist = 1000 ) -> None : \"\"\"Instantiating the class. Args: place (str): Any place in string format e.g. chennai, india max_dist (float): Distance in meter from the place to create a bounding box \"\"\" # e.g. Chennai, India self . place = place self . max_dist = max_dist def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_address ( self . place , { \"building\" : True }, dist = self . max_dist )","title":"BuildingsFromPlace"},{"location":"geometry/#shift.geometry.BuildingsFromPlace.__init__","text":"Instantiating the class. Parameters: Name Type Description Default place str Any place in string format e.g. chennai, india required max_dist float Distance in meter from the place to create a bounding box 1000 Source code in shift\\geometry.py 312 313 314 315 316 317 318 319 320 321 322 323 def __init__ ( self , place : str , max_dist = 1000 ) -> None : \"\"\"Instantiating the class. Args: place (str): Any place in string format e.g. chennai, india max_dist (float): Distance in meter from the place to create a bounding box \"\"\" # e.g. Chennai, India self . place = place self . max_dist = max_dist","title":"__init__()"},{"location":"geometry/#shift.geometry.BuildingsFromPlace.get_gdf","text":"Refer to base class for details. Source code in shift\\geometry.py 325 326 327 328 329 def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_address ( self . place , { \"building\" : True }, dist = self . max_dist )","title":"get_gdf()"},{"location":"geometry/#shift.geometry.BuildingsFromPoint","text":"Bases: OpenStreetBuildingGeometries Getting building geometries from single point within bounding box. Attributes: Name Type Description point Sequence Point in (longitude, latitude) format max_dist float Distance in meter from the point to create a bounding box Source code in shift\\geometry.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 class BuildingsFromPoint ( OpenStreetBuildingGeometries ): \"\"\"Getting building geometries from single point within bounding box. Attributes: point (Sequence): Point in (longitude, latitude) format max_dist (float): Distance in meter from the point to create a bounding box \"\"\" def __init__ ( self , point : Sequence , max_dist : float = 1000 ) -> None : \"\"\"Instantiating the class. Args: point (Sequence): Point in (longitude, latitude) format max_dist (float): Distance in meter from the point to create a bounding box \"\"\" # e.g. (13.242134, 80.275948) self . point = point self . max_dist = max_dist def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_point ( self . point , { \"building\" : True }, dist = self . max_dist )","title":"BuildingsFromPoint"},{"location":"geometry/#shift.geometry.BuildingsFromPoint.__init__","text":"Instantiating the class. Parameters: Name Type Description Default point Sequence Point in (longitude, latitude) format required max_dist float Distance in meter from the point to create a bounding box 1000 Source code in shift\\geometry.py 285 286 287 288 289 290 291 292 293 294 295 def __init__ ( self , point : Sequence , max_dist : float = 1000 ) -> None : \"\"\"Instantiating the class. Args: point (Sequence): Point in (longitude, latitude) format max_dist (float): Distance in meter from the point to create a bounding box \"\"\" # e.g. (13.242134, 80.275948) self . point = point self . max_dist = max_dist","title":"__init__()"},{"location":"geometry/#shift.geometry.BuildingsFromPoint.get_gdf","text":"Refer to base class for details. Source code in shift\\geometry.py 297 298 299 300 301 def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_point ( self . point , { \"building\" : True }, dist = self . max_dist )","title":"get_gdf()"},{"location":"geometry/#shift.geometry.BuildingsFromPolygon","text":"Bases: OpenStreetBuildingGeometries Getting building geometries from a given polygon. Attributes: Name Type Description polygon List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] Source code in shift\\geometry.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 class BuildingsFromPolygon ( OpenStreetBuildingGeometries ): \"\"\"Getting building geometries from a given polygon. Attributes: polygon: List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] \"\"\" def __init__ ( self , polygon : List [ list ]) -> None : \"\"\"Instantiating the class. Args: polygon: List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] \"\"\" self . polygon = polygon def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_polygon ( self . polygon , { \"building\" : True })","title":"BuildingsFromPolygon"},{"location":"geometry/#shift.geometry.BuildingsFromPolygon.__init__","text":"Instantiating the class. Parameters: Name Type Description Default polygon List [ list ] List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] required Source code in shift\\geometry.py 339 340 341 342 343 344 345 346 def __init__ ( self , polygon : List [ list ]) -> None : \"\"\"Instantiating the class. Args: polygon: List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] \"\"\" self . polygon = polygon","title":"__init__()"},{"location":"geometry/#shift.geometry.BuildingsFromPolygon.get_gdf","text":"Refer to base class for details. Source code in shift\\geometry.py 348 349 350 def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_polygon ( self . polygon , { \"building\" : True })","title":"get_gdf()"},{"location":"geometry/#shift.geometry.GeometriesFromCSV","text":"Bases: ABC Interface for getting geometries from CSV file Attributes: Name Type Description csv_file str Path to csv file df pd . DataFrame dataframe holding the content of csv file Source code in shift\\geometry.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class GeometriesFromCSV ( ABC ): \"\"\"Interface for getting geometries from CSV file Attributes: csv_file (str): Path to csv file df (pd.DataFrame): dataframe holding the content of csv file \"\"\" def __init__ ( self , csv_file : str ) -> None : \"\"\"Method for instantiationg the class. Args: csv_file (str): Path to valid csv file Raises: FileNotFoundError: If csv file is not found NotCompatibleFileError: If the file pssed is not csv \"\"\" self . csv_file = csv_file if not os . path . exists ( csv_file ): raise FileNotFoundError ( csv_file ) else : if not csv_file . endswith ( \".csv\" ): raise NotCompatibleFileError ( csv_file , \".csv\" ) self . df = pd . read_csv ( csv_file ) self . validate () @abstractmethod def validate ( self ) -> bool : \"\"\"Child class must implement validate method.\"\"\" pass @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Child class must implement method to return list of geometries.\"\"\" pass","title":"GeometriesFromCSV"},{"location":"geometry/#shift.geometry.GeometriesFromCSV.__init__","text":"Method for instantiationg the class. Parameters: Name Type Description Default csv_file str Path to valid csv file required Raises: Type Description FileNotFoundError If csv file is not found NotCompatibleFileError If the file pssed is not csv Source code in shift\\geometry.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def __init__ ( self , csv_file : str ) -> None : \"\"\"Method for instantiationg the class. Args: csv_file (str): Path to valid csv file Raises: FileNotFoundError: If csv file is not found NotCompatibleFileError: If the file pssed is not csv \"\"\" self . csv_file = csv_file if not os . path . exists ( csv_file ): raise FileNotFoundError ( csv_file ) else : if not csv_file . endswith ( \".csv\" ): raise NotCompatibleFileError ( csv_file , \".csv\" ) self . df = pd . read_csv ( csv_file ) self . validate ()","title":"__init__()"},{"location":"geometry/#shift.geometry.GeometriesFromCSV.get_geometries","text":"Child class must implement method to return list of geometries. Source code in shift\\geometry.py 179 180 181 182 @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Child class must implement method to return list of geometries.\"\"\" pass","title":"get_geometries()"},{"location":"geometry/#shift.geometry.GeometriesFromCSV.validate","text":"Child class must implement validate method. Source code in shift\\geometry.py 174 175 176 177 @abstractmethod def validate ( self ) -> bool : \"\"\"Child class must implement validate method.\"\"\" pass","title":"validate()"},{"location":"geometry/#shift.geometry.Geometry","text":"Bases: ABC Interface for Geometry object. Source code in shift\\geometry.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class Geometry ( ABC ): \"\"\"Interface for Geometry object.\"\"\" @property def latitude ( self ) -> float : \"\"\"float: Latitude property of a building\"\"\" return self . _latitude @latitude . setter def latitude ( self , latitude : float ) -> None : \"\"\"Setter method for latitude property of a building\"\"\" if latitude < MIN_LATITUDE or latitude > MAX_LATITUDE : raise LatitudeNotInRangeError ( latitude ) self . _latitude = latitude @property def longitude ( self ) -> float : \"\"\"float: Longitude property of a building\"\"\" return self . _longitude @longitude . setter def longitude ( self , longitude : float ) -> None : \"\"\"Setter method for longitude property of a building\"\"\" if longitude < MIN_LONGITUDE or longitude > MAX_LONGITUDE : raise LongitudeNotInRangeError ( longitude ) self . _longitude = longitude def __eq__ ( self , other ): return ( self . latitude == other . latitude and self . longitude == other . longitude ) def __hash__ ( self ): return hash (( self . latitude , self . longitude ))","title":"Geometry"},{"location":"geometry/#shift.geometry.Geometry.latitude","text":"float: Latitude property of a building Source code in shift\\geometry.py 74 75 76 77 @property def latitude ( self ) -> float : \"\"\"float: Latitude property of a building\"\"\" return self . _latitude","title":"latitude()"},{"location":"geometry/#shift.geometry.Geometry.longitude","text":"float: Longitude property of a building Source code in shift\\geometry.py 86 87 88 89 @property def longitude ( self ) -> float : \"\"\"float: Longitude property of a building\"\"\" return self . _longitude","title":"longitude()"},{"location":"geometry/#shift.geometry.OpenStreetBuildingGeometries","text":"Bases: OpenStreetGeometries Concrete implementations of open street building geometries Source code in shift\\geometry.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 class OpenStreetBuildingGeometries ( OpenStreetGeometries ): \"\"\"Concrete implementations of open street building geometries\"\"\" def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Refer to base class for details.\"\"\" # Create container for holding list of geometries concrete_geometries = [] # Get geo dataframe object implemented by child OpenStreet Geometries subclass gdf_data = self . get_gdf () . to_dict ( orient = \"records\" ) # Loop through all the rows in geo dataframe to create list of concrete geometries for row in gdf_data : # Looping through only either point or polygon geometries if row [ \"geometry\" ] . geom_type in [ \"Point\" , \"Polygon\" ]: if row [ \"geometry\" ] . geom_type == \"Point\" : centre = list ( row [ \"geometry\" ] . coords )[ 0 ] area = 0 else : centre = list ( row [ \"geometry\" ] . centroid . coords )[ 0 ] # By default shapely gives area in square degrees # By assuming the earth to be a perfect square of 6370 meter square # area can be computed as below but it's not accurate however does the job for now area = row [ \"geometry\" ] . area * 6370 ** 2 # Create individual geometry geometry = BuildingGeometry () geometry . latitude = centre [ 1 ] geometry . longitude = centre [ 0 ] geometry . area = round ( area , 2 ) if geometry not in concrete_geometries : concrete_geometries . append ( geometry ) return concrete_geometries","title":"OpenStreetBuildingGeometries"},{"location":"geometry/#shift.geometry.OpenStreetBuildingGeometries.get_geometries","text":"Refer to base class for details. Source code in shift\\geometry.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Refer to base class for details.\"\"\" # Create container for holding list of geometries concrete_geometries = [] # Get geo dataframe object implemented by child OpenStreet Geometries subclass gdf_data = self . get_gdf () . to_dict ( orient = \"records\" ) # Loop through all the rows in geo dataframe to create list of concrete geometries for row in gdf_data : # Looping through only either point or polygon geometries if row [ \"geometry\" ] . geom_type in [ \"Point\" , \"Polygon\" ]: if row [ \"geometry\" ] . geom_type == \"Point\" : centre = list ( row [ \"geometry\" ] . coords )[ 0 ] area = 0 else : centre = list ( row [ \"geometry\" ] . centroid . coords )[ 0 ] # By default shapely gives area in square degrees # By assuming the earth to be a perfect square of 6370 meter square # area can be computed as below but it's not accurate however does the job for now area = row [ \"geometry\" ] . area * 6370 ** 2 # Create individual geometry geometry = BuildingGeometry () geometry . latitude = centre [ 1 ] geometry . longitude = centre [ 0 ] geometry . area = round ( area , 2 ) if geometry not in concrete_geometries : concrete_geometries . append ( geometry ) return concrete_geometries","title":"get_geometries()"},{"location":"geometry/#shift.geometry.OpenStreetGeometries","text":"Bases: ABC Interface for getting geometries from OpenStreet data. Source code in shift\\geometry.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 class OpenStreetGeometries ( ABC ): \"\"\"Interface for getting geometries from OpenStreet data.\"\"\" @abstractmethod def get_gdf ( self ) -> pd . DataFrame : \"\"\"Method to return the geo dataframe containing all the buildings. Returns: pd.DataFrame: Geo dataframe containing all the buildings. \"\"\" pass @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Method to return all the geometry objects. Returns: List[Geometry]: list of all the building geometry objects. \"\"\" pass","title":"OpenStreetGeometries"},{"location":"geometry/#shift.geometry.OpenStreetGeometries.get_gdf","text":"Method to return the geo dataframe containing all the buildings. Returns: Type Description pd . DataFrame pd.DataFrame: Geo dataframe containing all the buildings. Source code in shift\\geometry.py 217 218 219 220 221 222 223 224 @abstractmethod def get_gdf ( self ) -> pd . DataFrame : \"\"\"Method to return the geo dataframe containing all the buildings. Returns: pd.DataFrame: Geo dataframe containing all the buildings. \"\"\" pass","title":"get_gdf()"},{"location":"geometry/#shift.geometry.OpenStreetGeometries.get_geometries","text":"Method to return all the geometry objects. Returns: Type Description List [ Geometry ] List[Geometry]: list of all the building geometry objects. Source code in shift\\geometry.py 226 227 228 229 230 231 232 233 @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Method to return all the geometry objects. Returns: List[Geometry]: list of all the building geometry objects. \"\"\" pass","title":"get_geometries()"},{"location":"geometry/#shift.geometry.SimpleLoadGeometriesFromCSV","text":"Bases: GeometriesFromCSV Concrete implementations for getting simple load geometries from CSV file. Refer to the base class for more deatils on how to construct the object. Source code in shift\\geometry.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 class SimpleLoadGeometriesFromCSV ( GeometriesFromCSV ): \"\"\"Concrete implementations for getting simple load geometries from CSV file. Refer to the base class for more deatils on how to construct the object. \"\"\" def get_geometries ( self ): \"\"\"Method to get all the gepmetries from csv.\"\"\" # Let's loop through all records and create all the geometries concrete_geometries = [] for record in self . df . to_dict ( orient = \"records\" ): geometry = SimpleLoadGeometry () geometry . latitude = record [ \"latitude\" ] geometry . longitude = record [ \"longitude\" ] geometry . kw = record [ \"kw\" ] concrete_geometries . append ( geometry ) return concrete_geometries def validate ( self ): \"\"\"Method to validate the content of csv file.\"\"\" return df_validator ( SIMPLELOADGEOMETRY_SCHEMA , self . df )","title":"SimpleLoadGeometriesFromCSV"},{"location":"geometry/#shift.geometry.SimpleLoadGeometriesFromCSV.get_geometries","text":"Method to get all the gepmetries from csv. Source code in shift\\geometry.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def get_geometries ( self ): \"\"\"Method to get all the gepmetries from csv.\"\"\" # Let's loop through all records and create all the geometries concrete_geometries = [] for record in self . df . to_dict ( orient = \"records\" ): geometry = SimpleLoadGeometry () geometry . latitude = record [ \"latitude\" ] geometry . longitude = record [ \"longitude\" ] geometry . kw = record [ \"kw\" ] concrete_geometries . append ( geometry ) return concrete_geometries","title":"get_geometries()"},{"location":"geometry/#shift.geometry.SimpleLoadGeometriesFromCSV.validate","text":"Method to validate the content of csv file. Source code in shift\\geometry.py 209 210 211 def validate ( self ): \"\"\"Method to validate the content of csv file.\"\"\" return df_validator ( SIMPLELOADGEOMETRY_SCHEMA , self . df )","title":"validate()"},{"location":"geometry/#shift.geometry.SimpleLoadGeometry","text":"Bases: Geometry Implementation for simple load point geometry Source code in shift\\geometry.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 class SimpleLoadGeometry ( Geometry ): \"\"\"Implementation for simple load point geometry\"\"\" @property def kw ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _kw @kw . setter def kw ( self , kw : float ) -> None : \"\"\"Setter method for area property of a building\"\"\" self . _kw = kw def __repr__ ( self ): return f \"Building( Latitude = { self . latitude } , Longitude = { self . longitude } , kW = { self . kw } )\"","title":"SimpleLoadGeometry"},{"location":"geometry/#shift.geometry.SimpleLoadGeometry.kw","text":"float: Area property of a building Source code in shift\\geometry.py 130 131 132 133 @property def kw ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _kw","title":"kw()"},{"location":"how-to-guides/","text":"","title":"How to Guides"},{"location":"tutorials/","text":"","title":"Tutorials"}]}