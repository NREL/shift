{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Shift Generate distribution feeder model from OpenStreet data. Getting free distribution feeder models for your reasearch has never been easier. Installation Instruction We are in the processing of releasing a stable version to PyPI. Until it is ready for installing via pip, you can install this tool by cloning or downloading code from here . We recommend using Anaconda or Miniconda to create the environment for windows user. Use the commands below to create environment and install the shift tool. Windows 10 Mac OS & linux conda create -n shift python==3.9 conda install osmnx cd <cloned_repo> pip install -e. conda create -n shift python==3.9 cd <cloned_repo> pip install -e.","title":"Welcome"},{"location":"#shift","text":"Generate distribution feeder model from OpenStreet data. Getting free distribution feeder models for your reasearch has never been easier.","title":"Shift"},{"location":"#installation-instruction","text":"We are in the processing of releasing a stable version to PyPI. Until it is ready for installing via pip, you can install this tool by cloning or downloading code from here . We recommend using Anaconda or Miniconda to create the environment for windows user. Use the commands below to create environment and install the shift tool. Windows 10 Mac OS & linux conda create -n shift python==3.9 conda install osmnx cd <cloned_repo> pip install -e. conda create -n shift python==3.9 cd <cloned_repo> pip install -e.","title":"Installation Instruction"},{"location":"clustering/","text":"Contains abstract and concrete classes for implementing clustering. This module contains classes for managing clustering of location pairs. The cluster center is used as reference location to figure out transformer siting. In the process mapping between cluster center and locations is also created. Examples: Get the clusters from given list of location pairs and plot it. >>> from shift.clustering import KmeansClustering >>> import numpy as np >>> x_array = np . array ([[ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ]]) >>> cluster = KmeansClustering ( 2 ) >>> cluster . get_clusters ( x_array ) >>> cluster . plot_clusters () Clustering Bases: ABC Abstract interface for implementing clustering subclass Source code in shift\\clustering.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class Clustering ( ABC ): \"\"\"Abstract interface for implementing clustering subclass\"\"\" @abstractmethod def get_clusters ( self , x_array : List [ list ]) -> dict : \"\"\"Method for creating and returning clusters. Subclass inhereting this class must implement this method and should return the clusters in the following format. ```json {\"labels\": [0,1,1], \"centre\": [(0,0), (2,2)]} ``` Returns: dict: A dictionary containing cluster labels and cluster centers \"\"\" pass @abstractmethod def plot_clusters ( self ) -> None : \"\"\"Method to plot clusters Raises: EarlyMethodCallError: If this method is called before calling `get_clusters` method. \"\"\" pass get_clusters ( x_array ) abstractmethod Method for creating and returning clusters. Subclass inhereting this class must implement this method and should return the clusters in the following format. { \"labels\" : [ 0 , 1 , 1 ], \"centre\" : [ ( 0 , 0 ) , ( 2 , 2 ) ]} Returns: Name Type Description dict dict A dictionary containing cluster labels and cluster centers Source code in shift\\clustering.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 @abstractmethod def get_clusters ( self , x_array : List [ list ]) -> dict : \"\"\"Method for creating and returning clusters. Subclass inhereting this class must implement this method and should return the clusters in the following format. ```json {\"labels\": [0,1,1], \"centre\": [(0,0), (2,2)]} ``` Returns: dict: A dictionary containing cluster labels and cluster centers \"\"\" pass plot_clusters () abstractmethod Method to plot clusters Raises: Type Description EarlyMethodCallError If this method is called before calling get_clusters method. Source code in shift\\clustering.py 84 85 86 87 88 89 90 91 @abstractmethod def plot_clusters ( self ) -> None : \"\"\"Method to plot clusters Raises: EarlyMethodCallError: If this method is called before calling `get_clusters` method. \"\"\" pass KmeansClustering Bases: Clustering Class implementing Kmeans clustering. Attributes: Name Type Description num_of_clusters Union [ str , int ] Number of clusters to be used cluster_centers List [ Sequece ] List of cluster center labels list Integer label for each location indicating which cluster they belong to xarray List [ Sequece ] List of location pairs for which clustering is performed optimal_clusters int Optimal number of clusters created if num_of_clusters passed is optimal Source code in shift\\clustering.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 class KmeansClustering ( Clustering ): \"\"\"Class implementing Kmeans clustering. Attributes: num_of_clusters (Union[str, int]): Number of clusters to be used cluster_centers (List[Sequece]): List of cluster center labels (list): Integer label for each location indicating which cluster they belong to xarray (List[Sequece]): List of location pairs for which clustering is performed optimal_clusters (int): Optimal number of clusters created if `num_of_clusters` passed is `optimal` \"\"\" def __init__ ( self , num_of_clusters : Union [ str , int ] = \"optimal\" ) -> None : \"\"\"Constructor for `KmeansClustering` class. Args: num_of_clusters (Union[str, int]): Number of clusters to be used Raises: NumberOfClusterNotInRangeError: if `num_of_clusters` speecified is less than MIN_NUM_CLUSTER constants module. \"\"\" self . num_of_clusters = num_of_clusters if isinstance ( self . num_of_clusters , int ): if self . num_of_clusters < MIN_NUM_CLUSTER : raise NumberOfClusterNotInRangeError ( self . num_of_clusters ) def plot_clusters ( self ): \"\"\"Refer to the base class for details.\"\"\" if ( hasattr ( self , \"x_array\" ) and hasattr ( self , \"labels\" ) and hasattr ( self , \"clsuter_centers\" ) ): plot_data = { \"x\" : [], \"y\" : [], \"label\" : []} for d , label in zip ( self . x_array , self . labels ): plot_data [ \"x\" ] . append ( d [ 0 ]) plot_data [ \"y\" ] . append ( d [ 1 ]) plot_data [ \"label\" ] . append ( label ) fig = px . scatter ( pd . DataFrame ( plot_data ), x = \"x\" , y = \"y\" , color = \"label\" ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot clusters method!\" ) def plot_scores ( self ): \"\"\"Method for plotting scores Note: Only use this method if `num_of_clusters` passed is `optimal`. Raises: EarlyMethodCallError: If called before calling `get_clusters` method. \"\"\" if hasattr ( self , \"sil_scores\" ): plot_data = { \"Number of clusters\" : [ x [ 0 ] for x in self . sil_scores ], \"Silhouette Value\" : [ x [ 1 ] for x in self . sil_scores ], } fig = px . line ( pd . DataFrame ( plot_data ), x = \"Number of clusters\" , y = \"Silhouette Value\" , ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot scores method!\" ) def get_clusters ( self , x_array : list ) -> dict : \"\"\"Refer to the base class for details. Raises: WrongInputUsed: If the number of clusters passed is invalid. \"\"\" self . x_array = x_array if isinstance ( self . num_of_clusters , int ): kmeans = KMeans ( n_clusters = self . num_of_clusters , random_state = 0 ) . fit ( x_array ) else : if self . num_of_clusters == \"optimal\" : \"\"\"Let's try to find optimal number of clusters\"\"\" self . sil_scores = [] for k in range ( 2 , MAX_KMEANS_LOOP ): kmeans = KMeans ( n_clusters = k ) . fit ( x_array ) labels = kmeans . labels_ self . sil_scores . append ( ( k , silhouette_score ( x_array , labels , metric = \"euclidean\" ), ) ) # Break the loop if Silhouette score starts to decrease if k > 2 : if ( self . sil_scores [ k - 2 ][ 1 ] < self . sil_scores [ k - 3 ][ 1 ] ): break if k == MAX_KMEANS_LOOP - 1 : raise MaxLoopReachedForKmeans () kmeans = KMeans ( n_clusters = k - 1 , random_state = 0 ) . fit ( x_array ) self . optimal_clusters = k - 1 else : raise WrongInputUsed ( f \"For now number of clusters can be either integer number or 'optimal' ! You provided { self . num_of_clusters } \" ) self . labels = kmeans . labels_ self . cluster_centers = kmeans . cluster_centers_ return { \"labels\" : self . labels , \"centre\" : self . cluster_centers } __init__ ( num_of_clusters = 'optimal' ) Constructor for KmeansClustering class. Parameters: Name Type Description Default num_of_clusters Union [ str , int ] Number of clusters to be used 'optimal' Raises: Type Description NumberOfClusterNotInRangeError if num_of_clusters speecified is less than MIN_NUM_CLUSTER constants module. Source code in shift\\clustering.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def __init__ ( self , num_of_clusters : Union [ str , int ] = \"optimal\" ) -> None : \"\"\"Constructor for `KmeansClustering` class. Args: num_of_clusters (Union[str, int]): Number of clusters to be used Raises: NumberOfClusterNotInRangeError: if `num_of_clusters` speecified is less than MIN_NUM_CLUSTER constants module. \"\"\" self . num_of_clusters = num_of_clusters if isinstance ( self . num_of_clusters , int ): if self . num_of_clusters < MIN_NUM_CLUSTER : raise NumberOfClusterNotInRangeError ( self . num_of_clusters ) get_clusters ( x_array ) Refer to the base class for details. Raises: Type Description WrongInputUsed If the number of clusters passed is invalid. Source code in shift\\clustering.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def get_clusters ( self , x_array : list ) -> dict : \"\"\"Refer to the base class for details. Raises: WrongInputUsed: If the number of clusters passed is invalid. \"\"\" self . x_array = x_array if isinstance ( self . num_of_clusters , int ): kmeans = KMeans ( n_clusters = self . num_of_clusters , random_state = 0 ) . fit ( x_array ) else : if self . num_of_clusters == \"optimal\" : \"\"\"Let's try to find optimal number of clusters\"\"\" self . sil_scores = [] for k in range ( 2 , MAX_KMEANS_LOOP ): kmeans = KMeans ( n_clusters = k ) . fit ( x_array ) labels = kmeans . labels_ self . sil_scores . append ( ( k , silhouette_score ( x_array , labels , metric = \"euclidean\" ), ) ) # Break the loop if Silhouette score starts to decrease if k > 2 : if ( self . sil_scores [ k - 2 ][ 1 ] < self . sil_scores [ k - 3 ][ 1 ] ): break if k == MAX_KMEANS_LOOP - 1 : raise MaxLoopReachedForKmeans () kmeans = KMeans ( n_clusters = k - 1 , random_state = 0 ) . fit ( x_array ) self . optimal_clusters = k - 1 else : raise WrongInputUsed ( f \"For now number of clusters can be either integer number or 'optimal' ! You provided { self . num_of_clusters } \" ) self . labels = kmeans . labels_ self . cluster_centers = kmeans . cluster_centers_ return { \"labels\" : self . labels , \"centre\" : self . cluster_centers } plot_clusters () Refer to the base class for details. Source code in shift\\clustering.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def plot_clusters ( self ): \"\"\"Refer to the base class for details.\"\"\" if ( hasattr ( self , \"x_array\" ) and hasattr ( self , \"labels\" ) and hasattr ( self , \"clsuter_centers\" ) ): plot_data = { \"x\" : [], \"y\" : [], \"label\" : []} for d , label in zip ( self . x_array , self . labels ): plot_data [ \"x\" ] . append ( d [ 0 ]) plot_data [ \"y\" ] . append ( d [ 1 ]) plot_data [ \"label\" ] . append ( label ) fig = px . scatter ( pd . DataFrame ( plot_data ), x = \"x\" , y = \"y\" , color = \"label\" ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot clusters method!\" ) plot_scores () Method for plotting scores Note Only use this method if num_of_clusters passed is optimal . Raises: Type Description EarlyMethodCallError If called before calling get_clusters method. Source code in shift\\clustering.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def plot_scores ( self ): \"\"\"Method for plotting scores Note: Only use this method if `num_of_clusters` passed is `optimal`. Raises: EarlyMethodCallError: If called before calling `get_clusters` method. \"\"\" if hasattr ( self , \"sil_scores\" ): plot_data = { \"Number of clusters\" : [ x [ 0 ] for x in self . sil_scores ], \"Silhouette Value\" : [ x [ 1 ] for x in self . sil_scores ], } fig = px . line ( pd . DataFrame ( plot_data ), x = \"Number of clusters\" , y = \"Silhouette Value\" , ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot scores method!\" )","title":"clustering"},{"location":"clustering/#shift.clustering.Clustering","text":"Bases: ABC Abstract interface for implementing clustering subclass Source code in shift\\clustering.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class Clustering ( ABC ): \"\"\"Abstract interface for implementing clustering subclass\"\"\" @abstractmethod def get_clusters ( self , x_array : List [ list ]) -> dict : \"\"\"Method for creating and returning clusters. Subclass inhereting this class must implement this method and should return the clusters in the following format. ```json {\"labels\": [0,1,1], \"centre\": [(0,0), (2,2)]} ``` Returns: dict: A dictionary containing cluster labels and cluster centers \"\"\" pass @abstractmethod def plot_clusters ( self ) -> None : \"\"\"Method to plot clusters Raises: EarlyMethodCallError: If this method is called before calling `get_clusters` method. \"\"\" pass","title":"Clustering"},{"location":"clustering/#shift.clustering.Clustering.get_clusters","text":"Method for creating and returning clusters. Subclass inhereting this class must implement this method and should return the clusters in the following format. { \"labels\" : [ 0 , 1 , 1 ], \"centre\" : [ ( 0 , 0 ) , ( 2 , 2 ) ]} Returns: Name Type Description dict dict A dictionary containing cluster labels and cluster centers Source code in shift\\clustering.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 @abstractmethod def get_clusters ( self , x_array : List [ list ]) -> dict : \"\"\"Method for creating and returning clusters. Subclass inhereting this class must implement this method and should return the clusters in the following format. ```json {\"labels\": [0,1,1], \"centre\": [(0,0), (2,2)]} ``` Returns: dict: A dictionary containing cluster labels and cluster centers \"\"\" pass","title":"get_clusters()"},{"location":"clustering/#shift.clustering.Clustering.plot_clusters","text":"Method to plot clusters Raises: Type Description EarlyMethodCallError If this method is called before calling get_clusters method. Source code in shift\\clustering.py 84 85 86 87 88 89 90 91 @abstractmethod def plot_clusters ( self ) -> None : \"\"\"Method to plot clusters Raises: EarlyMethodCallError: If this method is called before calling `get_clusters` method. \"\"\" pass","title":"plot_clusters()"},{"location":"clustering/#shift.clustering.KmeansClustering","text":"Bases: Clustering Class implementing Kmeans clustering. Attributes: Name Type Description num_of_clusters Union [ str , int ] Number of clusters to be used cluster_centers List [ Sequece ] List of cluster center labels list Integer label for each location indicating which cluster they belong to xarray List [ Sequece ] List of location pairs for which clustering is performed optimal_clusters int Optimal number of clusters created if num_of_clusters passed is optimal Source code in shift\\clustering.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 class KmeansClustering ( Clustering ): \"\"\"Class implementing Kmeans clustering. Attributes: num_of_clusters (Union[str, int]): Number of clusters to be used cluster_centers (List[Sequece]): List of cluster center labels (list): Integer label for each location indicating which cluster they belong to xarray (List[Sequece]): List of location pairs for which clustering is performed optimal_clusters (int): Optimal number of clusters created if `num_of_clusters` passed is `optimal` \"\"\" def __init__ ( self , num_of_clusters : Union [ str , int ] = \"optimal\" ) -> None : \"\"\"Constructor for `KmeansClustering` class. Args: num_of_clusters (Union[str, int]): Number of clusters to be used Raises: NumberOfClusterNotInRangeError: if `num_of_clusters` speecified is less than MIN_NUM_CLUSTER constants module. \"\"\" self . num_of_clusters = num_of_clusters if isinstance ( self . num_of_clusters , int ): if self . num_of_clusters < MIN_NUM_CLUSTER : raise NumberOfClusterNotInRangeError ( self . num_of_clusters ) def plot_clusters ( self ): \"\"\"Refer to the base class for details.\"\"\" if ( hasattr ( self , \"x_array\" ) and hasattr ( self , \"labels\" ) and hasattr ( self , \"clsuter_centers\" ) ): plot_data = { \"x\" : [], \"y\" : [], \"label\" : []} for d , label in zip ( self . x_array , self . labels ): plot_data [ \"x\" ] . append ( d [ 0 ]) plot_data [ \"y\" ] . append ( d [ 1 ]) plot_data [ \"label\" ] . append ( label ) fig = px . scatter ( pd . DataFrame ( plot_data ), x = \"x\" , y = \"y\" , color = \"label\" ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot clusters method!\" ) def plot_scores ( self ): \"\"\"Method for plotting scores Note: Only use this method if `num_of_clusters` passed is `optimal`. Raises: EarlyMethodCallError: If called before calling `get_clusters` method. \"\"\" if hasattr ( self , \"sil_scores\" ): plot_data = { \"Number of clusters\" : [ x [ 0 ] for x in self . sil_scores ], \"Silhouette Value\" : [ x [ 1 ] for x in self . sil_scores ], } fig = px . line ( pd . DataFrame ( plot_data ), x = \"Number of clusters\" , y = \"Silhouette Value\" , ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot scores method!\" ) def get_clusters ( self , x_array : list ) -> dict : \"\"\"Refer to the base class for details. Raises: WrongInputUsed: If the number of clusters passed is invalid. \"\"\" self . x_array = x_array if isinstance ( self . num_of_clusters , int ): kmeans = KMeans ( n_clusters = self . num_of_clusters , random_state = 0 ) . fit ( x_array ) else : if self . num_of_clusters == \"optimal\" : \"\"\"Let's try to find optimal number of clusters\"\"\" self . sil_scores = [] for k in range ( 2 , MAX_KMEANS_LOOP ): kmeans = KMeans ( n_clusters = k ) . fit ( x_array ) labels = kmeans . labels_ self . sil_scores . append ( ( k , silhouette_score ( x_array , labels , metric = \"euclidean\" ), ) ) # Break the loop if Silhouette score starts to decrease if k > 2 : if ( self . sil_scores [ k - 2 ][ 1 ] < self . sil_scores [ k - 3 ][ 1 ] ): break if k == MAX_KMEANS_LOOP - 1 : raise MaxLoopReachedForKmeans () kmeans = KMeans ( n_clusters = k - 1 , random_state = 0 ) . fit ( x_array ) self . optimal_clusters = k - 1 else : raise WrongInputUsed ( f \"For now number of clusters can be either integer number or 'optimal' ! You provided { self . num_of_clusters } \" ) self . labels = kmeans . labels_ self . cluster_centers = kmeans . cluster_centers_ return { \"labels\" : self . labels , \"centre\" : self . cluster_centers }","title":"KmeansClustering"},{"location":"clustering/#shift.clustering.KmeansClustering.__init__","text":"Constructor for KmeansClustering class. Parameters: Name Type Description Default num_of_clusters Union [ str , int ] Number of clusters to be used 'optimal' Raises: Type Description NumberOfClusterNotInRangeError if num_of_clusters speecified is less than MIN_NUM_CLUSTER constants module. Source code in shift\\clustering.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def __init__ ( self , num_of_clusters : Union [ str , int ] = \"optimal\" ) -> None : \"\"\"Constructor for `KmeansClustering` class. Args: num_of_clusters (Union[str, int]): Number of clusters to be used Raises: NumberOfClusterNotInRangeError: if `num_of_clusters` speecified is less than MIN_NUM_CLUSTER constants module. \"\"\" self . num_of_clusters = num_of_clusters if isinstance ( self . num_of_clusters , int ): if self . num_of_clusters < MIN_NUM_CLUSTER : raise NumberOfClusterNotInRangeError ( self . num_of_clusters )","title":"__init__()"},{"location":"clustering/#shift.clustering.KmeansClustering.get_clusters","text":"Refer to the base class for details. Raises: Type Description WrongInputUsed If the number of clusters passed is invalid. Source code in shift\\clustering.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def get_clusters ( self , x_array : list ) -> dict : \"\"\"Refer to the base class for details. Raises: WrongInputUsed: If the number of clusters passed is invalid. \"\"\" self . x_array = x_array if isinstance ( self . num_of_clusters , int ): kmeans = KMeans ( n_clusters = self . num_of_clusters , random_state = 0 ) . fit ( x_array ) else : if self . num_of_clusters == \"optimal\" : \"\"\"Let's try to find optimal number of clusters\"\"\" self . sil_scores = [] for k in range ( 2 , MAX_KMEANS_LOOP ): kmeans = KMeans ( n_clusters = k ) . fit ( x_array ) labels = kmeans . labels_ self . sil_scores . append ( ( k , silhouette_score ( x_array , labels , metric = \"euclidean\" ), ) ) # Break the loop if Silhouette score starts to decrease if k > 2 : if ( self . sil_scores [ k - 2 ][ 1 ] < self . sil_scores [ k - 3 ][ 1 ] ): break if k == MAX_KMEANS_LOOP - 1 : raise MaxLoopReachedForKmeans () kmeans = KMeans ( n_clusters = k - 1 , random_state = 0 ) . fit ( x_array ) self . optimal_clusters = k - 1 else : raise WrongInputUsed ( f \"For now number of clusters can be either integer number or 'optimal' ! You provided { self . num_of_clusters } \" ) self . labels = kmeans . labels_ self . cluster_centers = kmeans . cluster_centers_ return { \"labels\" : self . labels , \"centre\" : self . cluster_centers }","title":"get_clusters()"},{"location":"clustering/#shift.clustering.KmeansClustering.plot_clusters","text":"Refer to the base class for details. Source code in shift\\clustering.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def plot_clusters ( self ): \"\"\"Refer to the base class for details.\"\"\" if ( hasattr ( self , \"x_array\" ) and hasattr ( self , \"labels\" ) and hasattr ( self , \"clsuter_centers\" ) ): plot_data = { \"x\" : [], \"y\" : [], \"label\" : []} for d , label in zip ( self . x_array , self . labels ): plot_data [ \"x\" ] . append ( d [ 0 ]) plot_data [ \"y\" ] . append ( d [ 1 ]) plot_data [ \"label\" ] . append ( label ) fig = px . scatter ( pd . DataFrame ( plot_data ), x = \"x\" , y = \"y\" , color = \"label\" ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot clusters method!\" )","title":"plot_clusters()"},{"location":"clustering/#shift.clustering.KmeansClustering.plot_scores","text":"Method for plotting scores Note Only use this method if num_of_clusters passed is optimal . Raises: Type Description EarlyMethodCallError If called before calling get_clusters method. Source code in shift\\clustering.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def plot_scores ( self ): \"\"\"Method for plotting scores Note: Only use this method if `num_of_clusters` passed is `optimal`. Raises: EarlyMethodCallError: If called before calling `get_clusters` method. \"\"\" if hasattr ( self , \"sil_scores\" ): plot_data = { \"Number of clusters\" : [ x [ 0 ] for x in self . sil_scores ], \"Silhouette Value\" : [ x [ 1 ] for x in self . sil_scores ], } fig = px . line ( pd . DataFrame ( plot_data ), x = \"Number of clusters\" , y = \"Silhouette Value\" , ) fig . show () else : raise EarlyMethodCallError ( f \"Call get_clusters() method first before calling plot scores method!\" )","title":"plot_scores()"},{"location":"developers-guide/","text":"","title":"Guide to Developers"},{"location":"exceptions/","text":"This module all the exceptions raised by this package. AdjustmentFactorNotInRangeError Bases: SeedBaseException Exception raised because adjustment factor not in range. Parameters: Name Type Description Default af float Adjustment factor property required Source code in shift\\exceptions.py 296 297 298 299 300 301 302 303 304 305 class AdjustmentFactorNotInRangeError ( SeedBaseException ): \"\"\"Exception raised because adjustment factor not in range. Args: af (float): Adjustment factor property \"\"\" def __init__ ( self , af : float ): self . message = f \"Adjustement factor { af } not in ( { MIN_ADJUSTMENT_FACTOR } , { MAX_ADJUSTMENT_FACTOR } ) range!\" super () . __init__ ( self . message ) AttributeDoesNotExistError Bases: SeedBaseException Method is called to early. Source code in shift\\exceptions.py 292 293 class AttributeDoesNotExistError ( SeedBaseException ): \"\"\"Method is called to early.\"\"\" CatalogNotFoundError Bases: SeedBaseException Exceptions raised because catalog requested is not found. Source code in shift\\exceptions.py 522 523 class CatalogNotFoundError ( SeedBaseException ): \"\"\"Exceptions raised because catalog requested is not found.\"\"\" ConductorNotFoundForKdrop Bases: SeedBaseException Exceptions raised because no conductor is found that satisfies the kdrop. Parameters: Name Type Description Default kdrop float Voltage drop property required Source code in shift\\exceptions.py 500 501 502 503 504 505 506 507 508 509 510 511 class ConductorNotFoundForKdrop ( SeedBaseException ): \"\"\"Exceptions raised because no conductor is found that satisfies the kdrop. Args: kdrop (float): Voltage drop property \"\"\" def __init__ ( self , kdrop : float ): self . message = ( f \"No conductor is found that satisfies kdrop of value { kdrop } \" ) super () . __init__ ( self . message ) CustomerInvalidPhase Bases: SeedBaseException Exceptions raised because number of phase for customer is greater than number of phase used in secondary. Parameters: Name Type Description Default customer_num_phase NumPhase Number of phase property for customer required secondary_num_phase NumPhase Number of phase for secondary lateral required Source code in shift\\exceptions.py 447 448 449 450 451 452 453 454 455 456 457 458 459 class CustomerInvalidPhase ( SeedBaseException ): \"\"\"Exceptions raised because number of phase for customer is greater than number of phase used in secondary. Args: customer_num_phase (NumPhase): Number of phase property for customer secondary_num_phase (NumPhase): Number of phase for secondary lateral \"\"\" def __init__ ( self , customer_num_phase : NumPhase , secondary_num_phase : NumPhase ): self . message = f \"Number of phase used for load { customer_num_phase } is greater than that used for secondary { secondary_num_phase } \" super () . __init__ ( self . message ) EarlyMethodCallError Bases: SeedBaseException Method is called to early. Source code in shift\\exceptions.py 288 289 class EarlyMethodCallError ( SeedBaseException ): \"\"\"Method is called to early.\"\"\" EmptyAssetStyleDict Bases: SeedBaseException Exception raised for empty style dict. Source code in shift\\exceptions.py 200 201 202 203 204 205 class EmptyAssetStyleDict ( SeedBaseException ): \"\"\"Exception raised for empty style dict.\"\"\" def __init__ ( self ): self . message = \"Asset specific style can not be empty in PLotlyGISNetworkPlot object\" super () . __init__ ( self . message ) EmptyCatalog Bases: SeedBaseException Exceptions raised because no catalog found. Source code in shift\\exceptions.py 321 322 class EmptyCatalog ( SeedBaseException ): \"\"\"Exceptions raised because no catalog found.\"\"\" FileNotFoundError Bases: SeedBaseException Exception raised because file path does not exist. Parameters: Name Type Description Default file_path str File path property required Source code in shift\\exceptions.py 139 140 141 142 143 144 145 146 147 148 class FileNotFoundError ( SeedBaseException ): \"\"\"Exception raised because file path does not exist. Args: file_path (str): File path property \"\"\" def __init__ ( self , file_path : str ): self . message = f \"File { file_path } does not exist!\" super () . __init__ ( self . message ) FolderNotFoundError Bases: SeedBaseException Exception raised because folder not found. Parameters: Name Type Description Default folder_path str Path to a invalid folder required Source code in shift\\exceptions.py 232 233 234 235 236 237 238 239 240 241 class FolderNotFoundError ( SeedBaseException ): \"\"\"Exception raised because folder not found. Args: folder_path (str): Path to a invalid folder \"\"\" def __init__ ( self , folder_path : str ): self . message = f \"Folder { folder_path } does not exist!\" super () . __init__ ( self . message ) HTkVlowerthanLTkVError Bases: SeedBaseException Exceptions raised because HT kV used is lower than LT kv used. Parameters: Name Type Description Default ht_kv float High tension kv property required lt_kv float Low tension kv property required Source code in shift\\exceptions.py 308 309 310 311 312 313 314 315 316 317 318 class HTkVlowerthanLTkVError ( SeedBaseException ): \"\"\"Exceptions raised because HT kV used is lower than LT kv used. Args: ht_kv (float): High tension kv property lt_kv (float): Low tension kv property \"\"\" def __init__ ( self , ht_kv : float , lt_kv : float ): self . message = f \"HT kV { ht_kv } must be higher than LT kV { lt_kv } !\" super () . __init__ ( self . message ) IncompleteGeometryConfigurationDict Bases: SeedBaseException Exceptions raised because of incomplete geometry configuration dict. Parameters: Name Type Description Default num_phase NumPhase Number of phase property required geometry_dict dict Geometry metadata required Source code in shift\\exceptions.py 487 488 489 490 491 492 493 494 495 496 497 class IncompleteGeometryConfigurationDict ( SeedBaseException ): \"\"\"Exceptions raised because of incomplete geometry configuration dict. Args: num_phase (NumPhase): Number of phase property geometry_dict (dict): Geometry metadata \"\"\" def __init__ ( self , num_phase : NumPhase , geometry_dict : dict ): self . message = f \" { num_phase } key does not exist in { geometry_dict } \" super () . __init__ ( self . message ) InvalidInputError Bases: SeedBaseException Exceptions raised because the input provided is not valid. Source code in shift\\exceptions.py 525 526 class InvalidInputError ( SeedBaseException ): \"\"\"Exceptions raised because the input provided is not valid. \"\"\" InvalidLengthUnitError Bases: SeedBaseException Exceptions raised because length unit is invalid. Parameters: Name Type Description Default unit str Line length unit used required Source code in shift\\exceptions.py 373 374 375 376 377 378 379 380 381 382 class InvalidLengthUnitError ( SeedBaseException ): \"\"\"Exceptions raised because length unit is invalid. Args: unit (str): Line length unit used \"\"\" def __init__ ( self , unit : str ): self . message = f \"Invalid length unit used { unit } please choose one of these units { VALID_LENGTH_UNITS } \" super () . __init__ ( self . message ) InvalidMapboxStyle Bases: SeedBaseException Exception raised because specified style is not accepted. Parameters: Name Type Description Default style str Style property used for mapbox required Source code in shift\\exceptions.py 188 189 190 191 192 193 194 195 196 197 class InvalidMapboxStyle ( SeedBaseException ): \"\"\"Exception raised because specified style is not accepted. Args: style (str): Style property used for mapbox \"\"\" def __init__ ( self , style : str ): self . message = f \"Style { style } is not a valid style. Please one of these styles { MAP_STYLES } \" super () . __init__ ( self . message ) InvalidNodeType Bases: SeedBaseException Exception because invalid node type is used. Parameters: Name Type Description Default node str Node type property required Source code in shift\\exceptions.py 220 221 222 223 224 225 226 227 228 229 class InvalidNodeType ( SeedBaseException ): \"\"\"Exception because invalid node type is used. Args: node (str): Node type property \"\"\" def __init__ ( self , node : str ): self . message = f \"Invalid node type: { node } , please make sure to use valid node types\" super () . __init__ ( self . message ) LatitudeNotInRangeError Bases: SeedBaseException Exception raised because latitude not in range. Parameters: Name Type Description Default latitude float Latitude property required Source code in shift\\exceptions.py 63 64 65 66 67 68 69 70 71 72 class LatitudeNotInRangeError ( SeedBaseException ): \"\"\"Exception raised because latitude not in range. Args: latitude (float): Latitude property \"\"\" def __init__ ( self , latitude : float ): self . message = f \"Latitude { latitude } not in ( { MIN_LATITUDE } , { MAX_LATITUDE } ) range!\" super () . __init__ ( self . message ) LongitudeNotInRangeError Bases: SeedBaseException Exception raised because longitude not in range. Parameters: Name Type Description Default longitude float Longitude property required Source code in shift\\exceptions.py 75 76 77 78 79 80 81 82 83 84 class LongitudeNotInRangeError ( SeedBaseException ): \"\"\"Exception raised because longitude not in range. Args: longitude (float): Longitude property \"\"\" def __init__ ( self , longitude : float ): self . message = f \"Longitude { longitude } not in ( { MIN_LONGITUDE } , { MAX_LONGITUDE } ) range!\" super () . __init__ ( self . message ) MaxLoopReachedForKmeans Bases: SeedBaseException Exception raised because max number of iterations reached for computing optimal cluster number. Source code in shift\\exceptions.py 268 269 class MaxLoopReachedForKmeans ( SeedBaseException ): \"\"\"Exception raised because max number of iterations reached for computing optimal cluster number.\"\"\" MissingConfigurationAttribute Bases: SeedBaseException Exceptions raised because attribute is missing in configuration yaml file. Source code in shift\\exceptions.py 514 515 class MissingConfigurationAttribute ( SeedBaseException ): \"\"\"Exceptions raised because attribute is missing in configuration yaml file.\"\"\" MissingKeyDataForNetworkNode Bases: SeedBaseException Exception because type property is missing for a network node. Parameters: Name Type Description Default type str type property for missing key required Source code in shift\\exceptions.py 208 209 210 211 212 213 214 215 216 217 class MissingKeyDataForNetworkNode ( SeedBaseException ): \"\"\"Exception because type property is missing for a network node. Args: type (str): type property for missing key \"\"\" def __init__ ( self , type : str ): self . message = f \"` { type } ` field is missing in network node data\" super () . __init__ ( self . message ) MultipleCatalogFoundError Bases: SeedBaseException Exceptions raised because multiple records found in the catalog. Parameters: Name Type Description Default records List [ dict ] List of records required Source code in shift\\exceptions.py 325 326 327 328 329 330 331 332 333 334 class MultipleCatalogFoundError ( SeedBaseException ): \"\"\"Exceptions raised because multiple records found in the catalog. Args: records (List[dict]): List of records \"\"\" def __init__ ( self , records : List [ dict ]): self . message = f \"Multiple records found { records } !\" super () . __init__ ( self . message ) NegativeAmpacityError Bases: SeedBaseException Exceptions raised because Ampacity is negative. Parameters: Name Type Description Default ampacity float Ampacity property required Source code in shift\\exceptions.py 421 422 423 424 425 426 427 428 429 430 class NegativeAmpacityError ( SeedBaseException ): \"\"\"Exceptions raised because Ampacity is negative. Args: ampacity (float): Ampacity property \"\"\" def __init__ ( self , ampacity : float ): self . message = f \"Ampacity can not be negative but found { ampacity } \" super () . __init__ ( self . message ) NegativeAreaError Bases: SeedBaseException Exception raused because area of the geometry is negative. Parameters: Name Type Description Default area float Area property required Source code in shift\\exceptions.py 103 104 105 106 107 108 109 110 111 112 class NegativeAreaError ( SeedBaseException ): \"\"\"Exception raused because area of the geometry is negative. Args: area (float): Area property \"\"\" def __init__ ( self , area : float ): self . message = f \"Area = { area } can not be negative\" super () . __init__ ( self . message ) NegativeDiameterError Bases: SeedBaseException Exceptions raised because diameter is negative. Parameters: Name Type Description Default diameter float Conductor diameter property required Source code in shift\\exceptions.py 385 386 387 388 389 390 391 392 393 394 class NegativeDiameterError ( SeedBaseException ): \"\"\"Exceptions raised because diameter is negative. Args: diameter (float): Conductor diameter property \"\"\" def __init__ ( self , diameter : float ): self . message = f \"Diamater can not be negative but found { diameter } \" super () . __init__ ( self . message ) NegativeGMRError Bases: SeedBaseException Exceptions raised because GMR is negative. Parameters: Name Type Description Default gmr float Geometric mean radius property required Source code in shift\\exceptions.py 397 398 399 400 401 402 403 404 405 406 class NegativeGMRError ( SeedBaseException ): \"\"\"Exceptions raised because GMR is negative. Args: gmr (float): Geometric mean radius property \"\"\" def __init__ ( self , gmr : float ): self . message = f \"GMR can not be negative but found { gmr } \" super () . __init__ ( self . message ) NegativeKVError Bases: SeedBaseException Exception raised because kV is negative. Parameters: Name Type Description Default kv float Voltage in KV property required Source code in shift\\exceptions.py 87 88 89 90 91 92 93 94 95 96 class NegativeKVError ( SeedBaseException ): \"\"\"Exception raised because kV is negative. Args: kv (float): Voltage in KV property \"\"\" def __init__ ( self , kv : float ): self . message = f \"KV = { kv } can not be negative\" super () . __init__ ( self . message ) NegativeLineLengthError Bases: SeedBaseException Exceptions raised because line length is negative. Parameters: Name Type Description Default length float Line segment's length property required Source code in shift\\exceptions.py 361 362 363 364 365 366 367 368 369 370 class NegativeLineLengthError ( SeedBaseException ): \"\"\"Exceptions raised because line length is negative. Args: length (float): Line segment's length property \"\"\" def __init__ ( self , length : float ): self . message = f \"Line length can not be negative but found { length } \" super () . __init__ ( self . message ) NegativeResistanceError Bases: SeedBaseException Exceptions raised because AC resistance is negative. Parameters: Name Type Description Default r float AC resistance property required Source code in shift\\exceptions.py 409 410 411 412 413 414 415 416 417 418 class NegativeResistanceError ( SeedBaseException ): \"\"\"Exceptions raised because AC resistance is negative. Args: r (float): AC resistance property \"\"\" def __init__ ( self , r : float ): self . message = f \"AC resistance can not be negative but found { r } \" super () . __init__ ( self . message ) NegativeStrandsError Bases: SeedBaseException Exceptions raised because Number of strands is negative. Parameters: Name Type Description Default num_of_strands float Number of strands property required Source code in shift\\exceptions.py 433 434 435 436 437 438 439 440 441 442 443 444 class NegativeStrandsError ( SeedBaseException ): \"\"\"Exceptions raised because Number of strands is negative. Args: num_of_strands (float): Number of strands property \"\"\" def __init__ ( self , num_of_strands : float ): self . message = ( f \"Number of strands can not be negative but found { num_of_strands } \" ) super () . __init__ ( self . message ) NegativekVAError Bases: SeedBaseException Exception raised because negative kva is used. Parameters: Name Type Description Default kva float kva property required Source code in shift\\exceptions.py 256 257 258 259 260 261 262 263 264 265 class NegativekVAError ( SeedBaseException ): \"\"\"Exception raised because negative kva is used. Args: kva (float): kva property \"\"\" def __init__ ( self , kva : float ): self . message = f \"kVA = { kva } can not be negative\" super () . __init__ ( self . message ) NotCompatibleFileError Bases: SeedBaseException Exception raised because unexpected file type recieved. Parameters: Name Type Description Default file_path str File path property required expected_type str Expected file type property required Source code in shift\\exceptions.py 151 152 153 154 155 156 157 158 159 160 161 class NotCompatibleFileError ( SeedBaseException ): \"\"\"Exception raised because unexpected file type recieved. Args: file_path (str): File path property expected_type (str): Expected file type property \"\"\" def __init__ ( self , file_path : str , expected_type : str ): self . message = f \"Unexpected file type received, expected { expected_type } but got { file_path } \" super () . __init__ ( self . message ) NotImplementedError Bases: SeedBaseException Feature not implmeneted error. Source code in shift\\exceptions.py 528 529 class NotImplementedError ( SeedBaseException ): \"\"\" Feature not implmeneted error.\"\"\" NumberOfClusterNotInRangeError Bases: SeedBaseException Exception raised because number of clusters used is not within range. Parameters: Name Type Description Default num_of_clus int Number of clusters property required Source code in shift\\exceptions.py 276 277 278 279 280 281 282 283 284 285 class NumberOfClusterNotInRangeError ( SeedBaseException ): \"\"\"Exception raised because number of clusters used is not within range. Args: num_of_clus (int): Number of clusters property \"\"\" def __init__ ( self , num_of_clus : int ): self . message = f \"Number of clusters { num_of_clus } must be less than { MIN_NUM_CLUSTER } !\" super () . __init__ ( self . message ) OperationYearNotInRange Bases: SeedBaseException Exceptions raised because year in operation is not within range. Parameters: Name Type Description Default year float Year property required Source code in shift\\exceptions.py 337 338 339 340 341 342 343 344 345 346 class OperationYearNotInRange ( SeedBaseException ): \"\"\"Exceptions raised because year in operation is not within range. Args: year (float): Year property \"\"\" def __init__ ( self , year : float ): self . message = f \"Year in operation must be in range { ( MIN_YEAR_OPERATION , MAX_YEAR_OPERATION ) } , but found { year } \" super () . __init__ ( self . message ) PercentageNotInRangeError Bases: SeedBaseException Exception raised because percentage set is not within range. Parameters: Name Type Description Default pct float Percentage property required Source code in shift\\exceptions.py 244 245 246 247 248 249 250 251 252 253 class PercentageNotInRangeError ( SeedBaseException ): \"\"\"Exception raised because percentage set is not within range. Args: pct (float): Percentage property \"\"\" def __init__ ( self , pct : float ): self . message = f \"Percentage { pct } not in ( { MIN_PERCENTAGE } , { MAX_PERCENTAGE } ) range!\" super () . __init__ ( self . message ) PercentageSumNotHundred Bases: SeedBaseException Exception raised because sum of pct values not equal to 100. Parameters: Name Type Description Default total_pct float Percentage property required Source code in shift\\exceptions.py 127 128 129 130 131 132 133 134 135 136 class PercentageSumNotHundred ( SeedBaseException ): \"\"\"Exception raised because sum of pct values not equal to 100. Args: total_pct (float): Percentage property \"\"\" def __init__ ( self , total_pct : float ): self . message = f \"Total sum { total_pct } not equal to 100\" super () . __init__ ( self . message ) PhaseMismatchError Bases: SeedBaseException Exceptions raised because phase misatch is encountered. Parameters: Name Type Description Default phase1 Phase Phase property for one end required phase2 Phase Phase property for other end required Source code in shift\\exceptions.py 474 475 476 477 478 479 480 481 482 483 484 class PhaseMismatchError ( SeedBaseException ): \"\"\"Exceptions raised because phase misatch is encountered. Args: phase1 (Phase): Phase property for one end phase2 (Phase): Phase property for other end \"\"\" def __init__ ( self , phase1 : Phase , phase2 : Phase ): self . message = f \"Attempt to connect phase { phase1 } to phase { phase2 } is encountered!\" super () . __init__ ( self . message ) PoleToPoleDistanceNotInRange Bases: SeedBaseException Exceptions raised because pole to pole distance is not within range. Parameters: Name Type Description Default distance float Pole to pole distance property required Source code in shift\\exceptions.py 349 350 351 352 353 354 355 356 357 358 class PoleToPoleDistanceNotInRange ( SeedBaseException ): \"\"\"Exceptions raised because pole to pole distance is not within range. Args: distance (float): Pole to pole distance property \"\"\" def __init__ ( self , distance : float ): self . message = f \"Pole to pole distance must be in range { ( MIN_POLE_TO_POLE_DISTANCE , MAX_POLE_TO_POLE_DISTANCE ) } , but found { distance } \" super () . __init__ ( self . message ) PowerFactorNotInRangeError Bases: SeedBaseException Exception raised because power factor not in range. Parameters: Name Type Description Default pf float Power factor property required Source code in shift\\exceptions.py 115 116 117 118 119 120 121 122 123 124 class PowerFactorNotInRangeError ( SeedBaseException ): \"\"\"Exception raised because power factor not in range. Args: pf (float): Power factor property \"\"\" def __init__ ( self , pf : float ): self . message = f \"Power factor { pf } not in ( { MIN_POWER_FACTOR } , { MAX_POWER_FACTOR } ) range!\" super () . __init__ ( self . message ) SeedBaseException Bases: Exception All exception should derive from this. Source code in shift\\exceptions.py 59 60 class SeedBaseException ( Exception ): \"\"\"All exception should derive from this.\"\"\" UnsupportedFeatureError Bases: SeedBaseException Exceptions raised because feature being requested is not yet supported or invalid type is passed. Source code in shift\\exceptions.py 518 519 class UnsupportedFeatureError ( SeedBaseException ): \"\"\"Exceptions raised because feature being requested is not yet supported or invalid type is passed.\"\"\" UnsupportedFrequencyError Bases: SeedBaseException Exceptions raised because unsupported frequency is in use. Parameters: Name Type Description Default freq float Frequency in hz required Source code in shift\\exceptions.py 462 463 464 465 466 467 468 469 470 471 class UnsupportedFrequencyError ( SeedBaseException ): \"\"\"Exceptions raised because unsupported frequency is in use. Args: freq (float): Frequency in hz \"\"\" def __init__ ( self , freq : float ): self . message = f \"Unsupported frequency is used { freq } please choose one of these frequency { VALID_FREQUENCIES } \" super () . __init__ ( self . message ) ValidationError Bases: SeedBaseException Exception raised bbecause content can not be validated. Parameters: Name Type Description Default errors list List of error messages. required Source code in shift\\exceptions.py 164 165 166 167 168 169 170 171 172 173 class ValidationError ( SeedBaseException ): \"\"\"Exception raised bbecause content can not be validated. Args: errors (list): List of error messages. \"\"\" def __init__ ( self , errors : list ): self . message = f \"Could not validate the content: { errors } \" super () . __init__ ( self . message ) WrongInputUsed Bases: SeedBaseException Exeption raised becaue wrong input is used. Source code in shift\\exceptions.py 272 273 class WrongInputUsed ( SeedBaseException ): \"\"\"Exeption raised becaue wrong input is used.\"\"\" ZeroKVError Bases: SeedBaseException Exception raused because the kV is zero. Source code in shift\\exceptions.py 99 100 class ZeroKVError ( SeedBaseException ): \"\"\"Exception raused because the kV is zero.\"\"\" ZoomLevelNotInRangeError Bases: SeedBaseException Exception raised because zoom level defined is not in range. Parameters: Name Type Description Default zoom int Zoom level property required Source code in shift\\exceptions.py 176 177 178 179 180 181 182 183 184 185 class ZoomLevelNotInRangeError ( SeedBaseException ): \"\"\"Exception raised because zoom level defined is not in range. Args: zoom (int): Zoom level property \"\"\" def __init__ ( self , zoom : int ): self . message = f \"Zoom level { zoom } not in ( { MIN_ZOOM_LEVEL } , { MAX_ZOOM_LEVEL } ) range!\" super () . __init__ ( self . message )","title":"exceptions"},{"location":"exceptions/#shift.exceptions.AdjustmentFactorNotInRangeError","text":"Bases: SeedBaseException Exception raised because adjustment factor not in range. Parameters: Name Type Description Default af float Adjustment factor property required Source code in shift\\exceptions.py 296 297 298 299 300 301 302 303 304 305 class AdjustmentFactorNotInRangeError ( SeedBaseException ): \"\"\"Exception raised because adjustment factor not in range. Args: af (float): Adjustment factor property \"\"\" def __init__ ( self , af : float ): self . message = f \"Adjustement factor { af } not in ( { MIN_ADJUSTMENT_FACTOR } , { MAX_ADJUSTMENT_FACTOR } ) range!\" super () . __init__ ( self . message )","title":"AdjustmentFactorNotInRangeError"},{"location":"exceptions/#shift.exceptions.AttributeDoesNotExistError","text":"Bases: SeedBaseException Method is called to early. Source code in shift\\exceptions.py 292 293 class AttributeDoesNotExistError ( SeedBaseException ): \"\"\"Method is called to early.\"\"\"","title":"AttributeDoesNotExistError"},{"location":"exceptions/#shift.exceptions.CatalogNotFoundError","text":"Bases: SeedBaseException Exceptions raised because catalog requested is not found. Source code in shift\\exceptions.py 522 523 class CatalogNotFoundError ( SeedBaseException ): \"\"\"Exceptions raised because catalog requested is not found.\"\"\"","title":"CatalogNotFoundError"},{"location":"exceptions/#shift.exceptions.ConductorNotFoundForKdrop","text":"Bases: SeedBaseException Exceptions raised because no conductor is found that satisfies the kdrop. Parameters: Name Type Description Default kdrop float Voltage drop property required Source code in shift\\exceptions.py 500 501 502 503 504 505 506 507 508 509 510 511 class ConductorNotFoundForKdrop ( SeedBaseException ): \"\"\"Exceptions raised because no conductor is found that satisfies the kdrop. Args: kdrop (float): Voltage drop property \"\"\" def __init__ ( self , kdrop : float ): self . message = ( f \"No conductor is found that satisfies kdrop of value { kdrop } \" ) super () . __init__ ( self . message )","title":"ConductorNotFoundForKdrop"},{"location":"exceptions/#shift.exceptions.CustomerInvalidPhase","text":"Bases: SeedBaseException Exceptions raised because number of phase for customer is greater than number of phase used in secondary. Parameters: Name Type Description Default customer_num_phase NumPhase Number of phase property for customer required secondary_num_phase NumPhase Number of phase for secondary lateral required Source code in shift\\exceptions.py 447 448 449 450 451 452 453 454 455 456 457 458 459 class CustomerInvalidPhase ( SeedBaseException ): \"\"\"Exceptions raised because number of phase for customer is greater than number of phase used in secondary. Args: customer_num_phase (NumPhase): Number of phase property for customer secondary_num_phase (NumPhase): Number of phase for secondary lateral \"\"\" def __init__ ( self , customer_num_phase : NumPhase , secondary_num_phase : NumPhase ): self . message = f \"Number of phase used for load { customer_num_phase } is greater than that used for secondary { secondary_num_phase } \" super () . __init__ ( self . message )","title":"CustomerInvalidPhase"},{"location":"exceptions/#shift.exceptions.EarlyMethodCallError","text":"Bases: SeedBaseException Method is called to early. Source code in shift\\exceptions.py 288 289 class EarlyMethodCallError ( SeedBaseException ): \"\"\"Method is called to early.\"\"\"","title":"EarlyMethodCallError"},{"location":"exceptions/#shift.exceptions.EmptyAssetStyleDict","text":"Bases: SeedBaseException Exception raised for empty style dict. Source code in shift\\exceptions.py 200 201 202 203 204 205 class EmptyAssetStyleDict ( SeedBaseException ): \"\"\"Exception raised for empty style dict.\"\"\" def __init__ ( self ): self . message = \"Asset specific style can not be empty in PLotlyGISNetworkPlot object\" super () . __init__ ( self . message )","title":"EmptyAssetStyleDict"},{"location":"exceptions/#shift.exceptions.EmptyCatalog","text":"Bases: SeedBaseException Exceptions raised because no catalog found. Source code in shift\\exceptions.py 321 322 class EmptyCatalog ( SeedBaseException ): \"\"\"Exceptions raised because no catalog found.\"\"\"","title":"EmptyCatalog"},{"location":"exceptions/#shift.exceptions.FileNotFoundError","text":"Bases: SeedBaseException Exception raised because file path does not exist. Parameters: Name Type Description Default file_path str File path property required Source code in shift\\exceptions.py 139 140 141 142 143 144 145 146 147 148 class FileNotFoundError ( SeedBaseException ): \"\"\"Exception raised because file path does not exist. Args: file_path (str): File path property \"\"\" def __init__ ( self , file_path : str ): self . message = f \"File { file_path } does not exist!\" super () . __init__ ( self . message )","title":"FileNotFoundError"},{"location":"exceptions/#shift.exceptions.FolderNotFoundError","text":"Bases: SeedBaseException Exception raised because folder not found. Parameters: Name Type Description Default folder_path str Path to a invalid folder required Source code in shift\\exceptions.py 232 233 234 235 236 237 238 239 240 241 class FolderNotFoundError ( SeedBaseException ): \"\"\"Exception raised because folder not found. Args: folder_path (str): Path to a invalid folder \"\"\" def __init__ ( self , folder_path : str ): self . message = f \"Folder { folder_path } does not exist!\" super () . __init__ ( self . message )","title":"FolderNotFoundError"},{"location":"exceptions/#shift.exceptions.HTkVlowerthanLTkVError","text":"Bases: SeedBaseException Exceptions raised because HT kV used is lower than LT kv used. Parameters: Name Type Description Default ht_kv float High tension kv property required lt_kv float Low tension kv property required Source code in shift\\exceptions.py 308 309 310 311 312 313 314 315 316 317 318 class HTkVlowerthanLTkVError ( SeedBaseException ): \"\"\"Exceptions raised because HT kV used is lower than LT kv used. Args: ht_kv (float): High tension kv property lt_kv (float): Low tension kv property \"\"\" def __init__ ( self , ht_kv : float , lt_kv : float ): self . message = f \"HT kV { ht_kv } must be higher than LT kV { lt_kv } !\" super () . __init__ ( self . message )","title":"HTkVlowerthanLTkVError"},{"location":"exceptions/#shift.exceptions.IncompleteGeometryConfigurationDict","text":"Bases: SeedBaseException Exceptions raised because of incomplete geometry configuration dict. Parameters: Name Type Description Default num_phase NumPhase Number of phase property required geometry_dict dict Geometry metadata required Source code in shift\\exceptions.py 487 488 489 490 491 492 493 494 495 496 497 class IncompleteGeometryConfigurationDict ( SeedBaseException ): \"\"\"Exceptions raised because of incomplete geometry configuration dict. Args: num_phase (NumPhase): Number of phase property geometry_dict (dict): Geometry metadata \"\"\" def __init__ ( self , num_phase : NumPhase , geometry_dict : dict ): self . message = f \" { num_phase } key does not exist in { geometry_dict } \" super () . __init__ ( self . message )","title":"IncompleteGeometryConfigurationDict"},{"location":"exceptions/#shift.exceptions.InvalidInputError","text":"Bases: SeedBaseException Exceptions raised because the input provided is not valid. Source code in shift\\exceptions.py 525 526 class InvalidInputError ( SeedBaseException ): \"\"\"Exceptions raised because the input provided is not valid. \"\"\"","title":"InvalidInputError"},{"location":"exceptions/#shift.exceptions.InvalidLengthUnitError","text":"Bases: SeedBaseException Exceptions raised because length unit is invalid. Parameters: Name Type Description Default unit str Line length unit used required Source code in shift\\exceptions.py 373 374 375 376 377 378 379 380 381 382 class InvalidLengthUnitError ( SeedBaseException ): \"\"\"Exceptions raised because length unit is invalid. Args: unit (str): Line length unit used \"\"\" def __init__ ( self , unit : str ): self . message = f \"Invalid length unit used { unit } please choose one of these units { VALID_LENGTH_UNITS } \" super () . __init__ ( self . message )","title":"InvalidLengthUnitError"},{"location":"exceptions/#shift.exceptions.InvalidMapboxStyle","text":"Bases: SeedBaseException Exception raised because specified style is not accepted. Parameters: Name Type Description Default style str Style property used for mapbox required Source code in shift\\exceptions.py 188 189 190 191 192 193 194 195 196 197 class InvalidMapboxStyle ( SeedBaseException ): \"\"\"Exception raised because specified style is not accepted. Args: style (str): Style property used for mapbox \"\"\" def __init__ ( self , style : str ): self . message = f \"Style { style } is not a valid style. Please one of these styles { MAP_STYLES } \" super () . __init__ ( self . message )","title":"InvalidMapboxStyle"},{"location":"exceptions/#shift.exceptions.InvalidNodeType","text":"Bases: SeedBaseException Exception because invalid node type is used. Parameters: Name Type Description Default node str Node type property required Source code in shift\\exceptions.py 220 221 222 223 224 225 226 227 228 229 class InvalidNodeType ( SeedBaseException ): \"\"\"Exception because invalid node type is used. Args: node (str): Node type property \"\"\" def __init__ ( self , node : str ): self . message = f \"Invalid node type: { node } , please make sure to use valid node types\" super () . __init__ ( self . message )","title":"InvalidNodeType"},{"location":"exceptions/#shift.exceptions.LatitudeNotInRangeError","text":"Bases: SeedBaseException Exception raised because latitude not in range. Parameters: Name Type Description Default latitude float Latitude property required Source code in shift\\exceptions.py 63 64 65 66 67 68 69 70 71 72 class LatitudeNotInRangeError ( SeedBaseException ): \"\"\"Exception raised because latitude not in range. Args: latitude (float): Latitude property \"\"\" def __init__ ( self , latitude : float ): self . message = f \"Latitude { latitude } not in ( { MIN_LATITUDE } , { MAX_LATITUDE } ) range!\" super () . __init__ ( self . message )","title":"LatitudeNotInRangeError"},{"location":"exceptions/#shift.exceptions.LongitudeNotInRangeError","text":"Bases: SeedBaseException Exception raised because longitude not in range. Parameters: Name Type Description Default longitude float Longitude property required Source code in shift\\exceptions.py 75 76 77 78 79 80 81 82 83 84 class LongitudeNotInRangeError ( SeedBaseException ): \"\"\"Exception raised because longitude not in range. Args: longitude (float): Longitude property \"\"\" def __init__ ( self , longitude : float ): self . message = f \"Longitude { longitude } not in ( { MIN_LONGITUDE } , { MAX_LONGITUDE } ) range!\" super () . __init__ ( self . message )","title":"LongitudeNotInRangeError"},{"location":"exceptions/#shift.exceptions.MaxLoopReachedForKmeans","text":"Bases: SeedBaseException Exception raised because max number of iterations reached for computing optimal cluster number. Source code in shift\\exceptions.py 268 269 class MaxLoopReachedForKmeans ( SeedBaseException ): \"\"\"Exception raised because max number of iterations reached for computing optimal cluster number.\"\"\"","title":"MaxLoopReachedForKmeans"},{"location":"exceptions/#shift.exceptions.MissingConfigurationAttribute","text":"Bases: SeedBaseException Exceptions raised because attribute is missing in configuration yaml file. Source code in shift\\exceptions.py 514 515 class MissingConfigurationAttribute ( SeedBaseException ): \"\"\"Exceptions raised because attribute is missing in configuration yaml file.\"\"\"","title":"MissingConfigurationAttribute"},{"location":"exceptions/#shift.exceptions.MissingKeyDataForNetworkNode","text":"Bases: SeedBaseException Exception because type property is missing for a network node. Parameters: Name Type Description Default type str type property for missing key required Source code in shift\\exceptions.py 208 209 210 211 212 213 214 215 216 217 class MissingKeyDataForNetworkNode ( SeedBaseException ): \"\"\"Exception because type property is missing for a network node. Args: type (str): type property for missing key \"\"\" def __init__ ( self , type : str ): self . message = f \"` { type } ` field is missing in network node data\" super () . __init__ ( self . message )","title":"MissingKeyDataForNetworkNode"},{"location":"exceptions/#shift.exceptions.MultipleCatalogFoundError","text":"Bases: SeedBaseException Exceptions raised because multiple records found in the catalog. Parameters: Name Type Description Default records List [ dict ] List of records required Source code in shift\\exceptions.py 325 326 327 328 329 330 331 332 333 334 class MultipleCatalogFoundError ( SeedBaseException ): \"\"\"Exceptions raised because multiple records found in the catalog. Args: records (List[dict]): List of records \"\"\" def __init__ ( self , records : List [ dict ]): self . message = f \"Multiple records found { records } !\" super () . __init__ ( self . message )","title":"MultipleCatalogFoundError"},{"location":"exceptions/#shift.exceptions.NegativeAmpacityError","text":"Bases: SeedBaseException Exceptions raised because Ampacity is negative. Parameters: Name Type Description Default ampacity float Ampacity property required Source code in shift\\exceptions.py 421 422 423 424 425 426 427 428 429 430 class NegativeAmpacityError ( SeedBaseException ): \"\"\"Exceptions raised because Ampacity is negative. Args: ampacity (float): Ampacity property \"\"\" def __init__ ( self , ampacity : float ): self . message = f \"Ampacity can not be negative but found { ampacity } \" super () . __init__ ( self . message )","title":"NegativeAmpacityError"},{"location":"exceptions/#shift.exceptions.NegativeAreaError","text":"Bases: SeedBaseException Exception raused because area of the geometry is negative. Parameters: Name Type Description Default area float Area property required Source code in shift\\exceptions.py 103 104 105 106 107 108 109 110 111 112 class NegativeAreaError ( SeedBaseException ): \"\"\"Exception raused because area of the geometry is negative. Args: area (float): Area property \"\"\" def __init__ ( self , area : float ): self . message = f \"Area = { area } can not be negative\" super () . __init__ ( self . message )","title":"NegativeAreaError"},{"location":"exceptions/#shift.exceptions.NegativeDiameterError","text":"Bases: SeedBaseException Exceptions raised because diameter is negative. Parameters: Name Type Description Default diameter float Conductor diameter property required Source code in shift\\exceptions.py 385 386 387 388 389 390 391 392 393 394 class NegativeDiameterError ( SeedBaseException ): \"\"\"Exceptions raised because diameter is negative. Args: diameter (float): Conductor diameter property \"\"\" def __init__ ( self , diameter : float ): self . message = f \"Diamater can not be negative but found { diameter } \" super () . __init__ ( self . message )","title":"NegativeDiameterError"},{"location":"exceptions/#shift.exceptions.NegativeGMRError","text":"Bases: SeedBaseException Exceptions raised because GMR is negative. Parameters: Name Type Description Default gmr float Geometric mean radius property required Source code in shift\\exceptions.py 397 398 399 400 401 402 403 404 405 406 class NegativeGMRError ( SeedBaseException ): \"\"\"Exceptions raised because GMR is negative. Args: gmr (float): Geometric mean radius property \"\"\" def __init__ ( self , gmr : float ): self . message = f \"GMR can not be negative but found { gmr } \" super () . __init__ ( self . message )","title":"NegativeGMRError"},{"location":"exceptions/#shift.exceptions.NegativeKVError","text":"Bases: SeedBaseException Exception raised because kV is negative. Parameters: Name Type Description Default kv float Voltage in KV property required Source code in shift\\exceptions.py 87 88 89 90 91 92 93 94 95 96 class NegativeKVError ( SeedBaseException ): \"\"\"Exception raised because kV is negative. Args: kv (float): Voltage in KV property \"\"\" def __init__ ( self , kv : float ): self . message = f \"KV = { kv } can not be negative\" super () . __init__ ( self . message )","title":"NegativeKVError"},{"location":"exceptions/#shift.exceptions.NegativeLineLengthError","text":"Bases: SeedBaseException Exceptions raised because line length is negative. Parameters: Name Type Description Default length float Line segment's length property required Source code in shift\\exceptions.py 361 362 363 364 365 366 367 368 369 370 class NegativeLineLengthError ( SeedBaseException ): \"\"\"Exceptions raised because line length is negative. Args: length (float): Line segment's length property \"\"\" def __init__ ( self , length : float ): self . message = f \"Line length can not be negative but found { length } \" super () . __init__ ( self . message )","title":"NegativeLineLengthError"},{"location":"exceptions/#shift.exceptions.NegativeResistanceError","text":"Bases: SeedBaseException Exceptions raised because AC resistance is negative. Parameters: Name Type Description Default r float AC resistance property required Source code in shift\\exceptions.py 409 410 411 412 413 414 415 416 417 418 class NegativeResistanceError ( SeedBaseException ): \"\"\"Exceptions raised because AC resistance is negative. Args: r (float): AC resistance property \"\"\" def __init__ ( self , r : float ): self . message = f \"AC resistance can not be negative but found { r } \" super () . __init__ ( self . message )","title":"NegativeResistanceError"},{"location":"exceptions/#shift.exceptions.NegativeStrandsError","text":"Bases: SeedBaseException Exceptions raised because Number of strands is negative. Parameters: Name Type Description Default num_of_strands float Number of strands property required Source code in shift\\exceptions.py 433 434 435 436 437 438 439 440 441 442 443 444 class NegativeStrandsError ( SeedBaseException ): \"\"\"Exceptions raised because Number of strands is negative. Args: num_of_strands (float): Number of strands property \"\"\" def __init__ ( self , num_of_strands : float ): self . message = ( f \"Number of strands can not be negative but found { num_of_strands } \" ) super () . __init__ ( self . message )","title":"NegativeStrandsError"},{"location":"exceptions/#shift.exceptions.NegativekVAError","text":"Bases: SeedBaseException Exception raised because negative kva is used. Parameters: Name Type Description Default kva float kva property required Source code in shift\\exceptions.py 256 257 258 259 260 261 262 263 264 265 class NegativekVAError ( SeedBaseException ): \"\"\"Exception raised because negative kva is used. Args: kva (float): kva property \"\"\" def __init__ ( self , kva : float ): self . message = f \"kVA = { kva } can not be negative\" super () . __init__ ( self . message )","title":"NegativekVAError"},{"location":"exceptions/#shift.exceptions.NotCompatibleFileError","text":"Bases: SeedBaseException Exception raised because unexpected file type recieved. Parameters: Name Type Description Default file_path str File path property required expected_type str Expected file type property required Source code in shift\\exceptions.py 151 152 153 154 155 156 157 158 159 160 161 class NotCompatibleFileError ( SeedBaseException ): \"\"\"Exception raised because unexpected file type recieved. Args: file_path (str): File path property expected_type (str): Expected file type property \"\"\" def __init__ ( self , file_path : str , expected_type : str ): self . message = f \"Unexpected file type received, expected { expected_type } but got { file_path } \" super () . __init__ ( self . message )","title":"NotCompatibleFileError"},{"location":"exceptions/#shift.exceptions.NotImplementedError","text":"Bases: SeedBaseException Feature not implmeneted error. Source code in shift\\exceptions.py 528 529 class NotImplementedError ( SeedBaseException ): \"\"\" Feature not implmeneted error.\"\"\"","title":"NotImplementedError"},{"location":"exceptions/#shift.exceptions.NumberOfClusterNotInRangeError","text":"Bases: SeedBaseException Exception raised because number of clusters used is not within range. Parameters: Name Type Description Default num_of_clus int Number of clusters property required Source code in shift\\exceptions.py 276 277 278 279 280 281 282 283 284 285 class NumberOfClusterNotInRangeError ( SeedBaseException ): \"\"\"Exception raised because number of clusters used is not within range. Args: num_of_clus (int): Number of clusters property \"\"\" def __init__ ( self , num_of_clus : int ): self . message = f \"Number of clusters { num_of_clus } must be less than { MIN_NUM_CLUSTER } !\" super () . __init__ ( self . message )","title":"NumberOfClusterNotInRangeError"},{"location":"exceptions/#shift.exceptions.OperationYearNotInRange","text":"Bases: SeedBaseException Exceptions raised because year in operation is not within range. Parameters: Name Type Description Default year float Year property required Source code in shift\\exceptions.py 337 338 339 340 341 342 343 344 345 346 class OperationYearNotInRange ( SeedBaseException ): \"\"\"Exceptions raised because year in operation is not within range. Args: year (float): Year property \"\"\" def __init__ ( self , year : float ): self . message = f \"Year in operation must be in range { ( MIN_YEAR_OPERATION , MAX_YEAR_OPERATION ) } , but found { year } \" super () . __init__ ( self . message )","title":"OperationYearNotInRange"},{"location":"exceptions/#shift.exceptions.PercentageNotInRangeError","text":"Bases: SeedBaseException Exception raised because percentage set is not within range. Parameters: Name Type Description Default pct float Percentage property required Source code in shift\\exceptions.py 244 245 246 247 248 249 250 251 252 253 class PercentageNotInRangeError ( SeedBaseException ): \"\"\"Exception raised because percentage set is not within range. Args: pct (float): Percentage property \"\"\" def __init__ ( self , pct : float ): self . message = f \"Percentage { pct } not in ( { MIN_PERCENTAGE } , { MAX_PERCENTAGE } ) range!\" super () . __init__ ( self . message )","title":"PercentageNotInRangeError"},{"location":"exceptions/#shift.exceptions.PercentageSumNotHundred","text":"Bases: SeedBaseException Exception raised because sum of pct values not equal to 100. Parameters: Name Type Description Default total_pct float Percentage property required Source code in shift\\exceptions.py 127 128 129 130 131 132 133 134 135 136 class PercentageSumNotHundred ( SeedBaseException ): \"\"\"Exception raised because sum of pct values not equal to 100. Args: total_pct (float): Percentage property \"\"\" def __init__ ( self , total_pct : float ): self . message = f \"Total sum { total_pct } not equal to 100\" super () . __init__ ( self . message )","title":"PercentageSumNotHundred"},{"location":"exceptions/#shift.exceptions.PhaseMismatchError","text":"Bases: SeedBaseException Exceptions raised because phase misatch is encountered. Parameters: Name Type Description Default phase1 Phase Phase property for one end required phase2 Phase Phase property for other end required Source code in shift\\exceptions.py 474 475 476 477 478 479 480 481 482 483 484 class PhaseMismatchError ( SeedBaseException ): \"\"\"Exceptions raised because phase misatch is encountered. Args: phase1 (Phase): Phase property for one end phase2 (Phase): Phase property for other end \"\"\" def __init__ ( self , phase1 : Phase , phase2 : Phase ): self . message = f \"Attempt to connect phase { phase1 } to phase { phase2 } is encountered!\" super () . __init__ ( self . message )","title":"PhaseMismatchError"},{"location":"exceptions/#shift.exceptions.PoleToPoleDistanceNotInRange","text":"Bases: SeedBaseException Exceptions raised because pole to pole distance is not within range. Parameters: Name Type Description Default distance float Pole to pole distance property required Source code in shift\\exceptions.py 349 350 351 352 353 354 355 356 357 358 class PoleToPoleDistanceNotInRange ( SeedBaseException ): \"\"\"Exceptions raised because pole to pole distance is not within range. Args: distance (float): Pole to pole distance property \"\"\" def __init__ ( self , distance : float ): self . message = f \"Pole to pole distance must be in range { ( MIN_POLE_TO_POLE_DISTANCE , MAX_POLE_TO_POLE_DISTANCE ) } , but found { distance } \" super () . __init__ ( self . message )","title":"PoleToPoleDistanceNotInRange"},{"location":"exceptions/#shift.exceptions.PowerFactorNotInRangeError","text":"Bases: SeedBaseException Exception raised because power factor not in range. Parameters: Name Type Description Default pf float Power factor property required Source code in shift\\exceptions.py 115 116 117 118 119 120 121 122 123 124 class PowerFactorNotInRangeError ( SeedBaseException ): \"\"\"Exception raised because power factor not in range. Args: pf (float): Power factor property \"\"\" def __init__ ( self , pf : float ): self . message = f \"Power factor { pf } not in ( { MIN_POWER_FACTOR } , { MAX_POWER_FACTOR } ) range!\" super () . __init__ ( self . message )","title":"PowerFactorNotInRangeError"},{"location":"exceptions/#shift.exceptions.SeedBaseException","text":"Bases: Exception All exception should derive from this. Source code in shift\\exceptions.py 59 60 class SeedBaseException ( Exception ): \"\"\"All exception should derive from this.\"\"\"","title":"SeedBaseException"},{"location":"exceptions/#shift.exceptions.UnsupportedFeatureError","text":"Bases: SeedBaseException Exceptions raised because feature being requested is not yet supported or invalid type is passed. Source code in shift\\exceptions.py 518 519 class UnsupportedFeatureError ( SeedBaseException ): \"\"\"Exceptions raised because feature being requested is not yet supported or invalid type is passed.\"\"\"","title":"UnsupportedFeatureError"},{"location":"exceptions/#shift.exceptions.UnsupportedFrequencyError","text":"Bases: SeedBaseException Exceptions raised because unsupported frequency is in use. Parameters: Name Type Description Default freq float Frequency in hz required Source code in shift\\exceptions.py 462 463 464 465 466 467 468 469 470 471 class UnsupportedFrequencyError ( SeedBaseException ): \"\"\"Exceptions raised because unsupported frequency is in use. Args: freq (float): Frequency in hz \"\"\" def __init__ ( self , freq : float ): self . message = f \"Unsupported frequency is used { freq } please choose one of these frequency { VALID_FREQUENCIES } \" super () . __init__ ( self . message )","title":"UnsupportedFrequencyError"},{"location":"exceptions/#shift.exceptions.ValidationError","text":"Bases: SeedBaseException Exception raised bbecause content can not be validated. Parameters: Name Type Description Default errors list List of error messages. required Source code in shift\\exceptions.py 164 165 166 167 168 169 170 171 172 173 class ValidationError ( SeedBaseException ): \"\"\"Exception raised bbecause content can not be validated. Args: errors (list): List of error messages. \"\"\" def __init__ ( self , errors : list ): self . message = f \"Could not validate the content: { errors } \" super () . __init__ ( self . message )","title":"ValidationError"},{"location":"exceptions/#shift.exceptions.WrongInputUsed","text":"Bases: SeedBaseException Exeption raised becaue wrong input is used. Source code in shift\\exceptions.py 272 273 class WrongInputUsed ( SeedBaseException ): \"\"\"Exeption raised becaue wrong input is used.\"\"\"","title":"WrongInputUsed"},{"location":"exceptions/#shift.exceptions.ZeroKVError","text":"Bases: SeedBaseException Exception raused because the kV is zero. Source code in shift\\exceptions.py 99 100 class ZeroKVError ( SeedBaseException ): \"\"\"Exception raused because the kV is zero.\"\"\"","title":"ZeroKVError"},{"location":"exceptions/#shift.exceptions.ZoomLevelNotInRangeError","text":"Bases: SeedBaseException Exception raised because zoom level defined is not in range. Parameters: Name Type Description Default zoom int Zoom level property required Source code in shift\\exceptions.py 176 177 178 179 180 181 182 183 184 185 class ZoomLevelNotInRangeError ( SeedBaseException ): \"\"\"Exception raised because zoom level defined is not in range. Args: zoom (int): Zoom level property \"\"\" def __init__ ( self , zoom : int ): self . message = f \"Zoom level { zoom } not in ( { MIN_ZOOM_LEVEL } , { MAX_ZOOM_LEVEL } ) range!\" super () . __init__ ( self . message )","title":"ZoomLevelNotInRangeError"},{"location":"explanation/","text":"","title":"Theoritical Explanation"},{"location":"facade/","text":"This module is used to consume yaml file to produce synthetic feeeder. generate_feeder_from_yaml ( yaml_file ) Generates synthetic feeder model by taking in yamk file. Parameters: Name Type Description Default yaml_file str yaml file path containing user configurations. required Examples: >>> from shift.facade import generate_feeder_from_yaml >>> generate_feeder_from_yaml ( r \"sample-1.yaml\" ) Source code in shift\\facade.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 def generate_feeder_from_yaml ( yaml_file : str ) -> None : \"\"\"Generates synthetic feeder model by taking in yamk file. Args: yaml_file (str): yaml file path containing user configurations. Examples: >>> from shift.facade import generate_feeder_from_yaml >>> generate_feeder_from_yaml(r\"sample-1.yaml\") \"\"\" with open ( yaml_file , \"r\" ) as f : config = yaml . safe_load ( f ) # Location config location = config . get ( \"location\" , {}) # Get geometries address = location . get ( \"address\" , None ) distance = location . get ( \"distance\" , None ) div_func_coeffs = config [ \"div_func_coeff\" ] if address : if isinstance ( address , str ): g = BuildingsFromPlace ( address , distance ) elif isinstance ( address , list ) and isinstance ( address [ 0 ], list ): g = BuildingsFromPolygon ( address ) else : g = BuildingsFromPoint ( address , distance ) else : g = SimpleLoadGeometriesFromCSV ( location [ \"csv_file\" ]) # Generate geometries from geometry geometries = g . get_geometries () # load configs load_config = config . get ( \"loads\" , {}) if load_config [ \"phase\" ][ \"method\" ] == \"random\" : pa = RandomPhaseAllocator ( load_config [ \"phase\" ][ \"pct_single_phase\" ], load_config [ \"phase\" ][ \"pct_two_phase\" ], load_config [ \"phase\" ][ \"pct_three_phase\" ], geometries , ) # Connection setter if load_config [ \"conn\" ][ \"method\" ] == \"default\" : cs = DefaultConnSetter () # kv setter if load_config [ \"kv\" ][ \"method\" ] == \"simple\" : vs = SimpleVoltageSetter ( load_config [ \"kv\" ][ \"kv\" ]) # kw setter if load_config [ \"kw\" ][ \"method\" ] == \"piecewiselinear\" : kws = PiecewiseBuildingAreaToConsumptionConverter ( load_config [ \"kw\" ][ \"curve\" ] ) # Generate all the loads loads = [] for g in geometries : if load_config [ \"type\" ][ \"name\" ] == \"constantpowerfactor\" : builder = ConstantPowerFactorBuildingGeometryLoadBuilder ( g , pa , kws , vs , cs , load_config [ \"type\" ][ \"pf\" ] ) b = LoadBuilderEngineer ( builder ) loads . append ( b . get_load ()) # Generate transformers trans_config = config [ \"dist_xfmrs\" ] if trans_config [ \"method\" ][ \"name\" ] == \"clustering\" : kmeans_cluster = KmeansClustering ( int ( len ( loads ) / trans_config [ \"method\" ][ \"estimated_customers_per_transformer\" ] ) ) trans_builder = ClusteringBasedTransformerLoadMapper ( loads , clustering_object = kmeans_cluster , diversity_factor_func = lambda x : div_func_coeffs [ 0 ] * np . log ( x ) + div_func_coeffs [ 1 ], ht_kv = trans_config [ \"kv\" ][ \"ht\" ], lt_kv = trans_config [ \"kv\" ][ \"lt\" ], ht_conn = TRANSFORMER_CONNECTION_MAPPER [ trans_config [ \"conn\" ][ \"ht\" ]], lt_conn = TRANSFORMER_CONNECTION_MAPPER [ trans_config [ \"conn\" ][ \"lt\" ]], ht_phase = _get_phase ( trans_config [ \"phase\" ][ \"num_phase\" ], trans_config [ \"conn\" ][ \"ht\" ] == \"wye-grounded\" , trans_config [ \"phase\" ][ \"phase_type\" ], ), lt_phase = _get_phase ( trans_config [ \"phase\" ][ \"num_phase\" ], trans_config [ \"conn\" ][ \"lt\" ] == \"wye-grounded\" , trans_config [ \"phase\" ][ \"phase_type\" ], ), num_phase = NUM_PHASE_MAPPER . get ( trans_config [ \"phase\" ][ \"num_phase\" ]), catalog_type = trans_config [ \"design_factors\" ][ \"catalog_type\" ], power_factor = trans_config [ \"design_factors\" ][ \"pf\" ], adjustment_factor = trans_config [ \"design_factors\" ][ \"adj_factor\" ], planned_avg_annual_growth = trans_config [ \"design_factors\" ][ \"planned_avg_annual_growth\" ], actual_avg_annual_growth = trans_config [ \"design_factors\" ][ \"actual_avg_annual_growth\" ], actual_years_in_operation = trans_config [ \"design_factors\" ][ \"actual_years_in_operation\" ], planned_years_in_operation = trans_config [ \"design_factors\" ][ \"planned_years_in_operation\" ], ) transformers = trans_builder . get_transformer_load_mapping () # Get the primary network primary_config = config . get ( \"primary_network\" , {}) substation_config = config . get ( \"substation\" , {}) substation_tr_config = config . get ( \"substation_xfmr\" , {}) if primary_config [ \"method\" ] == \"openstreet\" : if address : if isinstance ( address , str ): road_network = RoadNetworkFromPlace ( address , distance ) elif isinstance ( address , list ) and isinstance ( address [ 0 ], list ): road_network = RoadNetworkFromPolygon ( address ) else : road_network = RoadNetworkFromPoint ( address , distance ) elif primary_config [ \"method\" ] == \"openstreet\" : UnsupportedFeatureError ( f \"Road network from buildings locations \\ only is still need to be updated!\" ) pnet = PrimaryNetworkFromRoad ( road_network , transformers , substation_config [ \"location\" ], lambda x : div_func_coeffs [ 0 ] * np . log ( x ) + div_func_coeffs [ 1 ], primary_config [ \"kv\" ], primary_config [ \"max_pp_distance\" ], power_factor = primary_config [ \"design_factors\" ][ \"pf\" ], adjustment_factor = primary_config [ \"design_factors\" ][ \"adj_factor\" ], planned_avg_annual_growth = primary_config [ \"design_factors\" ][ \"planned_avg_annual_growth\" ], actual_avg_annual_growth = primary_config [ \"design_factors\" ][ \"actual_avg_annual_growth\" ], actual_years_in_operation = primary_config [ \"design_factors\" ][ \"actual_years_in_operation\" ], planned_years_in_operation = primary_config [ \"design_factors\" ][ \"planned_years_in_operation\" ], ) substation_node = pnet . substation_node substation_coords = pnet . substation_coords pnet . update_network_with_ampacity () longest_length = pnet . get_longest_length_in_kvameter () / 1609.34 k_drop = primary_config [ \"design_factors\" ][ \"voltage_drop\" ] / ( longest_length ) psections = PrimarySectionsBuilder ( pnet . get_network (), conductor_type = CONDUCTOR_MAPPING [ primary_config [ \"cond_type\" ]], configuration = _get_configuration ( primary_config [ \"configuration\" ], primary_config [ \"phase\" ][ \"neutral_present\" ], ), num_phase = NUM_PHASE_MAPPER [ primary_config [ \"phase\" ][ \"num_phase\" ]], phase = _get_phase ( primary_config [ \"phase\" ][ \"num_phase\" ], primary_config [ \"phase\" ][ \"neutral_present\" ], primary_config [ \"phase\" ][ \"phase_type\" ], ), neutral_present = primary_config [ \"phase\" ][ \"neutral_present\" ], material = primary_config [ \"design_factors\" ][ \"catalog_type\" ], ) primary_sections = psections . generate_primary_line_sections ( k_drop , primary_config [ \"kv\" ] ) r_nodes = pnet . get_trans_node_mapping () print ( len ( r_nodes ), len ( transformers ), r_nodes ) transformers = update_transformer_locations ( r_nodes , transformers , primary_sections ) print ( len ( transformers )) # Model the substation sub_trans_builder = SingleTransformerBuilder ( loads , substation_coords [ 0 ], substation_coords [ 1 ], diversity_factor_func = lambda x : div_func_coeffs [ 0 ] * np . log ( x ) + div_func_coeffs [ 1 ], ht_kv = substation_tr_config [ \"kv\" ][ \"ht\" ], lt_kv = substation_tr_config [ \"kv\" ][ \"lt\" ], ht_conn = TRANSFORMER_CONNECTION_MAPPER [ substation_tr_config [ \"conn\" ][ \"ht\" ] ], lt_conn = TRANSFORMER_CONNECTION_MAPPER [ substation_tr_config [ \"conn\" ][ \"lt\" ] ], ht_phase = _get_phase ( substation_tr_config [ \"phase\" ][ \"num_phase\" ], substation_tr_config [ \"conn\" ][ \"ht\" ] == \"wye-grounded\" , substation_tr_config [ \"phase\" ][ \"phase_type\" ], ), lt_phase = _get_phase ( substation_tr_config [ \"phase\" ][ \"num_phase\" ], substation_tr_config [ \"conn\" ][ \"lt\" ] == \"wye-grounded\" , substation_tr_config [ \"phase\" ][ \"phase_type\" ], ), num_phase = NUM_PHASE_MAPPER [ substation_tr_config [ \"phase\" ][ \"num_phase\" ]], power_factor = substation_tr_config [ \"design_factors\" ][ \"pf\" ], adjustment_factor = substation_tr_config [ \"design_factors\" ][ \"adj_factor\" ], planned_avg_annual_growth = substation_tr_config [ \"design_factors\" ][ \"planned_avg_annual_growth\" ], actual_avg_annual_growth = substation_tr_config [ \"design_factors\" ][ \"actual_avg_annual_growth\" ], actual_years_in_operation = substation_tr_config [ \"design_factors\" ][ \"actual_years_in_operation\" ], planned_years_in_operation = substation_tr_config [ \"design_factors\" ][ \"planned_years_in_operation\" ], ) substation_transformer = sub_trans_builder . get_transformer_load_mapping () # Model secondaries secondary_config = config . get ( \"secondary_network\" , {}) secondary_sections = [] load_to_node_mapping_dict = {} with Pool ( min ( os . cpu_count (), len ( transformers ))) as pool : secondaries = pool . starmap ( _develop_secondaries , [ [ id , trans , transformers [ trans ], div_func_coeffs , secondary_config , ] for id , trans in enumerate ( transformers ) ], ) for result in secondaries : secondary_sections . extend ( result [ \"secondary_sections\" ]) load_to_node_mapping_dict . update ( result [ \"load2node_mapping\" ]) print ( len ( load_to_node_mapping_dict ), len ( result [ \"load2node_mapping\" ]), len ( load_to_node_mapping_dict ) - len ( result [ \"load2node_mapping\" ]), len ( loads ), ) # print('--', load_to_node_mapping_dict) # Now export the model if config [ \"exporter\" ][ \"type\" ] == \"opendss\" : if load_config [ \"type\" ][ \"name\" ] == \"constantpowerfactor\" : load_writer = ConstantPowerFactorLoadWriter ( loads , load_to_node_mapping_dict , \"loads.dss\" ) dist_xfmr_writer = TwoWindingSimpleTransformerWriter ( list ( transformers . keys ()), \"dist_xfmrs.dss\" ) substation_xfmre_writer = TwoWindingSimpleTransformerWriter ( list ( substation_transformer . keys ()), \"sub_trans.dss\" ) sections_writer = GeometryBasedLineWriter ( primary_sections + secondary_sections , line_file_name = \"lines.dss\" , geometry_file_name = \"line_geometry.dss\" , wire_file_name = \"wiredata.dss\" , cable_file_name = \"cabledata.dss\" , ) opendss_writer = OpenDSSExporter ( [ dist_xfmr_writer , substation_xfmre_writer , sections_writer , load_writer , ], config [ \"exporter\" ][ \"path\" ], \"master.dss\" , config [ \"substation\" ][ \"circuit_name\" ], config [ \"substation\" ][ \"kv\" ], config [ \"substation\" ][ \"freq\" ], _get_phase ( config [ \"substation\" ][ \"phase\" ][ \"num_phase\" ], config [ \"substation\" ][ \"phase\" ][ \"neutral_present\" ], config [ \"substation\" ][ \"phase\" ][ \"phase_type\" ], ), NUM_PHASE_MAPPER [ config [ \"substation\" ][ \"phase\" ][ \"num_phase\" ]], f \" { substation_node . split ( '_' )[ 0 ] } _ { substation_node . split ( '_' )[ 1 ] } _htnode\" , config [ \"substation\" ][ \"z1\" ], config [ \"substation\" ][ \"z1\" ], config [ \"substation\" ][ \"kv_levels\" ], ) opendss_writer . export ()","title":"facade"},{"location":"facade/#shift.facade.generate_feeder_from_yaml","text":"Generates synthetic feeder model by taking in yamk file. Parameters: Name Type Description Default yaml_file str yaml file path containing user configurations. required Examples: >>> from shift.facade import generate_feeder_from_yaml >>> generate_feeder_from_yaml ( r \"sample-1.yaml\" ) Source code in shift\\facade.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 def generate_feeder_from_yaml ( yaml_file : str ) -> None : \"\"\"Generates synthetic feeder model by taking in yamk file. Args: yaml_file (str): yaml file path containing user configurations. Examples: >>> from shift.facade import generate_feeder_from_yaml >>> generate_feeder_from_yaml(r\"sample-1.yaml\") \"\"\" with open ( yaml_file , \"r\" ) as f : config = yaml . safe_load ( f ) # Location config location = config . get ( \"location\" , {}) # Get geometries address = location . get ( \"address\" , None ) distance = location . get ( \"distance\" , None ) div_func_coeffs = config [ \"div_func_coeff\" ] if address : if isinstance ( address , str ): g = BuildingsFromPlace ( address , distance ) elif isinstance ( address , list ) and isinstance ( address [ 0 ], list ): g = BuildingsFromPolygon ( address ) else : g = BuildingsFromPoint ( address , distance ) else : g = SimpleLoadGeometriesFromCSV ( location [ \"csv_file\" ]) # Generate geometries from geometry geometries = g . get_geometries () # load configs load_config = config . get ( \"loads\" , {}) if load_config [ \"phase\" ][ \"method\" ] == \"random\" : pa = RandomPhaseAllocator ( load_config [ \"phase\" ][ \"pct_single_phase\" ], load_config [ \"phase\" ][ \"pct_two_phase\" ], load_config [ \"phase\" ][ \"pct_three_phase\" ], geometries , ) # Connection setter if load_config [ \"conn\" ][ \"method\" ] == \"default\" : cs = DefaultConnSetter () # kv setter if load_config [ \"kv\" ][ \"method\" ] == \"simple\" : vs = SimpleVoltageSetter ( load_config [ \"kv\" ][ \"kv\" ]) # kw setter if load_config [ \"kw\" ][ \"method\" ] == \"piecewiselinear\" : kws = PiecewiseBuildingAreaToConsumptionConverter ( load_config [ \"kw\" ][ \"curve\" ] ) # Generate all the loads loads = [] for g in geometries : if load_config [ \"type\" ][ \"name\" ] == \"constantpowerfactor\" : builder = ConstantPowerFactorBuildingGeometryLoadBuilder ( g , pa , kws , vs , cs , load_config [ \"type\" ][ \"pf\" ] ) b = LoadBuilderEngineer ( builder ) loads . append ( b . get_load ()) # Generate transformers trans_config = config [ \"dist_xfmrs\" ] if trans_config [ \"method\" ][ \"name\" ] == \"clustering\" : kmeans_cluster = KmeansClustering ( int ( len ( loads ) / trans_config [ \"method\" ][ \"estimated_customers_per_transformer\" ] ) ) trans_builder = ClusteringBasedTransformerLoadMapper ( loads , clustering_object = kmeans_cluster , diversity_factor_func = lambda x : div_func_coeffs [ 0 ] * np . log ( x ) + div_func_coeffs [ 1 ], ht_kv = trans_config [ \"kv\" ][ \"ht\" ], lt_kv = trans_config [ \"kv\" ][ \"lt\" ], ht_conn = TRANSFORMER_CONNECTION_MAPPER [ trans_config [ \"conn\" ][ \"ht\" ]], lt_conn = TRANSFORMER_CONNECTION_MAPPER [ trans_config [ \"conn\" ][ \"lt\" ]], ht_phase = _get_phase ( trans_config [ \"phase\" ][ \"num_phase\" ], trans_config [ \"conn\" ][ \"ht\" ] == \"wye-grounded\" , trans_config [ \"phase\" ][ \"phase_type\" ], ), lt_phase = _get_phase ( trans_config [ \"phase\" ][ \"num_phase\" ], trans_config [ \"conn\" ][ \"lt\" ] == \"wye-grounded\" , trans_config [ \"phase\" ][ \"phase_type\" ], ), num_phase = NUM_PHASE_MAPPER . get ( trans_config [ \"phase\" ][ \"num_phase\" ]), catalog_type = trans_config [ \"design_factors\" ][ \"catalog_type\" ], power_factor = trans_config [ \"design_factors\" ][ \"pf\" ], adjustment_factor = trans_config [ \"design_factors\" ][ \"adj_factor\" ], planned_avg_annual_growth = trans_config [ \"design_factors\" ][ \"planned_avg_annual_growth\" ], actual_avg_annual_growth = trans_config [ \"design_factors\" ][ \"actual_avg_annual_growth\" ], actual_years_in_operation = trans_config [ \"design_factors\" ][ \"actual_years_in_operation\" ], planned_years_in_operation = trans_config [ \"design_factors\" ][ \"planned_years_in_operation\" ], ) transformers = trans_builder . get_transformer_load_mapping () # Get the primary network primary_config = config . get ( \"primary_network\" , {}) substation_config = config . get ( \"substation\" , {}) substation_tr_config = config . get ( \"substation_xfmr\" , {}) if primary_config [ \"method\" ] == \"openstreet\" : if address : if isinstance ( address , str ): road_network = RoadNetworkFromPlace ( address , distance ) elif isinstance ( address , list ) and isinstance ( address [ 0 ], list ): road_network = RoadNetworkFromPolygon ( address ) else : road_network = RoadNetworkFromPoint ( address , distance ) elif primary_config [ \"method\" ] == \"openstreet\" : UnsupportedFeatureError ( f \"Road network from buildings locations \\ only is still need to be updated!\" ) pnet = PrimaryNetworkFromRoad ( road_network , transformers , substation_config [ \"location\" ], lambda x : div_func_coeffs [ 0 ] * np . log ( x ) + div_func_coeffs [ 1 ], primary_config [ \"kv\" ], primary_config [ \"max_pp_distance\" ], power_factor = primary_config [ \"design_factors\" ][ \"pf\" ], adjustment_factor = primary_config [ \"design_factors\" ][ \"adj_factor\" ], planned_avg_annual_growth = primary_config [ \"design_factors\" ][ \"planned_avg_annual_growth\" ], actual_avg_annual_growth = primary_config [ \"design_factors\" ][ \"actual_avg_annual_growth\" ], actual_years_in_operation = primary_config [ \"design_factors\" ][ \"actual_years_in_operation\" ], planned_years_in_operation = primary_config [ \"design_factors\" ][ \"planned_years_in_operation\" ], ) substation_node = pnet . substation_node substation_coords = pnet . substation_coords pnet . update_network_with_ampacity () longest_length = pnet . get_longest_length_in_kvameter () / 1609.34 k_drop = primary_config [ \"design_factors\" ][ \"voltage_drop\" ] / ( longest_length ) psections = PrimarySectionsBuilder ( pnet . get_network (), conductor_type = CONDUCTOR_MAPPING [ primary_config [ \"cond_type\" ]], configuration = _get_configuration ( primary_config [ \"configuration\" ], primary_config [ \"phase\" ][ \"neutral_present\" ], ), num_phase = NUM_PHASE_MAPPER [ primary_config [ \"phase\" ][ \"num_phase\" ]], phase = _get_phase ( primary_config [ \"phase\" ][ \"num_phase\" ], primary_config [ \"phase\" ][ \"neutral_present\" ], primary_config [ \"phase\" ][ \"phase_type\" ], ), neutral_present = primary_config [ \"phase\" ][ \"neutral_present\" ], material = primary_config [ \"design_factors\" ][ \"catalog_type\" ], ) primary_sections = psections . generate_primary_line_sections ( k_drop , primary_config [ \"kv\" ] ) r_nodes = pnet . get_trans_node_mapping () print ( len ( r_nodes ), len ( transformers ), r_nodes ) transformers = update_transformer_locations ( r_nodes , transformers , primary_sections ) print ( len ( transformers )) # Model the substation sub_trans_builder = SingleTransformerBuilder ( loads , substation_coords [ 0 ], substation_coords [ 1 ], diversity_factor_func = lambda x : div_func_coeffs [ 0 ] * np . log ( x ) + div_func_coeffs [ 1 ], ht_kv = substation_tr_config [ \"kv\" ][ \"ht\" ], lt_kv = substation_tr_config [ \"kv\" ][ \"lt\" ], ht_conn = TRANSFORMER_CONNECTION_MAPPER [ substation_tr_config [ \"conn\" ][ \"ht\" ] ], lt_conn = TRANSFORMER_CONNECTION_MAPPER [ substation_tr_config [ \"conn\" ][ \"lt\" ] ], ht_phase = _get_phase ( substation_tr_config [ \"phase\" ][ \"num_phase\" ], substation_tr_config [ \"conn\" ][ \"ht\" ] == \"wye-grounded\" , substation_tr_config [ \"phase\" ][ \"phase_type\" ], ), lt_phase = _get_phase ( substation_tr_config [ \"phase\" ][ \"num_phase\" ], substation_tr_config [ \"conn\" ][ \"lt\" ] == \"wye-grounded\" , substation_tr_config [ \"phase\" ][ \"phase_type\" ], ), num_phase = NUM_PHASE_MAPPER [ substation_tr_config [ \"phase\" ][ \"num_phase\" ]], power_factor = substation_tr_config [ \"design_factors\" ][ \"pf\" ], adjustment_factor = substation_tr_config [ \"design_factors\" ][ \"adj_factor\" ], planned_avg_annual_growth = substation_tr_config [ \"design_factors\" ][ \"planned_avg_annual_growth\" ], actual_avg_annual_growth = substation_tr_config [ \"design_factors\" ][ \"actual_avg_annual_growth\" ], actual_years_in_operation = substation_tr_config [ \"design_factors\" ][ \"actual_years_in_operation\" ], planned_years_in_operation = substation_tr_config [ \"design_factors\" ][ \"planned_years_in_operation\" ], ) substation_transformer = sub_trans_builder . get_transformer_load_mapping () # Model secondaries secondary_config = config . get ( \"secondary_network\" , {}) secondary_sections = [] load_to_node_mapping_dict = {} with Pool ( min ( os . cpu_count (), len ( transformers ))) as pool : secondaries = pool . starmap ( _develop_secondaries , [ [ id , trans , transformers [ trans ], div_func_coeffs , secondary_config , ] for id , trans in enumerate ( transformers ) ], ) for result in secondaries : secondary_sections . extend ( result [ \"secondary_sections\" ]) load_to_node_mapping_dict . update ( result [ \"load2node_mapping\" ]) print ( len ( load_to_node_mapping_dict ), len ( result [ \"load2node_mapping\" ]), len ( load_to_node_mapping_dict ) - len ( result [ \"load2node_mapping\" ]), len ( loads ), ) # print('--', load_to_node_mapping_dict) # Now export the model if config [ \"exporter\" ][ \"type\" ] == \"opendss\" : if load_config [ \"type\" ][ \"name\" ] == \"constantpowerfactor\" : load_writer = ConstantPowerFactorLoadWriter ( loads , load_to_node_mapping_dict , \"loads.dss\" ) dist_xfmr_writer = TwoWindingSimpleTransformerWriter ( list ( transformers . keys ()), \"dist_xfmrs.dss\" ) substation_xfmre_writer = TwoWindingSimpleTransformerWriter ( list ( substation_transformer . keys ()), \"sub_trans.dss\" ) sections_writer = GeometryBasedLineWriter ( primary_sections + secondary_sections , line_file_name = \"lines.dss\" , geometry_file_name = \"line_geometry.dss\" , wire_file_name = \"wiredata.dss\" , cable_file_name = \"cabledata.dss\" , ) opendss_writer = OpenDSSExporter ( [ dist_xfmr_writer , substation_xfmre_writer , sections_writer , load_writer , ], config [ \"exporter\" ][ \"path\" ], \"master.dss\" , config [ \"substation\" ][ \"circuit_name\" ], config [ \"substation\" ][ \"kv\" ], config [ \"substation\" ][ \"freq\" ], _get_phase ( config [ \"substation\" ][ \"phase\" ][ \"num_phase\" ], config [ \"substation\" ][ \"phase\" ][ \"neutral_present\" ], config [ \"substation\" ][ \"phase\" ][ \"phase_type\" ], ), NUM_PHASE_MAPPER [ config [ \"substation\" ][ \"phase\" ][ \"num_phase\" ]], f \" { substation_node . split ( '_' )[ 0 ] } _ { substation_node . split ( '_' )[ 1 ] } _htnode\" , config [ \"substation\" ][ \"z1\" ], config [ \"substation\" ][ \"z1\" ], config [ \"substation\" ][ \"kv_levels\" ], ) opendss_writer . export ()","title":"generate_feeder_from_yaml()"},{"location":"feeder_network/","text":"This module manages connecting various power system components to build a network. SimpleTwoLayerDistributionNetworkBuilder Bases: TwoLayerDistributionNetworkBuilder Class for creating distribution assets for developing two layer distribution network. Attributes: Name Type Description feeder nx . Graph Instance of networkx graph Source code in shift\\feeder_network.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 class SimpleTwoLayerDistributionNetworkBuilder ( TwoLayerDistributionNetworkBuilder ): \"\"\" Class for creating distribution assets for developing two layer distribution network. Attributes: feeder (nx.Graph): Instance of networkx graph \"\"\" def __init__ ( self ) -> None : \"\"\" Constructor for SimpleTwoLayerDistributionNetworkBuilder class\"\"\" self . feeder = nx . Graph () def add_load_nodes ( self , loads : List [ Load ]) -> None : \"\"\" Add load nodes to the network. Args: loads (List[Load]): List of `Load` objects \"\"\" #Loop over all the load and add to the network for load in loads : self . feeder . add_node ( load . name , pos = ( load . longitude , load . latitude ), type = NetworkAsset . LOAD , data = load . __dict__ , object = load , ) def add_distribution_transformers ( self , transformers : List [ Transformer ]) -> None : \"\"\" Add transformer nodes to the network. Args: transformers (List[Transformer]): List of `Transformer` objects \"\"\" for xfmr in transformers : self . feeder . add_node ( xfmr . name , pos = ( xfmr . longitude , xfmr . latitude ), type = NetworkAsset . DISTXFMR , data = xfmr . __dict__ , object = xfmr , ) def add_low_tension_network ( self , edges : List [ Line ]) -> None : \"\"\" Add low tension line segments to the network. Args: edges (List[Line]): List of `Line` objects representing secondary line segments \"\"\" for edge in edges : if not self . feeder . has_node ( edge . fromnode ): self . feeder . add_node ( edge . fromnode , pos = ( float ( edge . fromnode . split ( \"_\" )[ 0 ]), float ( edge . fromnode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . LTNODE , data = {}, ) if not self . feeder . has_node ( edge . tonode ): self . feeder . add_node ( edge . tonode , pos = ( float ( edge . tonode . split ( \"_\" )[ 0 ]), float ( edge . tonode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . LTNODE , data = {}, ) self . feeder . add_edge ( edge . fromnode , edge . tonode , type = NetworkAsset . LTLINE , data = {}, object = edge , ) def add_high_tension_network ( self , edges : List [ Line ]) -> None : \"\"\" Add high tension line segments to the network. Args: edges (List[Line]): List of `Line` objects representing primary line segments \"\"\" for edge in edges : self . feeder . add_node ( edge . fromnode , pos = ( float ( edge . fromnode . split ( \"_\" )[ 0 ]), float ( edge . fromnode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . HTNODE , data = {}, ) self . feeder . add_node ( edge . tonode , pos = ( float ( edge . tonode . split ( \"_\" )[ 0 ]), float ( edge . tonode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . HTNODE , data = {}, ) self . feeder . add_edge ( edge . fromnode , edge . tonode , type = NetworkAsset . HTLINE , data = {}, object = edge , ) # Make correction to transformer node: # Pull the transformer node to network node and convert to edge def add_substation ( self ): \"\"\" Add substation \"\"\" pass __init__ () Constructor for SimpleTwoLayerDistributionNetworkBuilder class Source code in shift\\feeder_network.py 159 160 161 162 def __init__ ( self ) -> None : \"\"\" Constructor for SimpleTwoLayerDistributionNetworkBuilder class\"\"\" self . feeder = nx . Graph () add_distribution_transformers ( transformers ) Add transformer nodes to the network. Parameters: Name Type Description Default transformers List [ Transformer ] List of Transformer objects required Source code in shift\\feeder_network.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def add_distribution_transformers ( self , transformers : List [ Transformer ]) -> None : \"\"\" Add transformer nodes to the network. Args: transformers (List[Transformer]): List of `Transformer` objects \"\"\" for xfmr in transformers : self . feeder . add_node ( xfmr . name , pos = ( xfmr . longitude , xfmr . latitude ), type = NetworkAsset . DISTXFMR , data = xfmr . __dict__ , object = xfmr , ) add_high_tension_network ( edges ) Add high tension line segments to the network. Parameters: Name Type Description Default edges List [ Line ] List of Line objects representing primary line segments required Source code in shift\\feeder_network.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 def add_high_tension_network ( self , edges : List [ Line ]) -> None : \"\"\" Add high tension line segments to the network. Args: edges (List[Line]): List of `Line` objects representing primary line segments \"\"\" for edge in edges : self . feeder . add_node ( edge . fromnode , pos = ( float ( edge . fromnode . split ( \"_\" )[ 0 ]), float ( edge . fromnode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . HTNODE , data = {}, ) self . feeder . add_node ( edge . tonode , pos = ( float ( edge . tonode . split ( \"_\" )[ 0 ]), float ( edge . tonode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . HTNODE , data = {}, ) self . feeder . add_edge ( edge . fromnode , edge . tonode , type = NetworkAsset . HTLINE , data = {}, object = edge , ) add_load_nodes ( loads ) Add load nodes to the network. Parameters: Name Type Description Default loads List [ Load ] List of Load objects required Source code in shift\\feeder_network.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def add_load_nodes ( self , loads : List [ Load ]) -> None : \"\"\" Add load nodes to the network. Args: loads (List[Load]): List of `Load` objects \"\"\" #Loop over all the load and add to the network for load in loads : self . feeder . add_node ( load . name , pos = ( load . longitude , load . latitude ), type = NetworkAsset . LOAD , data = load . __dict__ , object = load , ) add_low_tension_network ( edges ) Add low tension line segments to the network. Parameters: Name Type Description Default edges List [ Line ] List of Line objects representing secondary line segments required Source code in shift\\feeder_network.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def add_low_tension_network ( self , edges : List [ Line ]) -> None : \"\"\" Add low tension line segments to the network. Args: edges (List[Line]): List of `Line` objects representing secondary line segments \"\"\" for edge in edges : if not self . feeder . has_node ( edge . fromnode ): self . feeder . add_node ( edge . fromnode , pos = ( float ( edge . fromnode . split ( \"_\" )[ 0 ]), float ( edge . fromnode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . LTNODE , data = {}, ) if not self . feeder . has_node ( edge . tonode ): self . feeder . add_node ( edge . tonode , pos = ( float ( edge . tonode . split ( \"_\" )[ 0 ]), float ( edge . tonode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . LTNODE , data = {}, ) self . feeder . add_edge ( edge . fromnode , edge . tonode , type = NetworkAsset . LTLINE , data = {}, object = edge , ) add_substation () Add substation Source code in shift\\feeder_network.py 273 274 275 def add_substation ( self ): \"\"\" Add substation \"\"\" pass TwoLayerDistributionNetworkBuilder Bases: ABC Interface to build two layer (low tension + high tension) distribution network Source code in shift\\feeder_network.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class TwoLayerDistributionNetworkBuilder ( ABC ): \"\"\"Interface to build two layer (low tension + high tension) distribution network\"\"\" @abstractmethod def add_load_nodes ( self ): \"\"\"Abstract method to add customer nodes to the distribution network\"\"\" pass @abstractmethod def add_distribution_transformers ( self , loads : List [ Load ]): \"\"\"Abstract method to add distribution transformer nodes\"\"\" pass @abstractmethod def add_low_tension_network ( self ): \"\"\"Abstract method to add low tension network\"\"\" pass @abstractmethod def add_high_tension_network ( self ): \"\"\"Abstract method to add high tension network\"\"\" pass @abstractmethod def add_substation ( self ): \"\"\"Abstract method to add substation\"\"\" pass add_distribution_transformers ( loads ) abstractmethod Abstract method to add distribution transformer nodes Source code in shift\\feeder_network.py 92 93 94 95 @abstractmethod def add_distribution_transformers ( self , loads : List [ Load ]): \"\"\"Abstract method to add distribution transformer nodes\"\"\" pass add_high_tension_network () abstractmethod Abstract method to add high tension network Source code in shift\\feeder_network.py 102 103 104 105 @abstractmethod def add_high_tension_network ( self ): \"\"\"Abstract method to add high tension network\"\"\" pass add_load_nodes () abstractmethod Abstract method to add customer nodes to the distribution network Source code in shift\\feeder_network.py 87 88 89 90 @abstractmethod def add_load_nodes ( self ): \"\"\"Abstract method to add customer nodes to the distribution network\"\"\" pass add_low_tension_network () abstractmethod Abstract method to add low tension network Source code in shift\\feeder_network.py 97 98 99 100 @abstractmethod def add_low_tension_network ( self ): \"\"\"Abstract method to add low tension network\"\"\" pass add_substation () abstractmethod Abstract method to add substation Source code in shift\\feeder_network.py 107 108 109 110 @abstractmethod def add_substation ( self ): \"\"\"Abstract method to add substation\"\"\" pass TwoLayerNetworkBuilderDirector Builder for creating two layer distribution network. Attributes: Name Type Description builder TwoLayerDistributionNetworkBuilder Instance of TwoLayerDistributionNetworkBuilder class Source code in shift\\feeder_network.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 class TwoLayerNetworkBuilderDirector : \"\"\" Builder for creating two layer distribution network. Attributes: builder (TwoLayerDistributionNetworkBuilder): Instance of `TwoLayerDistributionNetworkBuilder` class \"\"\" def __init__ ( self , loads : List [ Load ], transformers : List [ Transformer ], primary_edges : List [ Line ], secondary_edges : List [ Line ], builder : TwoLayerDistributionNetworkBuilder , ) -> None : \"\"\" Constructor method for TwoLayerNetworkBuilderDirector class. Args: loads (List[Load]): List of `Load` objects transformers (List[Transformer]): List of `Transformer` objects primary_edges (List[Line]): List of `Line` objects representing primary sections secondary_edges (List[Line]): List of `Line` objects representing secondary sections builder (TwoLayerDistributionNetworkBuilder): Instance of builder type `TwoLayerDistributionNetworkBuilder` \"\"\" self . builder = builder self . builder . add_load_nodes ( loads ) self . builder . add_distribution_transformers ( transformers ) self . builder . add_high_tension_network ( primary_edges ) self . builder . add_low_tension_network ( secondary_edges ) def get_network ( self ): \"\"\"Returns a distribution network\"\"\" return self . builder . feeder __init__ ( loads , transformers , primary_edges , secondary_edges , builder ) Constructor method for TwoLayerNetworkBuilderDirector class. Parameters: Name Type Description Default loads List [ Load ] List of Load objects required transformers List [ Transformer ] List of Transformer objects required primary_edges List [ Line ] List of Line objects representing primary sections required secondary_edges List [ Line ] List of Line objects representing secondary sections required builder TwoLayerDistributionNetworkBuilder Instance of builder type TwoLayerDistributionNetworkBuilder required Source code in shift\\feeder_network.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def __init__ ( self , loads : List [ Load ], transformers : List [ Transformer ], primary_edges : List [ Line ], secondary_edges : List [ Line ], builder : TwoLayerDistributionNetworkBuilder , ) -> None : \"\"\" Constructor method for TwoLayerNetworkBuilderDirector class. Args: loads (List[Load]): List of `Load` objects transformers (List[Transformer]): List of `Transformer` objects primary_edges (List[Line]): List of `Line` objects representing primary sections secondary_edges (List[Line]): List of `Line` objects representing secondary sections builder (TwoLayerDistributionNetworkBuilder): Instance of builder type `TwoLayerDistributionNetworkBuilder` \"\"\" self . builder = builder self . builder . add_load_nodes ( loads ) self . builder . add_distribution_transformers ( transformers ) self . builder . add_high_tension_network ( primary_edges ) self . builder . add_low_tension_network ( secondary_edges ) get_network () Returns a distribution network Source code in shift\\feeder_network.py 146 147 148 def get_network ( self ): \"\"\"Returns a distribution network\"\"\" return self . builder . feeder update_transformer_locations ( retain_nodes , transformers_cust_mapper , primary_lines ) Updated the location of transformers by connecting it to nearest primary node. Parameters: Name Type Description Default retain_nodes List [ str ] list of nodes to be retained required transformers_cust_mapper dict A dictionary with key representing Transformer object values list of Load objects required primary_lines List [ Line ] List of line objects representing primary line sections. required Returns: Name Type Description dict dict New transformer to customer or loads mapping Source code in shift\\feeder_network.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def update_transformer_locations ( retain_nodes : List [ str ], transformers_cust_mapper : dict , primary_lines : List [ Line ], ) -> dict : \"\"\"Updated the location of transformers by connecting it to nearest primary node. Args: retain_nodes (List[str]): list of nodes to be retained transformers_cust_mapper (dict): A dictionary with key representing `Transformer` object values list of `Load` objects primary_lines (List[Line]): List of line objects representing primary line sections. Returns: dict: New transformer to customer or loads mapping \"\"\" rnode_to_trans_mapping = {} for rnode , rdict in retain_nodes . items (): for trans , cust_list in transformers_cust_mapper . items (): if rdict [ \"centre\" ] == ( trans . longitude , trans . latitude ): rnode_to_trans_mapping [ rnode ] = { \"trans\" : trans , \"longitude\" : rdict [ \"longitude\" ], \"latitude\" : rdict [ \"latitude\" ], \"cust_list\" : cust_list , } new_transformers_cust_mapper = {} for edge in primary_lines : for node in [ edge . fromnode , edge . tonode ]: if node in rnode_to_trans_mapping : trans_obj = rnode_to_trans_mapping [ node ][ \"trans\" ] trans_obj . longitude = rnode_to_trans_mapping [ node ][ \"longitude\" ] trans_obj . latitude = rnode_to_trans_mapping [ node ][ \"latitude\" ] new_transformers_cust_mapper [ trans_obj ] = rnode_to_trans_mapping [ node ][ \"cust_list\" ] return new_transformers_cust_mapper","title":"feeder_network"},{"location":"feeder_network/#shift.feeder_network.SimpleTwoLayerDistributionNetworkBuilder","text":"Bases: TwoLayerDistributionNetworkBuilder Class for creating distribution assets for developing two layer distribution network. Attributes: Name Type Description feeder nx . Graph Instance of networkx graph Source code in shift\\feeder_network.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 class SimpleTwoLayerDistributionNetworkBuilder ( TwoLayerDistributionNetworkBuilder ): \"\"\" Class for creating distribution assets for developing two layer distribution network. Attributes: feeder (nx.Graph): Instance of networkx graph \"\"\" def __init__ ( self ) -> None : \"\"\" Constructor for SimpleTwoLayerDistributionNetworkBuilder class\"\"\" self . feeder = nx . Graph () def add_load_nodes ( self , loads : List [ Load ]) -> None : \"\"\" Add load nodes to the network. Args: loads (List[Load]): List of `Load` objects \"\"\" #Loop over all the load and add to the network for load in loads : self . feeder . add_node ( load . name , pos = ( load . longitude , load . latitude ), type = NetworkAsset . LOAD , data = load . __dict__ , object = load , ) def add_distribution_transformers ( self , transformers : List [ Transformer ]) -> None : \"\"\" Add transformer nodes to the network. Args: transformers (List[Transformer]): List of `Transformer` objects \"\"\" for xfmr in transformers : self . feeder . add_node ( xfmr . name , pos = ( xfmr . longitude , xfmr . latitude ), type = NetworkAsset . DISTXFMR , data = xfmr . __dict__ , object = xfmr , ) def add_low_tension_network ( self , edges : List [ Line ]) -> None : \"\"\" Add low tension line segments to the network. Args: edges (List[Line]): List of `Line` objects representing secondary line segments \"\"\" for edge in edges : if not self . feeder . has_node ( edge . fromnode ): self . feeder . add_node ( edge . fromnode , pos = ( float ( edge . fromnode . split ( \"_\" )[ 0 ]), float ( edge . fromnode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . LTNODE , data = {}, ) if not self . feeder . has_node ( edge . tonode ): self . feeder . add_node ( edge . tonode , pos = ( float ( edge . tonode . split ( \"_\" )[ 0 ]), float ( edge . tonode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . LTNODE , data = {}, ) self . feeder . add_edge ( edge . fromnode , edge . tonode , type = NetworkAsset . LTLINE , data = {}, object = edge , ) def add_high_tension_network ( self , edges : List [ Line ]) -> None : \"\"\" Add high tension line segments to the network. Args: edges (List[Line]): List of `Line` objects representing primary line segments \"\"\" for edge in edges : self . feeder . add_node ( edge . fromnode , pos = ( float ( edge . fromnode . split ( \"_\" )[ 0 ]), float ( edge . fromnode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . HTNODE , data = {}, ) self . feeder . add_node ( edge . tonode , pos = ( float ( edge . tonode . split ( \"_\" )[ 0 ]), float ( edge . tonode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . HTNODE , data = {}, ) self . feeder . add_edge ( edge . fromnode , edge . tonode , type = NetworkAsset . HTLINE , data = {}, object = edge , ) # Make correction to transformer node: # Pull the transformer node to network node and convert to edge def add_substation ( self ): \"\"\" Add substation \"\"\" pass","title":"SimpleTwoLayerDistributionNetworkBuilder"},{"location":"feeder_network/#shift.feeder_network.SimpleTwoLayerDistributionNetworkBuilder.__init__","text":"Constructor for SimpleTwoLayerDistributionNetworkBuilder class Source code in shift\\feeder_network.py 159 160 161 162 def __init__ ( self ) -> None : \"\"\" Constructor for SimpleTwoLayerDistributionNetworkBuilder class\"\"\" self . feeder = nx . Graph ()","title":"__init__()"},{"location":"feeder_network/#shift.feeder_network.SimpleTwoLayerDistributionNetworkBuilder.add_distribution_transformers","text":"Add transformer nodes to the network. Parameters: Name Type Description Default transformers List [ Transformer ] List of Transformer objects required Source code in shift\\feeder_network.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def add_distribution_transformers ( self , transformers : List [ Transformer ]) -> None : \"\"\" Add transformer nodes to the network. Args: transformers (List[Transformer]): List of `Transformer` objects \"\"\" for xfmr in transformers : self . feeder . add_node ( xfmr . name , pos = ( xfmr . longitude , xfmr . latitude ), type = NetworkAsset . DISTXFMR , data = xfmr . __dict__ , object = xfmr , )","title":"add_distribution_transformers()"},{"location":"feeder_network/#shift.feeder_network.SimpleTwoLayerDistributionNetworkBuilder.add_high_tension_network","text":"Add high tension line segments to the network. Parameters: Name Type Description Default edges List [ Line ] List of Line objects representing primary line segments required Source code in shift\\feeder_network.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 def add_high_tension_network ( self , edges : List [ Line ]) -> None : \"\"\" Add high tension line segments to the network. Args: edges (List[Line]): List of `Line` objects representing primary line segments \"\"\" for edge in edges : self . feeder . add_node ( edge . fromnode , pos = ( float ( edge . fromnode . split ( \"_\" )[ 0 ]), float ( edge . fromnode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . HTNODE , data = {}, ) self . feeder . add_node ( edge . tonode , pos = ( float ( edge . tonode . split ( \"_\" )[ 0 ]), float ( edge . tonode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . HTNODE , data = {}, ) self . feeder . add_edge ( edge . fromnode , edge . tonode , type = NetworkAsset . HTLINE , data = {}, object = edge , )","title":"add_high_tension_network()"},{"location":"feeder_network/#shift.feeder_network.SimpleTwoLayerDistributionNetworkBuilder.add_load_nodes","text":"Add load nodes to the network. Parameters: Name Type Description Default loads List [ Load ] List of Load objects required Source code in shift\\feeder_network.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def add_load_nodes ( self , loads : List [ Load ]) -> None : \"\"\" Add load nodes to the network. Args: loads (List[Load]): List of `Load` objects \"\"\" #Loop over all the load and add to the network for load in loads : self . feeder . add_node ( load . name , pos = ( load . longitude , load . latitude ), type = NetworkAsset . LOAD , data = load . __dict__ , object = load , )","title":"add_load_nodes()"},{"location":"feeder_network/#shift.feeder_network.SimpleTwoLayerDistributionNetworkBuilder.add_low_tension_network","text":"Add low tension line segments to the network. Parameters: Name Type Description Default edges List [ Line ] List of Line objects representing secondary line segments required Source code in shift\\feeder_network.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def add_low_tension_network ( self , edges : List [ Line ]) -> None : \"\"\" Add low tension line segments to the network. Args: edges (List[Line]): List of `Line` objects representing secondary line segments \"\"\" for edge in edges : if not self . feeder . has_node ( edge . fromnode ): self . feeder . add_node ( edge . fromnode , pos = ( float ( edge . fromnode . split ( \"_\" )[ 0 ]), float ( edge . fromnode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . LTNODE , data = {}, ) if not self . feeder . has_node ( edge . tonode ): self . feeder . add_node ( edge . tonode , pos = ( float ( edge . tonode . split ( \"_\" )[ 0 ]), float ( edge . tonode . split ( \"_\" )[ 1 ]), ), type = NetworkAsset . LTNODE , data = {}, ) self . feeder . add_edge ( edge . fromnode , edge . tonode , type = NetworkAsset . LTLINE , data = {}, object = edge , )","title":"add_low_tension_network()"},{"location":"feeder_network/#shift.feeder_network.SimpleTwoLayerDistributionNetworkBuilder.add_substation","text":"Add substation Source code in shift\\feeder_network.py 273 274 275 def add_substation ( self ): \"\"\" Add substation \"\"\" pass","title":"add_substation()"},{"location":"feeder_network/#shift.feeder_network.TwoLayerDistributionNetworkBuilder","text":"Bases: ABC Interface to build two layer (low tension + high tension) distribution network Source code in shift\\feeder_network.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class TwoLayerDistributionNetworkBuilder ( ABC ): \"\"\"Interface to build two layer (low tension + high tension) distribution network\"\"\" @abstractmethod def add_load_nodes ( self ): \"\"\"Abstract method to add customer nodes to the distribution network\"\"\" pass @abstractmethod def add_distribution_transformers ( self , loads : List [ Load ]): \"\"\"Abstract method to add distribution transformer nodes\"\"\" pass @abstractmethod def add_low_tension_network ( self ): \"\"\"Abstract method to add low tension network\"\"\" pass @abstractmethod def add_high_tension_network ( self ): \"\"\"Abstract method to add high tension network\"\"\" pass @abstractmethod def add_substation ( self ): \"\"\"Abstract method to add substation\"\"\" pass","title":"TwoLayerDistributionNetworkBuilder"},{"location":"feeder_network/#shift.feeder_network.TwoLayerDistributionNetworkBuilder.add_distribution_transformers","text":"Abstract method to add distribution transformer nodes Source code in shift\\feeder_network.py 92 93 94 95 @abstractmethod def add_distribution_transformers ( self , loads : List [ Load ]): \"\"\"Abstract method to add distribution transformer nodes\"\"\" pass","title":"add_distribution_transformers()"},{"location":"feeder_network/#shift.feeder_network.TwoLayerDistributionNetworkBuilder.add_high_tension_network","text":"Abstract method to add high tension network Source code in shift\\feeder_network.py 102 103 104 105 @abstractmethod def add_high_tension_network ( self ): \"\"\"Abstract method to add high tension network\"\"\" pass","title":"add_high_tension_network()"},{"location":"feeder_network/#shift.feeder_network.TwoLayerDistributionNetworkBuilder.add_load_nodes","text":"Abstract method to add customer nodes to the distribution network Source code in shift\\feeder_network.py 87 88 89 90 @abstractmethod def add_load_nodes ( self ): \"\"\"Abstract method to add customer nodes to the distribution network\"\"\" pass","title":"add_load_nodes()"},{"location":"feeder_network/#shift.feeder_network.TwoLayerDistributionNetworkBuilder.add_low_tension_network","text":"Abstract method to add low tension network Source code in shift\\feeder_network.py 97 98 99 100 @abstractmethod def add_low_tension_network ( self ): \"\"\"Abstract method to add low tension network\"\"\" pass","title":"add_low_tension_network()"},{"location":"feeder_network/#shift.feeder_network.TwoLayerDistributionNetworkBuilder.add_substation","text":"Abstract method to add substation Source code in shift\\feeder_network.py 107 108 109 110 @abstractmethod def add_substation ( self ): \"\"\"Abstract method to add substation\"\"\" pass","title":"add_substation()"},{"location":"feeder_network/#shift.feeder_network.TwoLayerNetworkBuilderDirector","text":"Builder for creating two layer distribution network. Attributes: Name Type Description builder TwoLayerDistributionNetworkBuilder Instance of TwoLayerDistributionNetworkBuilder class Source code in shift\\feeder_network.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 class TwoLayerNetworkBuilderDirector : \"\"\" Builder for creating two layer distribution network. Attributes: builder (TwoLayerDistributionNetworkBuilder): Instance of `TwoLayerDistributionNetworkBuilder` class \"\"\" def __init__ ( self , loads : List [ Load ], transformers : List [ Transformer ], primary_edges : List [ Line ], secondary_edges : List [ Line ], builder : TwoLayerDistributionNetworkBuilder , ) -> None : \"\"\" Constructor method for TwoLayerNetworkBuilderDirector class. Args: loads (List[Load]): List of `Load` objects transformers (List[Transformer]): List of `Transformer` objects primary_edges (List[Line]): List of `Line` objects representing primary sections secondary_edges (List[Line]): List of `Line` objects representing secondary sections builder (TwoLayerDistributionNetworkBuilder): Instance of builder type `TwoLayerDistributionNetworkBuilder` \"\"\" self . builder = builder self . builder . add_load_nodes ( loads ) self . builder . add_distribution_transformers ( transformers ) self . builder . add_high_tension_network ( primary_edges ) self . builder . add_low_tension_network ( secondary_edges ) def get_network ( self ): \"\"\"Returns a distribution network\"\"\" return self . builder . feeder","title":"TwoLayerNetworkBuilderDirector"},{"location":"feeder_network/#shift.feeder_network.TwoLayerNetworkBuilderDirector.__init__","text":"Constructor method for TwoLayerNetworkBuilderDirector class. Parameters: Name Type Description Default loads List [ Load ] List of Load objects required transformers List [ Transformer ] List of Transformer objects required primary_edges List [ Line ] List of Line objects representing primary sections required secondary_edges List [ Line ] List of Line objects representing secondary sections required builder TwoLayerDistributionNetworkBuilder Instance of builder type TwoLayerDistributionNetworkBuilder required Source code in shift\\feeder_network.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def __init__ ( self , loads : List [ Load ], transformers : List [ Transformer ], primary_edges : List [ Line ], secondary_edges : List [ Line ], builder : TwoLayerDistributionNetworkBuilder , ) -> None : \"\"\" Constructor method for TwoLayerNetworkBuilderDirector class. Args: loads (List[Load]): List of `Load` objects transformers (List[Transformer]): List of `Transformer` objects primary_edges (List[Line]): List of `Line` objects representing primary sections secondary_edges (List[Line]): List of `Line` objects representing secondary sections builder (TwoLayerDistributionNetworkBuilder): Instance of builder type `TwoLayerDistributionNetworkBuilder` \"\"\" self . builder = builder self . builder . add_load_nodes ( loads ) self . builder . add_distribution_transformers ( transformers ) self . builder . add_high_tension_network ( primary_edges ) self . builder . add_low_tension_network ( secondary_edges )","title":"__init__()"},{"location":"feeder_network/#shift.feeder_network.TwoLayerNetworkBuilderDirector.get_network","text":"Returns a distribution network Source code in shift\\feeder_network.py 146 147 148 def get_network ( self ): \"\"\"Returns a distribution network\"\"\" return self . builder . feeder","title":"get_network()"},{"location":"feeder_network/#shift.feeder_network.update_transformer_locations","text":"Updated the location of transformers by connecting it to nearest primary node. Parameters: Name Type Description Default retain_nodes List [ str ] list of nodes to be retained required transformers_cust_mapper dict A dictionary with key representing Transformer object values list of Load objects required primary_lines List [ Line ] List of line objects representing primary line sections. required Returns: Name Type Description dict dict New transformer to customer or loads mapping Source code in shift\\feeder_network.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def update_transformer_locations ( retain_nodes : List [ str ], transformers_cust_mapper : dict , primary_lines : List [ Line ], ) -> dict : \"\"\"Updated the location of transformers by connecting it to nearest primary node. Args: retain_nodes (List[str]): list of nodes to be retained transformers_cust_mapper (dict): A dictionary with key representing `Transformer` object values list of `Load` objects primary_lines (List[Line]): List of line objects representing primary line sections. Returns: dict: New transformer to customer or loads mapping \"\"\" rnode_to_trans_mapping = {} for rnode , rdict in retain_nodes . items (): for trans , cust_list in transformers_cust_mapper . items (): if rdict [ \"centre\" ] == ( trans . longitude , trans . latitude ): rnode_to_trans_mapping [ rnode ] = { \"trans\" : trans , \"longitude\" : rdict [ \"longitude\" ], \"latitude\" : rdict [ \"latitude\" ], \"cust_list\" : cust_list , } new_transformers_cust_mapper = {} for edge in primary_lines : for node in [ edge . fromnode , edge . tonode ]: if node in rnode_to_trans_mapping : trans_obj = rnode_to_trans_mapping [ node ][ \"trans\" ] trans_obj . longitude = rnode_to_trans_mapping [ node ][ \"longitude\" ] trans_obj . latitude = rnode_to_trans_mapping [ node ][ \"latitude\" ] new_transformers_cust_mapper [ trans_obj ] = rnode_to_trans_mapping [ node ][ \"cust_list\" ] return new_transformers_cust_mapper","title":"update_transformer_locations()"},{"location":"geometry/","text":"Handles creation and management of geometries. This module manages creation of geometries from csv file as well as openstreet data. Contains abstract as well as concrete classes for creating geometries. Examples: Get the buildings from chennai and prints one of the building geometry. >>> from shift.geometry import BuildingsFromPlace >>> g = BuildingsFromPlace ( \"Chennai, India\" ) >>> geometries = g . get_geometries () >>> print ( geometries [ 0 ]) BuildingGeometry Bases: Geometry Implementation for Building geometry. Source code in shift\\geometry.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class BuildingGeometry ( Geometry ): \"\"\"Implementation for Building geometry.\"\"\" @property def area ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _area @area . setter def area ( self , area : float ) -> None : \"\"\"Setter method for area property of a building\"\"\" if area < 0 : raise NegativeAreaError ( area ) self . _area = area def __repr__ ( self ): return f \"Building( Latitude = { self . latitude } , Longitude = { self . longitude } , Area = { self . area } )\" area () property writable float: Area property of a building Source code in shift\\geometry.py 111 112 113 114 @property def area ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _area BuildingsFromPlace Bases: OpenStreetBuildingGeometries Getting building geometries from a place address within bounding box. Attributes: Name Type Description place str Any place in string format e.g. chennai, india max_dist float Distance in meter from the point to create a bounding box Source code in shift\\geometry.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 class BuildingsFromPlace ( OpenStreetBuildingGeometries ): \"\"\"Getting building geometries from a place address within bounding box. Attributes: place (str): Any place in string format e.g. chennai, india max_dist (float): Distance in meter from the point to create a bounding box \"\"\" def __init__ ( self , place : str , max_dist = 1000 ) -> None : \"\"\"Instantiating the class. Args: place (str): Any place in string format e.g. chennai, india max_dist (float): Distance in meter from the place to create a bounding box \"\"\" # e.g. Chennai, India self . place = place self . max_dist = max_dist def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_address ( self . place , { \"building\" : True }, dist = self . max_dist ) __init__ ( place , max_dist = 1000 ) Instantiating the class. Parameters: Name Type Description Default place str Any place in string format e.g. chennai, india required max_dist float Distance in meter from the place to create a bounding box 1000 Source code in shift\\geometry.py 312 313 314 315 316 317 318 319 320 321 322 323 def __init__ ( self , place : str , max_dist = 1000 ) -> None : \"\"\"Instantiating the class. Args: place (str): Any place in string format e.g. chennai, india max_dist (float): Distance in meter from the place to create a bounding box \"\"\" # e.g. Chennai, India self . place = place self . max_dist = max_dist get_gdf () Refer to base class for details. Source code in shift\\geometry.py 325 326 327 328 329 def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_address ( self . place , { \"building\" : True }, dist = self . max_dist ) BuildingsFromPoint Bases: OpenStreetBuildingGeometries Getting building geometries from single point within bounding box. Attributes: Name Type Description point Sequence Point in (longitude, latitude) format max_dist float Distance in meter from the point to create a bounding box Source code in shift\\geometry.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 class BuildingsFromPoint ( OpenStreetBuildingGeometries ): \"\"\"Getting building geometries from single point within bounding box. Attributes: point (Sequence): Point in (longitude, latitude) format max_dist (float): Distance in meter from the point to create a bounding box \"\"\" def __init__ ( self , point : Sequence , max_dist : float = 1000 ) -> None : \"\"\"Instantiating the class. Args: point (Sequence): Point in (longitude, latitude) format max_dist (float): Distance in meter from the point to create a bounding box \"\"\" # e.g. (13.242134, 80.275948) self . point = point self . max_dist = max_dist def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_point ( self . point , { \"building\" : True }, dist = self . max_dist ) __init__ ( point , max_dist = 1000 ) Instantiating the class. Parameters: Name Type Description Default point Sequence Point in (longitude, latitude) format required max_dist float Distance in meter from the point to create a bounding box 1000 Source code in shift\\geometry.py 285 286 287 288 289 290 291 292 293 294 295 def __init__ ( self , point : Sequence , max_dist : float = 1000 ) -> None : \"\"\"Instantiating the class. Args: point (Sequence): Point in (longitude, latitude) format max_dist (float): Distance in meter from the point to create a bounding box \"\"\" # e.g. (13.242134, 80.275948) self . point = point self . max_dist = max_dist get_gdf () Refer to base class for details. Source code in shift\\geometry.py 297 298 299 300 301 def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_point ( self . point , { \"building\" : True }, dist = self . max_dist ) BuildingsFromPolygon Bases: OpenStreetBuildingGeometries Getting building geometries from a given polygon. Attributes: Name Type Description polygon List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] Source code in shift\\geometry.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 class BuildingsFromPolygon ( OpenStreetBuildingGeometries ): \"\"\"Getting building geometries from a given polygon. Attributes: polygon: List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] \"\"\" def __init__ ( self , polygon : List [ list ]) -> None : \"\"\"Instantiating the class. Args: polygon: List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] \"\"\" self . polygon = polygon def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_polygon ( self . polygon , { \"building\" : True }) __init__ ( polygon ) Instantiating the class. Parameters: Name Type Description Default polygon List [ list ] List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] required Source code in shift\\geometry.py 339 340 341 342 343 344 345 346 def __init__ ( self , polygon : List [ list ]) -> None : \"\"\"Instantiating the class. Args: polygon: List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] \"\"\" self . polygon = polygon get_gdf () Refer to base class for details. Source code in shift\\geometry.py 348 349 350 def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_polygon ( self . polygon , { \"building\" : True }) GeometriesFromCSV Bases: ABC Interface for getting geometries from CSV file Attributes: Name Type Description csv_file str Path to csv file df pd . DataFrame dataframe holding the content of csv file Source code in shift\\geometry.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class GeometriesFromCSV ( ABC ): \"\"\"Interface for getting geometries from CSV file Attributes: csv_file (str): Path to csv file df (pd.DataFrame): dataframe holding the content of csv file \"\"\" def __init__ ( self , csv_file : str ) -> None : \"\"\"Method for instantiationg the class. Args: csv_file (str): Path to valid csv file Raises: FileNotFoundError: If csv file is not found NotCompatibleFileError: If the file pssed is not csv \"\"\" self . csv_file = csv_file if not os . path . exists ( csv_file ): raise FileNotFoundError ( csv_file ) else : if not csv_file . endswith ( \".csv\" ): raise NotCompatibleFileError ( csv_file , \".csv\" ) self . df = pd . read_csv ( csv_file ) self . validate () @abstractmethod def validate ( self ) -> bool : \"\"\"Child class must implement validate method.\"\"\" pass @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Child class must implement method to return list of geometries.\"\"\" pass __init__ ( csv_file ) Method for instantiationg the class. Parameters: Name Type Description Default csv_file str Path to valid csv file required Raises: Type Description FileNotFoundError If csv file is not found NotCompatibleFileError If the file pssed is not csv Source code in shift\\geometry.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def __init__ ( self , csv_file : str ) -> None : \"\"\"Method for instantiationg the class. Args: csv_file (str): Path to valid csv file Raises: FileNotFoundError: If csv file is not found NotCompatibleFileError: If the file pssed is not csv \"\"\" self . csv_file = csv_file if not os . path . exists ( csv_file ): raise FileNotFoundError ( csv_file ) else : if not csv_file . endswith ( \".csv\" ): raise NotCompatibleFileError ( csv_file , \".csv\" ) self . df = pd . read_csv ( csv_file ) self . validate () get_geometries () abstractmethod Child class must implement method to return list of geometries. Source code in shift\\geometry.py 179 180 181 182 @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Child class must implement method to return list of geometries.\"\"\" pass validate () abstractmethod Child class must implement validate method. Source code in shift\\geometry.py 174 175 176 177 @abstractmethod def validate ( self ) -> bool : \"\"\"Child class must implement validate method.\"\"\" pass Geometry Bases: ABC Interface for Geometry object. Source code in shift\\geometry.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class Geometry ( ABC ): \"\"\"Interface for Geometry object.\"\"\" @property def latitude ( self ) -> float : \"\"\"float: Latitude property of a building\"\"\" return self . _latitude @latitude . setter def latitude ( self , latitude : float ) -> None : \"\"\"Setter method for latitude property of a building\"\"\" if latitude < MIN_LATITUDE or latitude > MAX_LATITUDE : raise LatitudeNotInRangeError ( latitude ) self . _latitude = latitude @property def longitude ( self ) -> float : \"\"\"float: Longitude property of a building\"\"\" return self . _longitude @longitude . setter def longitude ( self , longitude : float ) -> None : \"\"\"Setter method for longitude property of a building\"\"\" if longitude < MIN_LONGITUDE or longitude > MAX_LONGITUDE : raise LongitudeNotInRangeError ( longitude ) self . _longitude = longitude def __eq__ ( self , other ): return ( self . latitude == other . latitude and self . longitude == other . longitude ) def __hash__ ( self ): return hash (( self . latitude , self . longitude )) latitude () property writable float: Latitude property of a building Source code in shift\\geometry.py 74 75 76 77 @property def latitude ( self ) -> float : \"\"\"float: Latitude property of a building\"\"\" return self . _latitude longitude () property writable float: Longitude property of a building Source code in shift\\geometry.py 86 87 88 89 @property def longitude ( self ) -> float : \"\"\"float: Longitude property of a building\"\"\" return self . _longitude OpenStreetBuildingGeometries Bases: OpenStreetGeometries Concrete implementations of open street building geometries Source code in shift\\geometry.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 class OpenStreetBuildingGeometries ( OpenStreetGeometries ): \"\"\"Concrete implementations of open street building geometries\"\"\" def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Refer to base class for details.\"\"\" # Create container for holding list of geometries concrete_geometries = [] # Get geo dataframe object implemented by child OpenStreet Geometries subclass gdf_data = self . get_gdf () . to_dict ( orient = \"records\" ) # Loop through all the rows in geo dataframe to create list of concrete geometries for row in gdf_data : # Looping through only either point or polygon geometries if row [ \"geometry\" ] . geom_type in [ \"Point\" , \"Polygon\" ]: if row [ \"geometry\" ] . geom_type == \"Point\" : centre = list ( row [ \"geometry\" ] . coords )[ 0 ] area = 0 else : centre = list ( row [ \"geometry\" ] . centroid . coords )[ 0 ] # By default shapely gives area in square degrees # By assuming the earth to be a perfect square of 6370 meter square # area can be computed as below but it's not accurate however does the job for now area = row [ \"geometry\" ] . area * 6370 ** 2 # Create individual geometry geometry = BuildingGeometry () geometry . latitude = centre [ 1 ] geometry . longitude = centre [ 0 ] geometry . area = round ( area , 2 ) if geometry not in concrete_geometries : concrete_geometries . append ( geometry ) return concrete_geometries get_geometries () Refer to base class for details. Source code in shift\\geometry.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Refer to base class for details.\"\"\" # Create container for holding list of geometries concrete_geometries = [] # Get geo dataframe object implemented by child OpenStreet Geometries subclass gdf_data = self . get_gdf () . to_dict ( orient = \"records\" ) # Loop through all the rows in geo dataframe to create list of concrete geometries for row in gdf_data : # Looping through only either point or polygon geometries if row [ \"geometry\" ] . geom_type in [ \"Point\" , \"Polygon\" ]: if row [ \"geometry\" ] . geom_type == \"Point\" : centre = list ( row [ \"geometry\" ] . coords )[ 0 ] area = 0 else : centre = list ( row [ \"geometry\" ] . centroid . coords )[ 0 ] # By default shapely gives area in square degrees # By assuming the earth to be a perfect square of 6370 meter square # area can be computed as below but it's not accurate however does the job for now area = row [ \"geometry\" ] . area * 6370 ** 2 # Create individual geometry geometry = BuildingGeometry () geometry . latitude = centre [ 1 ] geometry . longitude = centre [ 0 ] geometry . area = round ( area , 2 ) if geometry not in concrete_geometries : concrete_geometries . append ( geometry ) return concrete_geometries OpenStreetGeometries Bases: ABC Interface for getting geometries from OpenStreet data. Source code in shift\\geometry.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 class OpenStreetGeometries ( ABC ): \"\"\"Interface for getting geometries from OpenStreet data.\"\"\" @abstractmethod def get_gdf ( self ) -> pd . DataFrame : \"\"\"Method to return the geo dataframe containing all the buildings. Returns: pd.DataFrame: Geo dataframe containing all the buildings. \"\"\" pass @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Method to return all the geometry objects. Returns: List[Geometry]: list of all the building geometry objects. \"\"\" pass get_gdf () abstractmethod Method to return the geo dataframe containing all the buildings. Returns: Type Description pd . DataFrame pd.DataFrame: Geo dataframe containing all the buildings. Source code in shift\\geometry.py 217 218 219 220 221 222 223 224 @abstractmethod def get_gdf ( self ) -> pd . DataFrame : \"\"\"Method to return the geo dataframe containing all the buildings. Returns: pd.DataFrame: Geo dataframe containing all the buildings. \"\"\" pass get_geometries () abstractmethod Method to return all the geometry objects. Returns: Type Description List [ Geometry ] List[Geometry]: list of all the building geometry objects. Source code in shift\\geometry.py 226 227 228 229 230 231 232 233 @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Method to return all the geometry objects. Returns: List[Geometry]: list of all the building geometry objects. \"\"\" pass SimpleLoadGeometriesFromCSV Bases: GeometriesFromCSV Concrete implementations for getting simple load geometries from CSV file. Refer to the base class for more deatils on how to construct the object. Source code in shift\\geometry.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 class SimpleLoadGeometriesFromCSV ( GeometriesFromCSV ): \"\"\"Concrete implementations for getting simple load geometries from CSV file. Refer to the base class for more deatils on how to construct the object. \"\"\" def get_geometries ( self ): \"\"\"Method to get all the gepmetries from csv.\"\"\" # Let's loop through all records and create all the geometries concrete_geometries = [] for record in self . df . to_dict ( orient = \"records\" ): geometry = SimpleLoadGeometry () geometry . latitude = record [ \"latitude\" ] geometry . longitude = record [ \"longitude\" ] geometry . kw = record [ \"kw\" ] concrete_geometries . append ( geometry ) return concrete_geometries def validate ( self ): \"\"\"Method to validate the content of csv file.\"\"\" return df_validator ( SIMPLELOADGEOMETRY_SCHEMA , self . df ) get_geometries () Method to get all the gepmetries from csv. Source code in shift\\geometry.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def get_geometries ( self ): \"\"\"Method to get all the gepmetries from csv.\"\"\" # Let's loop through all records and create all the geometries concrete_geometries = [] for record in self . df . to_dict ( orient = \"records\" ): geometry = SimpleLoadGeometry () geometry . latitude = record [ \"latitude\" ] geometry . longitude = record [ \"longitude\" ] geometry . kw = record [ \"kw\" ] concrete_geometries . append ( geometry ) return concrete_geometries validate () Method to validate the content of csv file. Source code in shift\\geometry.py 209 210 211 def validate ( self ): \"\"\"Method to validate the content of csv file.\"\"\" return df_validator ( SIMPLELOADGEOMETRY_SCHEMA , self . df ) SimpleLoadGeometry Bases: Geometry Implementation for simple load point geometry Source code in shift\\geometry.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 class SimpleLoadGeometry ( Geometry ): \"\"\"Implementation for simple load point geometry\"\"\" @property def kw ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _kw @kw . setter def kw ( self , kw : float ) -> None : \"\"\"Setter method for area property of a building\"\"\" self . _kw = kw def __repr__ ( self ): return f \"Building( Latitude = { self . latitude } , Longitude = { self . longitude } , kW = { self . kw } )\" kw () property writable float: Area property of a building Source code in shift\\geometry.py 130 131 132 133 @property def kw ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _kw","title":"geometry"},{"location":"geometry/#shift.geometry.BuildingGeometry","text":"Bases: Geometry Implementation for Building geometry. Source code in shift\\geometry.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class BuildingGeometry ( Geometry ): \"\"\"Implementation for Building geometry.\"\"\" @property def area ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _area @area . setter def area ( self , area : float ) -> None : \"\"\"Setter method for area property of a building\"\"\" if area < 0 : raise NegativeAreaError ( area ) self . _area = area def __repr__ ( self ): return f \"Building( Latitude = { self . latitude } , Longitude = { self . longitude } , Area = { self . area } )\"","title":"BuildingGeometry"},{"location":"geometry/#shift.geometry.BuildingGeometry.area","text":"float: Area property of a building Source code in shift\\geometry.py 111 112 113 114 @property def area ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _area","title":"area()"},{"location":"geometry/#shift.geometry.BuildingsFromPlace","text":"Bases: OpenStreetBuildingGeometries Getting building geometries from a place address within bounding box. Attributes: Name Type Description place str Any place in string format e.g. chennai, india max_dist float Distance in meter from the point to create a bounding box Source code in shift\\geometry.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 class BuildingsFromPlace ( OpenStreetBuildingGeometries ): \"\"\"Getting building geometries from a place address within bounding box. Attributes: place (str): Any place in string format e.g. chennai, india max_dist (float): Distance in meter from the point to create a bounding box \"\"\" def __init__ ( self , place : str , max_dist = 1000 ) -> None : \"\"\"Instantiating the class. Args: place (str): Any place in string format e.g. chennai, india max_dist (float): Distance in meter from the place to create a bounding box \"\"\" # e.g. Chennai, India self . place = place self . max_dist = max_dist def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_address ( self . place , { \"building\" : True }, dist = self . max_dist )","title":"BuildingsFromPlace"},{"location":"geometry/#shift.geometry.BuildingsFromPlace.__init__","text":"Instantiating the class. Parameters: Name Type Description Default place str Any place in string format e.g. chennai, india required max_dist float Distance in meter from the place to create a bounding box 1000 Source code in shift\\geometry.py 312 313 314 315 316 317 318 319 320 321 322 323 def __init__ ( self , place : str , max_dist = 1000 ) -> None : \"\"\"Instantiating the class. Args: place (str): Any place in string format e.g. chennai, india max_dist (float): Distance in meter from the place to create a bounding box \"\"\" # e.g. Chennai, India self . place = place self . max_dist = max_dist","title":"__init__()"},{"location":"geometry/#shift.geometry.BuildingsFromPlace.get_gdf","text":"Refer to base class for details. Source code in shift\\geometry.py 325 326 327 328 329 def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_address ( self . place , { \"building\" : True }, dist = self . max_dist )","title":"get_gdf()"},{"location":"geometry/#shift.geometry.BuildingsFromPoint","text":"Bases: OpenStreetBuildingGeometries Getting building geometries from single point within bounding box. Attributes: Name Type Description point Sequence Point in (longitude, latitude) format max_dist float Distance in meter from the point to create a bounding box Source code in shift\\geometry.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 class BuildingsFromPoint ( OpenStreetBuildingGeometries ): \"\"\"Getting building geometries from single point within bounding box. Attributes: point (Sequence): Point in (longitude, latitude) format max_dist (float): Distance in meter from the point to create a bounding box \"\"\" def __init__ ( self , point : Sequence , max_dist : float = 1000 ) -> None : \"\"\"Instantiating the class. Args: point (Sequence): Point in (longitude, latitude) format max_dist (float): Distance in meter from the point to create a bounding box \"\"\" # e.g. (13.242134, 80.275948) self . point = point self . max_dist = max_dist def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_point ( self . point , { \"building\" : True }, dist = self . max_dist )","title":"BuildingsFromPoint"},{"location":"geometry/#shift.geometry.BuildingsFromPoint.__init__","text":"Instantiating the class. Parameters: Name Type Description Default point Sequence Point in (longitude, latitude) format required max_dist float Distance in meter from the point to create a bounding box 1000 Source code in shift\\geometry.py 285 286 287 288 289 290 291 292 293 294 295 def __init__ ( self , point : Sequence , max_dist : float = 1000 ) -> None : \"\"\"Instantiating the class. Args: point (Sequence): Point in (longitude, latitude) format max_dist (float): Distance in meter from the point to create a bounding box \"\"\" # e.g. (13.242134, 80.275948) self . point = point self . max_dist = max_dist","title":"__init__()"},{"location":"geometry/#shift.geometry.BuildingsFromPoint.get_gdf","text":"Refer to base class for details. Source code in shift\\geometry.py 297 298 299 300 301 def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_point ( self . point , { \"building\" : True }, dist = self . max_dist )","title":"get_gdf()"},{"location":"geometry/#shift.geometry.BuildingsFromPolygon","text":"Bases: OpenStreetBuildingGeometries Getting building geometries from a given polygon. Attributes: Name Type Description polygon List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] Source code in shift\\geometry.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 class BuildingsFromPolygon ( OpenStreetBuildingGeometries ): \"\"\"Getting building geometries from a given polygon. Attributes: polygon: List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] \"\"\" def __init__ ( self , polygon : List [ list ]) -> None : \"\"\"Instantiating the class. Args: polygon: List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] \"\"\" self . polygon = polygon def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_polygon ( self . polygon , { \"building\" : True })","title":"BuildingsFromPolygon"},{"location":"geometry/#shift.geometry.BuildingsFromPolygon.__init__","text":"Instantiating the class. Parameters: Name Type Description Default polygon List [ list ] List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] required Source code in shift\\geometry.py 339 340 341 342 343 344 345 346 def __init__ ( self , polygon : List [ list ]) -> None : \"\"\"Instantiating the class. Args: polygon: List[list]: Polygon to be used e.g. [[13.242134, 80.275948]] \"\"\" self . polygon = polygon","title":"__init__()"},{"location":"geometry/#shift.geometry.BuildingsFromPolygon.get_gdf","text":"Refer to base class for details. Source code in shift\\geometry.py 348 349 350 def get_gdf ( self ) -> pd . DataFrame : \"\"\"Refer to base class for details.\"\"\" return ox . geometries_from_polygon ( self . polygon , { \"building\" : True })","title":"get_gdf()"},{"location":"geometry/#shift.geometry.GeometriesFromCSV","text":"Bases: ABC Interface for getting geometries from CSV file Attributes: Name Type Description csv_file str Path to csv file df pd . DataFrame dataframe holding the content of csv file Source code in shift\\geometry.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class GeometriesFromCSV ( ABC ): \"\"\"Interface for getting geometries from CSV file Attributes: csv_file (str): Path to csv file df (pd.DataFrame): dataframe holding the content of csv file \"\"\" def __init__ ( self , csv_file : str ) -> None : \"\"\"Method for instantiationg the class. Args: csv_file (str): Path to valid csv file Raises: FileNotFoundError: If csv file is not found NotCompatibleFileError: If the file pssed is not csv \"\"\" self . csv_file = csv_file if not os . path . exists ( csv_file ): raise FileNotFoundError ( csv_file ) else : if not csv_file . endswith ( \".csv\" ): raise NotCompatibleFileError ( csv_file , \".csv\" ) self . df = pd . read_csv ( csv_file ) self . validate () @abstractmethod def validate ( self ) -> bool : \"\"\"Child class must implement validate method.\"\"\" pass @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Child class must implement method to return list of geometries.\"\"\" pass","title":"GeometriesFromCSV"},{"location":"geometry/#shift.geometry.GeometriesFromCSV.__init__","text":"Method for instantiationg the class. Parameters: Name Type Description Default csv_file str Path to valid csv file required Raises: Type Description FileNotFoundError If csv file is not found NotCompatibleFileError If the file pssed is not csv Source code in shift\\geometry.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def __init__ ( self , csv_file : str ) -> None : \"\"\"Method for instantiationg the class. Args: csv_file (str): Path to valid csv file Raises: FileNotFoundError: If csv file is not found NotCompatibleFileError: If the file pssed is not csv \"\"\" self . csv_file = csv_file if not os . path . exists ( csv_file ): raise FileNotFoundError ( csv_file ) else : if not csv_file . endswith ( \".csv\" ): raise NotCompatibleFileError ( csv_file , \".csv\" ) self . df = pd . read_csv ( csv_file ) self . validate ()","title":"__init__()"},{"location":"geometry/#shift.geometry.GeometriesFromCSV.get_geometries","text":"Child class must implement method to return list of geometries. Source code in shift\\geometry.py 179 180 181 182 @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Child class must implement method to return list of geometries.\"\"\" pass","title":"get_geometries()"},{"location":"geometry/#shift.geometry.GeometriesFromCSV.validate","text":"Child class must implement validate method. Source code in shift\\geometry.py 174 175 176 177 @abstractmethod def validate ( self ) -> bool : \"\"\"Child class must implement validate method.\"\"\" pass","title":"validate()"},{"location":"geometry/#shift.geometry.Geometry","text":"Bases: ABC Interface for Geometry object. Source code in shift\\geometry.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class Geometry ( ABC ): \"\"\"Interface for Geometry object.\"\"\" @property def latitude ( self ) -> float : \"\"\"float: Latitude property of a building\"\"\" return self . _latitude @latitude . setter def latitude ( self , latitude : float ) -> None : \"\"\"Setter method for latitude property of a building\"\"\" if latitude < MIN_LATITUDE or latitude > MAX_LATITUDE : raise LatitudeNotInRangeError ( latitude ) self . _latitude = latitude @property def longitude ( self ) -> float : \"\"\"float: Longitude property of a building\"\"\" return self . _longitude @longitude . setter def longitude ( self , longitude : float ) -> None : \"\"\"Setter method for longitude property of a building\"\"\" if longitude < MIN_LONGITUDE or longitude > MAX_LONGITUDE : raise LongitudeNotInRangeError ( longitude ) self . _longitude = longitude def __eq__ ( self , other ): return ( self . latitude == other . latitude and self . longitude == other . longitude ) def __hash__ ( self ): return hash (( self . latitude , self . longitude ))","title":"Geometry"},{"location":"geometry/#shift.geometry.Geometry.latitude","text":"float: Latitude property of a building Source code in shift\\geometry.py 74 75 76 77 @property def latitude ( self ) -> float : \"\"\"float: Latitude property of a building\"\"\" return self . _latitude","title":"latitude()"},{"location":"geometry/#shift.geometry.Geometry.longitude","text":"float: Longitude property of a building Source code in shift\\geometry.py 86 87 88 89 @property def longitude ( self ) -> float : \"\"\"float: Longitude property of a building\"\"\" return self . _longitude","title":"longitude()"},{"location":"geometry/#shift.geometry.OpenStreetBuildingGeometries","text":"Bases: OpenStreetGeometries Concrete implementations of open street building geometries Source code in shift\\geometry.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 class OpenStreetBuildingGeometries ( OpenStreetGeometries ): \"\"\"Concrete implementations of open street building geometries\"\"\" def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Refer to base class for details.\"\"\" # Create container for holding list of geometries concrete_geometries = [] # Get geo dataframe object implemented by child OpenStreet Geometries subclass gdf_data = self . get_gdf () . to_dict ( orient = \"records\" ) # Loop through all the rows in geo dataframe to create list of concrete geometries for row in gdf_data : # Looping through only either point or polygon geometries if row [ \"geometry\" ] . geom_type in [ \"Point\" , \"Polygon\" ]: if row [ \"geometry\" ] . geom_type == \"Point\" : centre = list ( row [ \"geometry\" ] . coords )[ 0 ] area = 0 else : centre = list ( row [ \"geometry\" ] . centroid . coords )[ 0 ] # By default shapely gives area in square degrees # By assuming the earth to be a perfect square of 6370 meter square # area can be computed as below but it's not accurate however does the job for now area = row [ \"geometry\" ] . area * 6370 ** 2 # Create individual geometry geometry = BuildingGeometry () geometry . latitude = centre [ 1 ] geometry . longitude = centre [ 0 ] geometry . area = round ( area , 2 ) if geometry not in concrete_geometries : concrete_geometries . append ( geometry ) return concrete_geometries","title":"OpenStreetBuildingGeometries"},{"location":"geometry/#shift.geometry.OpenStreetBuildingGeometries.get_geometries","text":"Refer to base class for details. Source code in shift\\geometry.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Refer to base class for details.\"\"\" # Create container for holding list of geometries concrete_geometries = [] # Get geo dataframe object implemented by child OpenStreet Geometries subclass gdf_data = self . get_gdf () . to_dict ( orient = \"records\" ) # Loop through all the rows in geo dataframe to create list of concrete geometries for row in gdf_data : # Looping through only either point or polygon geometries if row [ \"geometry\" ] . geom_type in [ \"Point\" , \"Polygon\" ]: if row [ \"geometry\" ] . geom_type == \"Point\" : centre = list ( row [ \"geometry\" ] . coords )[ 0 ] area = 0 else : centre = list ( row [ \"geometry\" ] . centroid . coords )[ 0 ] # By default shapely gives area in square degrees # By assuming the earth to be a perfect square of 6370 meter square # area can be computed as below but it's not accurate however does the job for now area = row [ \"geometry\" ] . area * 6370 ** 2 # Create individual geometry geometry = BuildingGeometry () geometry . latitude = centre [ 1 ] geometry . longitude = centre [ 0 ] geometry . area = round ( area , 2 ) if geometry not in concrete_geometries : concrete_geometries . append ( geometry ) return concrete_geometries","title":"get_geometries()"},{"location":"geometry/#shift.geometry.OpenStreetGeometries","text":"Bases: ABC Interface for getting geometries from OpenStreet data. Source code in shift\\geometry.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 class OpenStreetGeometries ( ABC ): \"\"\"Interface for getting geometries from OpenStreet data.\"\"\" @abstractmethod def get_gdf ( self ) -> pd . DataFrame : \"\"\"Method to return the geo dataframe containing all the buildings. Returns: pd.DataFrame: Geo dataframe containing all the buildings. \"\"\" pass @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Method to return all the geometry objects. Returns: List[Geometry]: list of all the building geometry objects. \"\"\" pass","title":"OpenStreetGeometries"},{"location":"geometry/#shift.geometry.OpenStreetGeometries.get_gdf","text":"Method to return the geo dataframe containing all the buildings. Returns: Type Description pd . DataFrame pd.DataFrame: Geo dataframe containing all the buildings. Source code in shift\\geometry.py 217 218 219 220 221 222 223 224 @abstractmethod def get_gdf ( self ) -> pd . DataFrame : \"\"\"Method to return the geo dataframe containing all the buildings. Returns: pd.DataFrame: Geo dataframe containing all the buildings. \"\"\" pass","title":"get_gdf()"},{"location":"geometry/#shift.geometry.OpenStreetGeometries.get_geometries","text":"Method to return all the geometry objects. Returns: Type Description List [ Geometry ] List[Geometry]: list of all the building geometry objects. Source code in shift\\geometry.py 226 227 228 229 230 231 232 233 @abstractmethod def get_geometries ( self ) -> List [ Geometry ]: \"\"\"Method to return all the geometry objects. Returns: List[Geometry]: list of all the building geometry objects. \"\"\" pass","title":"get_geometries()"},{"location":"geometry/#shift.geometry.SimpleLoadGeometriesFromCSV","text":"Bases: GeometriesFromCSV Concrete implementations for getting simple load geometries from CSV file. Refer to the base class for more deatils on how to construct the object. Source code in shift\\geometry.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 class SimpleLoadGeometriesFromCSV ( GeometriesFromCSV ): \"\"\"Concrete implementations for getting simple load geometries from CSV file. Refer to the base class for more deatils on how to construct the object. \"\"\" def get_geometries ( self ): \"\"\"Method to get all the gepmetries from csv.\"\"\" # Let's loop through all records and create all the geometries concrete_geometries = [] for record in self . df . to_dict ( orient = \"records\" ): geometry = SimpleLoadGeometry () geometry . latitude = record [ \"latitude\" ] geometry . longitude = record [ \"longitude\" ] geometry . kw = record [ \"kw\" ] concrete_geometries . append ( geometry ) return concrete_geometries def validate ( self ): \"\"\"Method to validate the content of csv file.\"\"\" return df_validator ( SIMPLELOADGEOMETRY_SCHEMA , self . df )","title":"SimpleLoadGeometriesFromCSV"},{"location":"geometry/#shift.geometry.SimpleLoadGeometriesFromCSV.get_geometries","text":"Method to get all the gepmetries from csv. Source code in shift\\geometry.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def get_geometries ( self ): \"\"\"Method to get all the gepmetries from csv.\"\"\" # Let's loop through all records and create all the geometries concrete_geometries = [] for record in self . df . to_dict ( orient = \"records\" ): geometry = SimpleLoadGeometry () geometry . latitude = record [ \"latitude\" ] geometry . longitude = record [ \"longitude\" ] geometry . kw = record [ \"kw\" ] concrete_geometries . append ( geometry ) return concrete_geometries","title":"get_geometries()"},{"location":"geometry/#shift.geometry.SimpleLoadGeometriesFromCSV.validate","text":"Method to validate the content of csv file. Source code in shift\\geometry.py 209 210 211 def validate ( self ): \"\"\"Method to validate the content of csv file.\"\"\" return df_validator ( SIMPLELOADGEOMETRY_SCHEMA , self . df )","title":"validate()"},{"location":"geometry/#shift.geometry.SimpleLoadGeometry","text":"Bases: Geometry Implementation for simple load point geometry Source code in shift\\geometry.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 class SimpleLoadGeometry ( Geometry ): \"\"\"Implementation for simple load point geometry\"\"\" @property def kw ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _kw @kw . setter def kw ( self , kw : float ) -> None : \"\"\"Setter method for area property of a building\"\"\" self . _kw = kw def __repr__ ( self ): return f \"Building( Latitude = { self . latitude } , Longitude = { self . longitude } , kW = { self . kw } )\"","title":"SimpleLoadGeometry"},{"location":"geometry/#shift.geometry.SimpleLoadGeometry.kw","text":"float: Area property of a building Source code in shift\\geometry.py 130 131 132 133 @property def kw ( self ) -> float : \"\"\"float: Area property of a building\"\"\" return self . _kw","title":"kw()"},{"location":"graph/","text":"This module manages graph network representing roads from openstreet data. Examples: >>> from shift.graph import RoadNetworkFromPlace >>> graph = RoadNetworkFromPlace ( 'chennai, india' ) >>> graph . get_network () OpenStreetRoadNetwork Bases: ABC Interface for getting road network from OpenStreet data Attributes: Name Type Description updated_network nx . Graph Graph of road network with udpated metadata Raises: Type Description AttributeDoesNotExistError If graph attribute does not already exist. Source code in shift\\graph.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class OpenStreetRoadNetwork ( ABC ): \"\"\"Interface for getting road network from OpenStreet data Attributes: updated_network (nx.Graph): Graph of road network with udpated metadata Raises: AttributeDoesNotExistError: If `graph` attribute does not already exist. \"\"\" def get_network ( self , node_append_str = Union [ str , None ]) -> nx . Graph : \"\"\"Returns a minimum spanning tree with updated metadata. Args: node_append_str (Union[str, None]): String to append in the name of all nodes \"\"\" if hasattr ( self , \"graph\" ): # Converting diected graph to undirected graph network = self . graph . to_undirected () # Find a minimum spanning tree of the network network = nx . minimum_spanning_tree ( network ) if node_append_str : network = nx . relabel_nodes ( network , { n : str ( n ) + node_append_str for n in network . nodes ()}, ) self . updated_network = nx . Graph () for node in network . nodes . data (): # x is longitude and y is latitude self . updated_network . add_node ( node [ 0 ], pos = ( node [ 1 ][ \"x\" ], node [ 1 ][ \"y\" ]), type = \"node\" , data = node [ 1 ], ) for edge in network . edges (): self . updated_network . add_edge ( edge [ 0 ], edge [ 1 ], type = \"edge\" ) return self . updated_network else : raise AttributeDoesNotExistError ( f \"'graph' attribute does not exist yet \\ for OpenStreet type road netwwork!\" ) get_network ( node_append_str = Union [ str , None ]) Returns a minimum spanning tree with updated metadata. Parameters: Name Type Description Default node_append_str Union [ str , None] String to append in the name of all nodes Union[str, None] Source code in shift\\graph.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_network ( self , node_append_str = Union [ str , None ]) -> nx . Graph : \"\"\"Returns a minimum spanning tree with updated metadata. Args: node_append_str (Union[str, None]): String to append in the name of all nodes \"\"\" if hasattr ( self , \"graph\" ): # Converting diected graph to undirected graph network = self . graph . to_undirected () # Find a minimum spanning tree of the network network = nx . minimum_spanning_tree ( network ) if node_append_str : network = nx . relabel_nodes ( network , { n : str ( n ) + node_append_str for n in network . nodes ()}, ) self . updated_network = nx . Graph () for node in network . nodes . data (): # x is longitude and y is latitude self . updated_network . add_node ( node [ 0 ], pos = ( node [ 1 ][ \"x\" ], node [ 1 ][ \"y\" ]), type = \"node\" , data = node [ 1 ], ) for edge in network . edges (): self . updated_network . add_edge ( edge [ 0 ], edge [ 1 ], type = \"edge\" ) return self . updated_network else : raise AttributeDoesNotExistError ( f \"'graph' attribute does not exist yet \\ for OpenStreet type road netwwork!\" ) RoadNetworkFromPlace Bases: OpenStreetRoadNetwork Getting road network from a place address within bounding box. Attributes: Name Type Description place str string representing location max_dist float Distance to be used to create bounding box around a point dist_type str Type of region to be created around the point network_type str Type of network to be retrived from openstreet data Source code in shift\\graph.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class RoadNetworkFromPlace ( OpenStreetRoadNetwork ): \"\"\"Getting road network from a place address within bounding box. Attributes: place (str): string representing location max_dist (float): Distance to be used to create bounding box around a point dist_type (str): Type of region to be created around the point network_type (str): Type of network to be retrived from openstreet data \"\"\" def __init__ ( self , place : str , max_dist : float = 1000 , dist_type : str = \"bbox\" , network_type : str = \"drive\" , ) -> None : \"\"\"Constructor for `RoadNetworkFromPlace` class. Args: place (str): string representing location max_dist (float): Distance to be used to create bounding box around a point dist_type (str): Type of region to be created around the point network_type (str): Type of network to be retrived from openstreet data \"\"\" # e.g. Chennai, India self . place = place self . max_dist = max_dist self . dist_type = dist_type self . network_type = network_type def get_network ( self , node_append_str : Union [ str , None ] = None ) -> nx . Graph : \"\"\"Refer to base class for more details.\"\"\" self . graph = ox . graph . graph_from_address ( self . place , dist = self . max_dist , dist_type = self . dist_type , network_type = self . network_type , ) super () . get_network ( node_append_str ) __init__ ( place , max_dist = 1000 , dist_type = 'bbox' , network_type = 'drive' ) Constructor for RoadNetworkFromPlace class. Parameters: Name Type Description Default place str string representing location required max_dist float Distance to be used to create bounding box around a point 1000 dist_type str Type of region to be created around the point 'bbox' network_type str Type of network to be retrived from openstreet data 'drive' Source code in shift\\graph.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def __init__ ( self , place : str , max_dist : float = 1000 , dist_type : str = \"bbox\" , network_type : str = \"drive\" , ) -> None : \"\"\"Constructor for `RoadNetworkFromPlace` class. Args: place (str): string representing location max_dist (float): Distance to be used to create bounding box around a point dist_type (str): Type of region to be created around the point network_type (str): Type of network to be retrived from openstreet data \"\"\" # e.g. Chennai, India self . place = place self . max_dist = max_dist self . dist_type = dist_type self . network_type = network_type get_network ( node_append_str = None ) Refer to base class for more details. Source code in shift\\graph.py 174 175 176 177 178 179 180 181 182 def get_network ( self , node_append_str : Union [ str , None ] = None ) -> nx . Graph : \"\"\"Refer to base class for more details.\"\"\" self . graph = ox . graph . graph_from_address ( self . place , dist = self . max_dist , dist_type = self . dist_type , network_type = self . network_type , ) super () . get_network ( node_append_str ) RoadNetworkFromPoint Bases: OpenStreetRoadNetwork Getting road network from single point within bounding box. Attributes: Name Type Description point tuple (longitude, latitude) pair representing point location max_dist float Distance to be used to create bounding box around a point dist_type str Type of region to be created around the point network_type str Type of network to be retrived from openstreet data Source code in shift\\graph.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 class RoadNetworkFromPoint ( OpenStreetRoadNetwork ): \"\"\"Getting road network from single point within bounding box. Attributes: point (tuple): (longitude, latitude) pair representing point location max_dist (float): Distance to be used to create bounding box around a point dist_type (str): Type of region to be created around the point network_type (str): Type of network to be retrived from openstreet data \"\"\" def __init__ ( self , point : tuple , max_dist : float = 1000 , dist_type : str = \"bbox\" , network_type : str = \"drive\" , ) -> None : \"\"\"Constructor for `RoadNetworkFromPoint` class. Args: point (tuple): (longitude, latitude) pair representing point location max_dist (float): Distance to be used to create bounding box around a point dist_type (str): Type of region to be created around the point network_type (str): Type of network to be retrived from openstreet data \"\"\" # e.g. (13.242134, 80.275948) self . point = point self . max_dist = max_dist self . dist_type = dist_type self . network_type = network_type def get_network ( self , node_append_str : Union [ str , None ] = None ) -> nx . Graph : \"\"\"Refer to base class for more details.\"\"\" self . graph = ox . graph . graph_from_point ( self . point , dist = self . max_dist , dist_type = self . dist_type , network_type = self . network_type , ) super () . get_network ( node_append_str ) __init__ ( point , max_dist = 1000 , dist_type = 'bbox' , network_type = 'drive' ) Constructor for RoadNetworkFromPoint class. Parameters: Name Type Description Default point tuple (longitude, latitude) pair representing point location required max_dist float Distance to be used to create bounding box around a point 1000 dist_type str Type of region to be created around the point 'bbox' network_type str Type of network to be retrived from openstreet data 'drive' Source code in shift\\graph.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def __init__ ( self , point : tuple , max_dist : float = 1000 , dist_type : str = \"bbox\" , network_type : str = \"drive\" , ) -> None : \"\"\"Constructor for `RoadNetworkFromPoint` class. Args: point (tuple): (longitude, latitude) pair representing point location max_dist (float): Distance to be used to create bounding box around a point dist_type (str): Type of region to be created around the point network_type (str): Type of network to be retrived from openstreet data \"\"\" # e.g. (13.242134, 80.275948) self . point = point self . max_dist = max_dist self . dist_type = dist_type self . network_type = network_type get_network ( node_append_str = None ) Refer to base class for more details. Source code in shift\\graph.py 132 133 134 135 136 137 138 139 140 def get_network ( self , node_append_str : Union [ str , None ] = None ) -> nx . Graph : \"\"\"Refer to base class for more details.\"\"\" self . graph = ox . graph . graph_from_point ( self . point , dist = self . max_dist , dist_type = self . dist_type , network_type = self . network_type , ) super () . get_network ( node_append_str ) RoadNetworkFromPolygon Bases: OpenStreetRoadNetwork Getting road network from a given polygon. Attributes: Name Type Description polygon List [ list ] List of (lon, lat) pairs custom_filter str Valid osmnx type customer filter to be applied Source code in shift\\graph.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 class RoadNetworkFromPolygon ( OpenStreetRoadNetwork ): \"\"\"Getting road network from a given polygon. Attributes: polygon (List[list]): List of (lon, lat) pairs custom_filter (str): Valid osmnx type customer filter to be applied \"\"\" def __init__ ( self , polygon : List [ list ], custom_filter : str = '[\"highway\"]' ) -> None : \"\"\"Constructor for `RoadNetworkFromPolygon` class. Args: polygon (List[list]): List of (lon, lat) pairs custom_filter (str): Valid osmnx type customer filter to be applied \"\"\" # e.g. [[13.242134, 80.275948]] self . polygon = polygon self . custom_filter = custom_filter def get_network ( self , node_append_str : Union [ str , None ] = None ) -> nx . Graph : \"\"\"Refer to base class for more details.\"\"\" polygon = shapely . geometry . Polygon ( self . polygon ) self . graph = ox . graph . graph_from_polygon ( polygon , custom_filter = self . custom_filter ) super () . get_network ( node_append_str ) __init__ ( polygon , custom_filter = '[\"highway\"]' ) Constructor for RoadNetworkFromPolygon class. Parameters: Name Type Description Default polygon List [ list ] List of (lon, lat) pairs required custom_filter str Valid osmnx type customer filter to be applied '[\"highway\"]' Source code in shift\\graph.py 193 194 195 196 197 198 199 200 201 202 203 204 205 def __init__ ( self , polygon : List [ list ], custom_filter : str = '[\"highway\"]' ) -> None : \"\"\"Constructor for `RoadNetworkFromPolygon` class. Args: polygon (List[list]): List of (lon, lat) pairs custom_filter (str): Valid osmnx type customer filter to be applied \"\"\" # e.g. [[13.242134, 80.275948]] self . polygon = polygon self . custom_filter = custom_filter get_network ( node_append_str = None ) Refer to base class for more details. Source code in shift\\graph.py 207 208 209 210 211 212 213 214 def get_network ( self , node_append_str : Union [ str , None ] = None ) -> nx . Graph : \"\"\"Refer to base class for more details.\"\"\" polygon = shapely . geometry . Polygon ( self . polygon ) self . graph = ox . graph . graph_from_polygon ( polygon , custom_filter = self . custom_filter ) super () . get_network ( node_append_str )","title":"graph"},{"location":"graph/#shift.graph.OpenStreetRoadNetwork","text":"Bases: ABC Interface for getting road network from OpenStreet data Attributes: Name Type Description updated_network nx . Graph Graph of road network with udpated metadata Raises: Type Description AttributeDoesNotExistError If graph attribute does not already exist. Source code in shift\\graph.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class OpenStreetRoadNetwork ( ABC ): \"\"\"Interface for getting road network from OpenStreet data Attributes: updated_network (nx.Graph): Graph of road network with udpated metadata Raises: AttributeDoesNotExistError: If `graph` attribute does not already exist. \"\"\" def get_network ( self , node_append_str = Union [ str , None ]) -> nx . Graph : \"\"\"Returns a minimum spanning tree with updated metadata. Args: node_append_str (Union[str, None]): String to append in the name of all nodes \"\"\" if hasattr ( self , \"graph\" ): # Converting diected graph to undirected graph network = self . graph . to_undirected () # Find a minimum spanning tree of the network network = nx . minimum_spanning_tree ( network ) if node_append_str : network = nx . relabel_nodes ( network , { n : str ( n ) + node_append_str for n in network . nodes ()}, ) self . updated_network = nx . Graph () for node in network . nodes . data (): # x is longitude and y is latitude self . updated_network . add_node ( node [ 0 ], pos = ( node [ 1 ][ \"x\" ], node [ 1 ][ \"y\" ]), type = \"node\" , data = node [ 1 ], ) for edge in network . edges (): self . updated_network . add_edge ( edge [ 0 ], edge [ 1 ], type = \"edge\" ) return self . updated_network else : raise AttributeDoesNotExistError ( f \"'graph' attribute does not exist yet \\ for OpenStreet type road netwwork!\" )","title":"OpenStreetRoadNetwork"},{"location":"graph/#shift.graph.OpenStreetRoadNetwork.get_network","text":"Returns a minimum spanning tree with updated metadata. Parameters: Name Type Description Default node_append_str Union [ str , None] String to append in the name of all nodes Union[str, None] Source code in shift\\graph.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_network ( self , node_append_str = Union [ str , None ]) -> nx . Graph : \"\"\"Returns a minimum spanning tree with updated metadata. Args: node_append_str (Union[str, None]): String to append in the name of all nodes \"\"\" if hasattr ( self , \"graph\" ): # Converting diected graph to undirected graph network = self . graph . to_undirected () # Find a minimum spanning tree of the network network = nx . minimum_spanning_tree ( network ) if node_append_str : network = nx . relabel_nodes ( network , { n : str ( n ) + node_append_str for n in network . nodes ()}, ) self . updated_network = nx . Graph () for node in network . nodes . data (): # x is longitude and y is latitude self . updated_network . add_node ( node [ 0 ], pos = ( node [ 1 ][ \"x\" ], node [ 1 ][ \"y\" ]), type = \"node\" , data = node [ 1 ], ) for edge in network . edges (): self . updated_network . add_edge ( edge [ 0 ], edge [ 1 ], type = \"edge\" ) return self . updated_network else : raise AttributeDoesNotExistError ( f \"'graph' attribute does not exist yet \\ for OpenStreet type road netwwork!\" )","title":"get_network()"},{"location":"graph/#shift.graph.RoadNetworkFromPlace","text":"Bases: OpenStreetRoadNetwork Getting road network from a place address within bounding box. Attributes: Name Type Description place str string representing location max_dist float Distance to be used to create bounding box around a point dist_type str Type of region to be created around the point network_type str Type of network to be retrived from openstreet data Source code in shift\\graph.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class RoadNetworkFromPlace ( OpenStreetRoadNetwork ): \"\"\"Getting road network from a place address within bounding box. Attributes: place (str): string representing location max_dist (float): Distance to be used to create bounding box around a point dist_type (str): Type of region to be created around the point network_type (str): Type of network to be retrived from openstreet data \"\"\" def __init__ ( self , place : str , max_dist : float = 1000 , dist_type : str = \"bbox\" , network_type : str = \"drive\" , ) -> None : \"\"\"Constructor for `RoadNetworkFromPlace` class. Args: place (str): string representing location max_dist (float): Distance to be used to create bounding box around a point dist_type (str): Type of region to be created around the point network_type (str): Type of network to be retrived from openstreet data \"\"\" # e.g. Chennai, India self . place = place self . max_dist = max_dist self . dist_type = dist_type self . network_type = network_type def get_network ( self , node_append_str : Union [ str , None ] = None ) -> nx . Graph : \"\"\"Refer to base class for more details.\"\"\" self . graph = ox . graph . graph_from_address ( self . place , dist = self . max_dist , dist_type = self . dist_type , network_type = self . network_type , ) super () . get_network ( node_append_str )","title":"RoadNetworkFromPlace"},{"location":"graph/#shift.graph.RoadNetworkFromPlace.__init__","text":"Constructor for RoadNetworkFromPlace class. Parameters: Name Type Description Default place str string representing location required max_dist float Distance to be used to create bounding box around a point 1000 dist_type str Type of region to be created around the point 'bbox' network_type str Type of network to be retrived from openstreet data 'drive' Source code in shift\\graph.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def __init__ ( self , place : str , max_dist : float = 1000 , dist_type : str = \"bbox\" , network_type : str = \"drive\" , ) -> None : \"\"\"Constructor for `RoadNetworkFromPlace` class. Args: place (str): string representing location max_dist (float): Distance to be used to create bounding box around a point dist_type (str): Type of region to be created around the point network_type (str): Type of network to be retrived from openstreet data \"\"\" # e.g. Chennai, India self . place = place self . max_dist = max_dist self . dist_type = dist_type self . network_type = network_type","title":"__init__()"},{"location":"graph/#shift.graph.RoadNetworkFromPlace.get_network","text":"Refer to base class for more details. Source code in shift\\graph.py 174 175 176 177 178 179 180 181 182 def get_network ( self , node_append_str : Union [ str , None ] = None ) -> nx . Graph : \"\"\"Refer to base class for more details.\"\"\" self . graph = ox . graph . graph_from_address ( self . place , dist = self . max_dist , dist_type = self . dist_type , network_type = self . network_type , ) super () . get_network ( node_append_str )","title":"get_network()"},{"location":"graph/#shift.graph.RoadNetworkFromPoint","text":"Bases: OpenStreetRoadNetwork Getting road network from single point within bounding box. Attributes: Name Type Description point tuple (longitude, latitude) pair representing point location max_dist float Distance to be used to create bounding box around a point dist_type str Type of region to be created around the point network_type str Type of network to be retrived from openstreet data Source code in shift\\graph.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 class RoadNetworkFromPoint ( OpenStreetRoadNetwork ): \"\"\"Getting road network from single point within bounding box. Attributes: point (tuple): (longitude, latitude) pair representing point location max_dist (float): Distance to be used to create bounding box around a point dist_type (str): Type of region to be created around the point network_type (str): Type of network to be retrived from openstreet data \"\"\" def __init__ ( self , point : tuple , max_dist : float = 1000 , dist_type : str = \"bbox\" , network_type : str = \"drive\" , ) -> None : \"\"\"Constructor for `RoadNetworkFromPoint` class. Args: point (tuple): (longitude, latitude) pair representing point location max_dist (float): Distance to be used to create bounding box around a point dist_type (str): Type of region to be created around the point network_type (str): Type of network to be retrived from openstreet data \"\"\" # e.g. (13.242134, 80.275948) self . point = point self . max_dist = max_dist self . dist_type = dist_type self . network_type = network_type def get_network ( self , node_append_str : Union [ str , None ] = None ) -> nx . Graph : \"\"\"Refer to base class for more details.\"\"\" self . graph = ox . graph . graph_from_point ( self . point , dist = self . max_dist , dist_type = self . dist_type , network_type = self . network_type , ) super () . get_network ( node_append_str )","title":"RoadNetworkFromPoint"},{"location":"graph/#shift.graph.RoadNetworkFromPoint.__init__","text":"Constructor for RoadNetworkFromPoint class. Parameters: Name Type Description Default point tuple (longitude, latitude) pair representing point location required max_dist float Distance to be used to create bounding box around a point 1000 dist_type str Type of region to be created around the point 'bbox' network_type str Type of network to be retrived from openstreet data 'drive' Source code in shift\\graph.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def __init__ ( self , point : tuple , max_dist : float = 1000 , dist_type : str = \"bbox\" , network_type : str = \"drive\" , ) -> None : \"\"\"Constructor for `RoadNetworkFromPoint` class. Args: point (tuple): (longitude, latitude) pair representing point location max_dist (float): Distance to be used to create bounding box around a point dist_type (str): Type of region to be created around the point network_type (str): Type of network to be retrived from openstreet data \"\"\" # e.g. (13.242134, 80.275948) self . point = point self . max_dist = max_dist self . dist_type = dist_type self . network_type = network_type","title":"__init__()"},{"location":"graph/#shift.graph.RoadNetworkFromPoint.get_network","text":"Refer to base class for more details. Source code in shift\\graph.py 132 133 134 135 136 137 138 139 140 def get_network ( self , node_append_str : Union [ str , None ] = None ) -> nx . Graph : \"\"\"Refer to base class for more details.\"\"\" self . graph = ox . graph . graph_from_point ( self . point , dist = self . max_dist , dist_type = self . dist_type , network_type = self . network_type , ) super () . get_network ( node_append_str )","title":"get_network()"},{"location":"graph/#shift.graph.RoadNetworkFromPolygon","text":"Bases: OpenStreetRoadNetwork Getting road network from a given polygon. Attributes: Name Type Description polygon List [ list ] List of (lon, lat) pairs custom_filter str Valid osmnx type customer filter to be applied Source code in shift\\graph.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 class RoadNetworkFromPolygon ( OpenStreetRoadNetwork ): \"\"\"Getting road network from a given polygon. Attributes: polygon (List[list]): List of (lon, lat) pairs custom_filter (str): Valid osmnx type customer filter to be applied \"\"\" def __init__ ( self , polygon : List [ list ], custom_filter : str = '[\"highway\"]' ) -> None : \"\"\"Constructor for `RoadNetworkFromPolygon` class. Args: polygon (List[list]): List of (lon, lat) pairs custom_filter (str): Valid osmnx type customer filter to be applied \"\"\" # e.g. [[13.242134, 80.275948]] self . polygon = polygon self . custom_filter = custom_filter def get_network ( self , node_append_str : Union [ str , None ] = None ) -> nx . Graph : \"\"\"Refer to base class for more details.\"\"\" polygon = shapely . geometry . Polygon ( self . polygon ) self . graph = ox . graph . graph_from_polygon ( polygon , custom_filter = self . custom_filter ) super () . get_network ( node_append_str )","title":"RoadNetworkFromPolygon"},{"location":"graph/#shift.graph.RoadNetworkFromPolygon.__init__","text":"Constructor for RoadNetworkFromPolygon class. Parameters: Name Type Description Default polygon List [ list ] List of (lon, lat) pairs required custom_filter str Valid osmnx type customer filter to be applied '[\"highway\"]' Source code in shift\\graph.py 193 194 195 196 197 198 199 200 201 202 203 204 205 def __init__ ( self , polygon : List [ list ], custom_filter : str = '[\"highway\"]' ) -> None : \"\"\"Constructor for `RoadNetworkFromPolygon` class. Args: polygon (List[list]): List of (lon, lat) pairs custom_filter (str): Valid osmnx type customer filter to be applied \"\"\" # e.g. [[13.242134, 80.275948]] self . polygon = polygon self . custom_filter = custom_filter","title":"__init__()"},{"location":"graph/#shift.graph.RoadNetworkFromPolygon.get_network","text":"Refer to base class for more details. Source code in shift\\graph.py 207 208 209 210 211 212 213 214 def get_network ( self , node_append_str : Union [ str , None ] = None ) -> nx . Graph : \"\"\"Refer to base class for more details.\"\"\" polygon = shapely . geometry . Polygon ( self . polygon ) self . graph = ox . graph . graph_from_polygon ( polygon , custom_filter = self . custom_filter ) super () . get_network ( node_append_str )","title":"get_network()"},{"location":"how-to-guides/","text":"","title":"How to Guides"},{"location":"line_section/","text":"This module contains classes for representing different parts of distribution line segment. Cable Bases: Wire Interface for cable data. Source code in shift\\line_section.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 class Cable ( Wire ): \"\"\"Interface for cable data.\"\"\" @property def inslayer ( self ) -> float : \"\"\"Thickness of insulation property of a cable\"\"\" return self . _inslayer @inslayer . setter def inslayer ( self , diameter : float ) -> None : \"\"\"Insulation thickness setter method for a cable\"\"\" if diameter < 0 : raise NegativeDiameterError ( diameter ) self . _inslayer = diameter @property def diains ( self ) -> float : \"\"\"Diameter over insulation property of a cable\"\"\" return self . _diains @diains . setter def diains ( self , diameter : float ) -> None : \"\"\"Diameter over insulation setter method for a cable\"\"\" if diameter < 0 : raise NegativeDiameterError ( diameter ) self . _diains = diameter @property def diacable ( self ) -> float : \"\"\"Diameter of cable property of a cable\"\"\" return self . _diacable @diacable . setter def diacable ( self , diameter : float ) -> None : \"\"\"Diameter of cable setter method for a cable\"\"\" if diameter < 0 : raise NegativeDiameterError ( diameter ) self . _diacable = diameter @property def rstrand ( self ) -> float : \"\"\"Resistance of neutral strand property for a cable\"\"\" return self . _rstrand @rstrand . setter def rstrand ( self , r : float ) -> None : \"\"\"Resistance of neutral strand property setter method for a wire\"\"\" if r < 0 : raise NegativeResistanceError ( r ) self . _rstrand = r @property def gmrstrand ( self ) -> float : \"\"\"gmrac of neutral strand property of a wire\"\"\" return self . _gmrstrand @gmrstrand . setter def gmrstrand ( self , gmr : float ) -> None : \"\"\"gmrac of neutral strand setter method for a wire\"\"\" if gmr < 0 : raise NegativeGMRError ( gmr ) self . _gmrstrand = gmr @property def diastrand ( self ) -> float : \"\"\"Diameter of neutral strand property of a cable\"\"\" return self . _diastrand @diastrand . setter def diastrand ( self , diameter : float ) -> None : \"\"\"Diameter of neutral strand setter method for a cable\"\"\" if diameter < 0 : raise NegativeDiameterError ( diameter ) self . _diastrand = diameter @property def k ( self ) -> int : \"\"\"Number of neutral strands property of a cable\"\"\" return self . _k @k . setter def k ( self , num_of_strand : int ) -> None : \"\"\"Number of neutral strands setter method for a cable\"\"\" if num_of_strand < 0 : raise NegativeStrandsError ( num_of_strand ) self . _k = num_of_strand def __eq__ ( self , other ): if ( super () . __eq__ ( other ) and self . inslayer == other . inslayer and self . diains == other . diains and self . diacable == other . diacable and self . rstrand == other . rstrand and self . gmrstrand == other . gmrstrand and self . diastrand == other . diastrand and self . k == other . k ): return True else : False def __repr__ ( self ): repr = super () . __repr__ () return ( f \" { self . __class__ . __name__ } ( { repr . split ( '(' )[ 1 ] . split ( ')' )[ 0 ] } , Insulation thickness = { self . _inslayer } , Diameter over insulation = { self . _diains } \" + f \" Diameter of cable = { self . _diacable } , Neutral strand resistance (ohm per) = { self . _rstrand } , Neutral strand GMR = { self . _gmrstrand } \" + f \"Neutral strand diameter = { self . _diastrand } , Number of neutral strands = { self . _k } )\" ) diacable () property writable Diameter of cable property of a cable Source code in shift\\line_section.py 194 195 196 197 @property def diacable ( self ) -> float : \"\"\"Diameter of cable property of a cable\"\"\" return self . _diacable diains () property writable Diameter over insulation property of a cable Source code in shift\\line_section.py 182 183 184 185 @property def diains ( self ) -> float : \"\"\"Diameter over insulation property of a cable\"\"\" return self . _diains diastrand () property writable Diameter of neutral strand property of a cable Source code in shift\\line_section.py 230 231 232 233 @property def diastrand ( self ) -> float : \"\"\"Diameter of neutral strand property of a cable\"\"\" return self . _diastrand gmrstrand () property writable gmrac of neutral strand property of a wire Source code in shift\\line_section.py 218 219 220 221 @property def gmrstrand ( self ) -> float : \"\"\"gmrac of neutral strand property of a wire\"\"\" return self . _gmrstrand inslayer () property writable Thickness of insulation property of a cable Source code in shift\\line_section.py 170 171 172 173 @property def inslayer ( self ) -> float : \"\"\"Thickness of insulation property of a cable\"\"\" return self . _inslayer k () property writable Number of neutral strands property of a cable Source code in shift\\line_section.py 242 243 244 245 @property def k ( self ) -> int : \"\"\"Number of neutral strands property of a cable\"\"\" return self . _k rstrand () property writable Resistance of neutral strand property for a cable Source code in shift\\line_section.py 206 207 208 209 @property def rstrand ( self ) -> float : \"\"\"Resistance of neutral strand property for a cable\"\"\" return self . _rstrand GeometryBasedLine Bases: Line Interface for geometry based line. Source code in shift\\line_section.py 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 class GeometryBasedLine ( Line ): \"\"\"Interface for geometry based line.\"\"\" @property def geometry ( self ) -> LineGeometry : \"\"\"Geometry of the line element\"\"\" return self . _geometry @geometry . setter def geometry ( self , geometry : LineGeometry ) -> None : \"\"\"Geometry setter method for the line element\"\"\" self . _geometry = geometry def __repr__ ( self ): return ( f \" { self . __class__ . __name__ } (Name = { self . _name } , FromNode = { self . _fromnode } , ToNode = { self . _tonode } , Length = { self . _length } \" + f \"NumPhase = { self . _num_phase } , Length unit = { self . _length_unit } , Geometry = { self . _geometry } )\" ) geometry () property writable Geometry of the line element Source code in shift\\line_section.py 703 704 705 706 @property def geometry ( self ) -> LineGeometry : \"\"\"Geometry of the line element\"\"\" return self . _geometry HorizontalSinglePhaseConfiguration Bases: LineGeometryConfiguration Concrete implementation for single phase horizontal configuration. Attributes: Name Type Description unit str Unit of height height_of_conductor float Height of conductor from ground Source code in shift\\line_section.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 class HorizontalSinglePhaseConfiguration ( LineGeometryConfiguration ): \"\"\"Concrete implementation for single phase horizontal configuration. Attributes: unit (str): Unit of height height_of_conductor (float): Height of conductor from ground \"\"\" def __init__ ( self , height_of_conductor : float , unit : str ) -> None : \"\"\"Constructor class for `HorizontalSinglePhaseConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor def get_x_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ 0 ] def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor ] __init__ ( height_of_conductor , unit ) Constructor class for HorizontalSinglePhaseConfiguration class. Parameters: Name Type Description Default height_of_conductor float Height of conductor from ground required unit str Unit of height required Source code in shift\\line_section.py 332 333 334 335 336 337 338 339 340 def __init__ ( self , height_of_conductor : float , unit : str ) -> None : \"\"\"Constructor class for `HorizontalSinglePhaseConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor get_h_array () Refer to base class for details. Source code in shift\\line_section.py 346 347 348 def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor ] get_x_array () Refer to base class for details. Source code in shift\\line_section.py 342 343 344 def get_x_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ 0 ] HorizontalSinglePhaseNeutralConfiguration Bases: LineGeometryConfiguration Concrete implementation for single phase horizontal configuration with neutral wire. Attributes: Name Type Description unit str Unit of height height_of_conductor float Height of conductor from ground separation_between_conductor float Distance between phase and neutral wire Source code in shift\\line_section.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 class HorizontalSinglePhaseNeutralConfiguration ( LineGeometryConfiguration ): \"\"\"Concrete implementation for single phase horizontal configuration with neutral wire. Attributes: unit (str): Unit of height height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire \"\"\" def __init__ ( self , height_of_conductor : float , separation_between_conductor : float , unit : str , ) -> None : \"\"\"Constructor for `HorizontalSinglePhaseNeutralConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor self . separation_between_conductor = separation_between_conductor def get_x_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ - self . separation_between_conductor / 2 , self . separation_between_conductor / 2 , ] def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor , self . height_of_conductor ] __init__ ( height_of_conductor , separation_between_conductor , unit ) Constructor for HorizontalSinglePhaseNeutralConfiguration class. Parameters: Name Type Description Default height_of_conductor float Height of conductor from ground required separation_between_conductor float Distance between phase and neutral wire required unit str Unit of height required Source code in shift\\line_section.py 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 def __init__ ( self , height_of_conductor : float , separation_between_conductor : float , unit : str , ) -> None : \"\"\"Constructor for `HorizontalSinglePhaseNeutralConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor self . separation_between_conductor = separation_between_conductor get_h_array () Refer to base class for details. Source code in shift\\line_section.py 385 386 387 def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor , self . height_of_conductor ] get_x_array () Refer to base class for details. Source code in shift\\line_section.py 378 379 380 381 382 383 def get_x_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ - self . separation_between_conductor / 2 , self . separation_between_conductor / 2 , ] HorizontalThreePhaseConfiguration Bases: LineGeometryConfiguration Concrete implementation for three phase horizontal configuration. Attributes: Name Type Description unit str Unit of height height_of_conductor float Height of conductor from ground separation_between_conductor float Distance between phase and neutral wire Source code in shift\\line_section.py 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 class HorizontalThreePhaseConfiguration ( LineGeometryConfiguration ): \"\"\"Concrete implementation for three phase horizontal configuration. Attributes: unit (str): Unit of height height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire \"\"\" def __init__ ( self , height_of_conductor , separation_between_conductor , unit ): \"\"\"Constructor for `HorizontalThreePhaseConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor self . separation_between_conductor = separation_between_conductor def get_x_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ - self . separation_between_conductor , 0 , self . separation_between_conductor , ] def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor , self . height_of_conductor , self . height_of_conductor , ] __init__ ( height_of_conductor , separation_between_conductor , unit ) Constructor for HorizontalThreePhaseConfiguration class. Parameters: Name Type Description Default height_of_conductor float Height of conductor from ground required separation_between_conductor float Distance between phase and neutral wire required unit str Unit of height required Source code in shift\\line_section.py 399 400 401 402 403 404 405 406 407 408 409 def __init__ ( self , height_of_conductor , separation_between_conductor , unit ): \"\"\"Constructor for `HorizontalThreePhaseConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor self . separation_between_conductor = separation_between_conductor get_h_array () Refer to base class for details. Source code in shift\\line_section.py 419 420 421 422 423 424 425 def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor , self . height_of_conductor , self . height_of_conductor , ] get_x_array () Refer to base class for details. Source code in shift\\line_section.py 411 412 413 414 415 416 417 def get_x_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ - self . separation_between_conductor , 0 , self . separation_between_conductor , ] HorizontalThreePhaseNeutralConfiguration Bases: LineGeometryConfiguration Concrete implementation for three phase horizontal configuration with neutral. Attributes: Name Type Description unit str Unit of height height_of_conductor float Height of conductor from ground separation_between_conductor float Distance between phase and neutral wire height_of_neutral_conductor float Height of neutral conductor Source code in shift\\line_section.py 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 class HorizontalThreePhaseNeutralConfiguration ( LineGeometryConfiguration ): \"\"\"Concrete implementation for three phase horizontal configuration with neutral. Attributes: unit (str): Unit of height height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire height_of_neutral_conductor (float): Height of neutral conductor \"\"\" def __init__ ( self , height_of_conductor : float , separation_between_conductor : float , height_of_neutral_conductor : float , unit : str , ) -> None : \"\"\"Constructor for `HorizontalThreePhaseNeutralConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire height_of_neutral_conductor (float): Height of neutral conductor unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor self . separation_between_conductor = separation_between_conductor self . height_of_neutral_conductor = height_of_neutral_conductor def get_x_array ( self ): \"\"\"Refer to base class for details.\"\"\" return [ - self . separation_between_conductor , 0 , self . separation_between_conductor , 0 , ] def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor , self . height_of_conductor , self . height_of_conductor , self . height_of_neutral_conductor , ] __init__ ( height_of_conductor , separation_between_conductor , height_of_neutral_conductor , unit ) Constructor for HorizontalThreePhaseNeutralConfiguration class. Parameters: Name Type Description Default height_of_conductor float Height of conductor from ground required separation_between_conductor float Distance between phase and neutral wire required height_of_neutral_conductor float Height of neutral conductor required unit str Unit of height required Source code in shift\\line_section.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 def __init__ ( self , height_of_conductor : float , separation_between_conductor : float , height_of_neutral_conductor : float , unit : str , ) -> None : \"\"\"Constructor for `HorizontalThreePhaseNeutralConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire height_of_neutral_conductor (float): Height of neutral conductor unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor self . separation_between_conductor = separation_between_conductor self . height_of_neutral_conductor = height_of_neutral_conductor get_h_array () Refer to base class for details. Source code in shift\\line_section.py 468 469 470 471 472 473 474 475 def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor , self . height_of_conductor , self . height_of_conductor , self . height_of_neutral_conductor , ] get_x_array () Refer to base class for details. Source code in shift\\line_section.py 459 460 461 462 463 464 465 466 def get_x_array ( self ): \"\"\"Refer to base class for details.\"\"\" return [ - self . separation_between_conductor , 0 , self . separation_between_conductor , 0 , ] Line Bases: ABC Interface for line section representation Source code in shift\\line_section.py 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 class Line ( ABC ): \"\"\"Interface for line section representation\"\"\" @property def name ( self ) -> str : \"\"\"Name property of a line element\"\"\" return self . _name @name . setter def name ( self , name : str ) -> None : \"\"\"Name setter method for a line element\"\"\" self . _name = name @property def fromnode ( self ) -> str : \"\"\"From node property of a line element\"\"\" return self . _fromnode @fromnode . setter def fromnode ( self , node : str ): \"\"\"From node setter method for a line element\"\"\" self . _fromnode = node @property def tonode ( self ) -> str : \"\"\"To node property of a line element\"\"\" return self . _tonode @tonode . setter def tonode ( self , node : str ): \"\"\"To node setter method for a line element\"\"\" self . _tonode = node @property def length ( self ) -> float : \"\"\"Length property of a line element\"\"\" return self . _length @length . setter def length ( self , length : float ): \"\"\"Length setter method for a line element\"\"\" if length < 0 : raise NegativeLineLengthError ( length ) self . _length = length @property def length_unit ( self ) -> str : \"\"\"Length unit property of a line element\"\"\" return self . _length_unit @length_unit . setter def length_unit ( self , unit : str ): \"\"\"Length setter method for a line element\"\"\" if unit not in VALID_LENGTH_UNITS : raise InvalidLengthUnitError ( unit ) self . _length_unit = unit @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property of the line element\"\"\" return self . _num_phase @num_phase . setter def num_phase ( self , num_phase : NumPhase ) -> None : \"\"\"Number of phase setter method for the line element\"\"\" self . _num_phase = num_phase @property def fromnode_phase ( self ) -> Phase : \"\"\"Phase property of the line element\"\"\" return self . _fromnode_phase @fromnode_phase . setter def fromnode_phase ( self , phase : Phase ) -> None : \"\"\"Phase setter method for the line element\"\"\" self . _fromnode_phase = phase @property def tonode_phase ( self ) -> Phase : \"\"\"Phase property of the line element\"\"\" return self . _tonode_phase @tonode_phase . setter def tonode_phase ( self , phase : Phase ) -> None : \"\"\"Phase setter method for the line element\"\"\" self . _tonode_phase = phase fromnode () property writable From node property of a line element Source code in shift\\line_section.py 625 626 627 628 @property def fromnode ( self ) -> str : \"\"\"From node property of a line element\"\"\" return self . _fromnode fromnode_phase () property writable Phase property of the line element Source code in shift\\line_section.py 679 680 681 682 @property def fromnode_phase ( self ) -> Phase : \"\"\"Phase property of the line element\"\"\" return self . _fromnode_phase length () property writable Length property of a line element Source code in shift\\line_section.py 645 646 647 648 @property def length ( self ) -> float : \"\"\"Length property of a line element\"\"\" return self . _length length_unit () property writable Length unit property of a line element Source code in shift\\line_section.py 657 658 659 660 @property def length_unit ( self ) -> str : \"\"\"Length unit property of a line element\"\"\" return self . _length_unit name () property writable Name property of a line element Source code in shift\\line_section.py 615 616 617 618 @property def name ( self ) -> str : \"\"\"Name property of a line element\"\"\" return self . _name num_phase () property writable Number of phase property of the line element Source code in shift\\line_section.py 669 670 671 672 @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property of the line element\"\"\" return self . _num_phase tonode () property writable To node property of a line element Source code in shift\\line_section.py 635 636 637 638 @property def tonode ( self ) -> str : \"\"\"To node property of a line element\"\"\" return self . _tonode tonode_phase () property writable Phase property of the line element Source code in shift\\line_section.py 689 690 691 692 @property def tonode_phase ( self ) -> Phase : \"\"\"Phase property of the line element\"\"\" return self . _tonode_phase LineGeometry Bases: ABC Interface for line geometry. Source code in shift\\line_section.py 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 class LineGeometry ( ABC ): \"\"\"Interface for line geometry.\"\"\" @property def name ( self ) -> str : \"\"\"Name property of a line geometry\"\"\" return self . _name @name . setter def name ( self , name : str ) -> None : \"\"\"Name setter method for a line geometry\"\"\" self . _name = name @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property of the line geometry\"\"\" return self . _num_phase @num_phase . setter def num_phase ( self , num_phase : NumPhase ) -> None : \"\"\"Number of phase setter method for a line geometry\"\"\" self . _num_phase = num_phase @property def num_conds ( self ) -> int : \"\"\"Number of conductors property of the line geometry\"\"\" return self . _num_conds @num_conds . setter def num_conds ( self , num_of_conds : int ) -> None : \"\"\"Number of conductors setter method for a line geometry\"\"\" self . _num_conds = num_of_conds @property def configuration ( self ) -> LineGeometryConfiguration : \"\"\"Phase wire property of a line geometry\"\"\" return self . _configuration @configuration . setter def configuration ( self , configuration : LineGeometryConfiguration ) -> None : \"\"\"Phase wire setter method for a line geometry\"\"\" self . _configuration = configuration def __eq__ ( self , other ): if ( self . num_phase == other . num_phase and self . num_conds == other . num_conds and self . configuration == other . configuration ): return True else : False def __repr__ ( self ): return f \" { self . __class__ . __name__ } (Name = { self . _name } , NumPhase = { self . _num_phase } , \\ Number of conductors = { self . _num_conds } , Configuration = { self . _configuration } )\" configuration () property writable Phase wire property of a line geometry Source code in shift\\line_section.py 511 512 513 514 @property def configuration ( self ) -> LineGeometryConfiguration : \"\"\"Phase wire property of a line geometry\"\"\" return self . _configuration name () property writable Name property of a line geometry Source code in shift\\line_section.py 481 482 483 484 @property def name ( self ) -> str : \"\"\"Name property of a line geometry\"\"\" return self . _name num_conds () property writable Number of conductors property of the line geometry Source code in shift\\line_section.py 501 502 503 504 @property def num_conds ( self ) -> int : \"\"\"Number of conductors property of the line geometry\"\"\" return self . _num_conds num_phase () property writable Number of phase property of the line geometry Source code in shift\\line_section.py 491 492 493 494 @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property of the line geometry\"\"\" return self . _num_phase LineGeometryConfiguration Bases: ABC Interface for line geometry configuration data. Source code in shift\\line_section.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 class LineGeometryConfiguration ( ABC ): \"\"\"Interface for line geometry configuration data.\"\"\" @property def unit ( self ) -> str : \"\"\"Unit property for configuration\"\"\" return self . _unit @unit . setter def unit ( self , unit_ : str ) -> None : \"\"\"Name setter method for a line geometry\"\"\" if unit_ not in VALID_LENGTH_UNITS : raise InvalidLengthUnitError ( unit_ ) self . _unit = unit_ @abstractmethod def get_x_array ( self ) -> list : \"\"\"Abstract method for getting x array to model line geometry. Returns: list: e.g [-0.4, 0, 0.4] \"\"\" pass @abstractmethod def get_h_array ( self ) -> list : \"\"\"Abstract method for getting h array to model line geometry. Returns: list: e.g. [9.0, 9.0, 9.0] \"\"\" pass def __eq__ ( self , other ): if ( self . unit == other . unit and self . get_x_array () == other . get_x_array () and self . get_h_array () == other . get_h_array () ): return True else : return False get_h_array () abstractmethod Abstract method for getting h array to model line geometry. Returns: Name Type Description list list e.g. [9.0, 9.0, 9.0] Source code in shift\\line_section.py 303 304 305 306 307 308 309 310 @abstractmethod def get_h_array ( self ) -> list : \"\"\"Abstract method for getting h array to model line geometry. Returns: list: e.g. [9.0, 9.0, 9.0] \"\"\" pass get_x_array () abstractmethod Abstract method for getting x array to model line geometry. Returns: Name Type Description list list e.g [-0.4, 0, 0.4] Source code in shift\\line_section.py 294 295 296 297 298 299 300 301 @abstractmethod def get_x_array ( self ) -> list : \"\"\"Abstract method for getting x array to model line geometry. Returns: list: e.g [-0.4, 0, 0.4] \"\"\" pass unit () property writable Unit property for configuration Source code in shift\\line_section.py 282 283 284 285 @property def unit ( self ) -> str : \"\"\"Unit property for configuration\"\"\" return self . _unit OverheadLineGeometry Bases: LineGeometry Interface for overhead line geometry. Source code in shift\\line_section.py 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 class OverheadLineGeometry ( LineGeometry ): \"\"\"Interface for overhead line geometry.\"\"\" @property def phase_wire ( self ) -> Wire : \"\"\"Phase wire property of a line geometry\"\"\" return self . _phase_wire @phase_wire . setter def phase_wire ( self , wire : Wire ) -> None : \"\"\"Phase wire setter method for a line geometry\"\"\" self . _phase_wire = wire def __eq__ ( self , other ): if super () . __eq__ ( other ) and self . phase_wire == other . phase_wire : return True else : False def __repr__ ( self ): repr = super () . __repr__ () return f \" { self . __class__ . __name__ } ( { repr . split ( '(' )[ 1 ] . split ( ')' )[ 0 ] } , Phase wire = { self . _phase_wire } )\" phase_wire () property writable Phase wire property of a line geometry Source code in shift\\line_section.py 540 541 542 543 @property def phase_wire ( self ) -> Wire : \"\"\"Phase wire property of a line geometry\"\"\" return self . _phase_wire OverheadLinewithNeutralGeometry Bases: OverheadLineGeometry Interface for overhead line with neutral geometry. Source code in shift\\line_section.py 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 class OverheadLinewithNeutralGeometry ( OverheadLineGeometry ): \"\"\"Interface for overhead line with neutral geometry.\"\"\" @property def neutral_wire ( self ) -> str : \"\"\"Neutral wire property of a line geometry\"\"\" return self . _neutral_wire @neutral_wire . setter def neutral_wire ( self , wire : Wire ) -> None : \"\"\"Neutral wire setter method for a line geometry\"\"\" self . _neutral_wire = wire def __eq__ ( self , other ): if super () . __eq__ ( other ) and self . neutral_wire == other . neutral_wire : return True else : False def __repr__ ( self ): repr = super () . __repr__ () return f \" { self . __class__ . __name__ } ( { repr . split ( '(' )[ 1 ] . split ( ')' )[ 0 ] } , Neutral wire = { self . _neutral_wire } )\" neutral_wire () property writable Neutral wire property of a line geometry Source code in shift\\line_section.py 565 566 567 568 @property def neutral_wire ( self ) -> str : \"\"\"Neutral wire property of a line geometry\"\"\" return self . _neutral_wire UndergroundLineGeometry Bases: LineGeometry Interface for underground line geometry Source code in shift\\line_section.py 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 class UndergroundLineGeometry ( LineGeometry ): \"\"\"Interface for underground line geometry\"\"\" @property def phase_cable ( self ) -> Cable : \"\"\"Phase cable property of a line geometry\"\"\" return self . _phase_cable @phase_cable . setter def phase_cable ( self , cable : Cable ) -> None : \"\"\"Phase cable setter method for a line geometry\"\"\" self . _phase_cable = cable def __eq__ ( self , other ): if super () . __eq__ ( other ) and self . phase_cable == other . phase_cable : return True else : False def __repr__ ( self ): repr = super () . __repr__ () return f \" { self . __class__ . __name__ } ( { repr . split ( '(' )[ 1 ] . split ( ')' )[ 0 ] } , Phase cable = { self . _phase_cable } )\" phase_cable () property writable Phase cable property of a line geometry Source code in shift\\line_section.py 590 591 592 593 @property def phase_cable ( self ) -> Cable : \"\"\"Phase cable property of a line geometry\"\"\" return self . _phase_cable Wire Class for storing wire data. Source code in shift\\line_section.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class Wire : \"\"\"Class for storing wire data.\"\"\" @property def name ( self ) -> str : \"\"\"Name property of a wire\"\"\" return self . _name @name . setter def name ( self , name : str ) -> None : \"\"\"Name setter method of a wire\"\"\" self . _name = name @property def runits ( self ) -> str : \"\"\"Unit for reistance property of a wire\"\"\" return self . _runits @runits . setter def runits ( self , unit : str ) -> None : \"\"\"runits setter method for a wire\"\"\" if unit not in VALID_LENGTH_UNITS : raise InvalidLengthUnitError ( unit ) self . _runits = unit @property def gmrunits ( self ) -> str : \"\"\"gmrunits for diamater property for a wire\"\"\" return self . _gmrunits @gmrunits . setter def gmrunits ( self , unit : str ) -> None : \"\"\"gmrunits setter method for a wire\"\"\" if unit not in VALID_LENGTH_UNITS : raise InvalidLengthUnitError ( unit ) self . _gmrunits = unit @property def radunits ( self ) -> str : \"\"\"Units for diamater property for a wire\"\"\" return self . _radunits @radunits . setter def radunits ( self , unit : str ) -> None : \"\"\"radunits setter method for a wire\"\"\" if unit not in VALID_LENGTH_UNITS : raise InvalidLengthUnitError ( unit ) self . _radunits = unit @property def rac ( self ) -> float : \"\"\"AC resistance property for a wire\"\"\" return self . _rac @rac . setter def rac ( self , r : float ) -> None : \"\"\"AC resistance property setter method for a wire\"\"\" if r < 0 : raise NegativeResistanceError ( r ) self . _rac = r @property def diam ( self ) -> float : \"\"\"Diameter property of a wire\"\"\" return self . _diam @diam . setter def diam ( self , diameter : float ) -> None : \"\"\"Diameter setter method for a wire\"\"\" if diameter < 0 : raise NegativeDiameterError ( diameter ) self . _diam = diameter @property def gmrac ( self ) -> float : \"\"\"gmrac property of a wire\"\"\" return self . _gmrac @gmrac . setter def gmrac ( self , gmr : float ) -> None : \"\"\"gmrac setter method for a wire\"\"\" if gmr < 0 : raise NegativeGMRError ( gmr ) self . _gmrac = gmr @property def normamps ( self ) -> float : \"\"\"Normal ampacity property of a wire\"\"\" return self . _normamps @normamps . setter def normamps ( self , current : float ) -> None : \"\"\"AC resistance property setter method for a wire\"\"\" if current < 0 : raise NegativeAmpacityError ( current ) self . _normamps = current def __eq__ ( self , other ): if ( self . name == other . name and self . runits == other . runits and self . gmrunits == other . gmrunits and self . radunits == other . radunits and self . rac == other . rac and self . diam == other . diam and self . gmrac == other . gmrac and self . normamps == other . normamps ): return True else : False def __repr__ ( self ): return ( f \" { self . __class__ . __name__ } (Name = { self . _name } , Resistance unit = { self . _runits } , GMR unit = { self . _gmrunits } , Radius unit = { self . _radunits } \" + f \", AC resistance (ohm per) = { self . _rac } , Diameter = { self . _diam } , GMR AC = { self . _gmrac } , Ampacity = { self . _normamps } )\" ) diam () property writable Diameter property of a wire Source code in shift\\line_section.py 108 109 110 111 @property def diam ( self ) -> float : \"\"\"Diameter property of a wire\"\"\" return self . _diam gmrac () property writable gmrac property of a wire Source code in shift\\line_section.py 120 121 122 123 @property def gmrac ( self ) -> float : \"\"\"gmrac property of a wire\"\"\" return self . _gmrac gmrunits () property writable gmrunits for diamater property for a wire Source code in shift\\line_section.py 72 73 74 75 @property def gmrunits ( self ) -> str : \"\"\"gmrunits for diamater property for a wire\"\"\" return self . _gmrunits name () property writable Name property of a wire Source code in shift\\line_section.py 50 51 52 53 @property def name ( self ) -> str : \"\"\"Name property of a wire\"\"\" return self . _name normamps () property writable Normal ampacity property of a wire Source code in shift\\line_section.py 132 133 134 135 @property def normamps ( self ) -> float : \"\"\"Normal ampacity property of a wire\"\"\" return self . _normamps rac () property writable AC resistance property for a wire Source code in shift\\line_section.py 96 97 98 99 @property def rac ( self ) -> float : \"\"\"AC resistance property for a wire\"\"\" return self . _rac radunits () property writable Units for diamater property for a wire Source code in shift\\line_section.py 84 85 86 87 @property def radunits ( self ) -> str : \"\"\"Units for diamater property for a wire\"\"\" return self . _radunits runits () property writable Unit for reistance property of a wire Source code in shift\\line_section.py 60 61 62 63 @property def runits ( self ) -> str : \"\"\"Unit for reistance property of a wire\"\"\" return self . _runits","title":"line_section"},{"location":"line_section/#shift.line_section.Cable","text":"Bases: Wire Interface for cable data. Source code in shift\\line_section.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 class Cable ( Wire ): \"\"\"Interface for cable data.\"\"\" @property def inslayer ( self ) -> float : \"\"\"Thickness of insulation property of a cable\"\"\" return self . _inslayer @inslayer . setter def inslayer ( self , diameter : float ) -> None : \"\"\"Insulation thickness setter method for a cable\"\"\" if diameter < 0 : raise NegativeDiameterError ( diameter ) self . _inslayer = diameter @property def diains ( self ) -> float : \"\"\"Diameter over insulation property of a cable\"\"\" return self . _diains @diains . setter def diains ( self , diameter : float ) -> None : \"\"\"Diameter over insulation setter method for a cable\"\"\" if diameter < 0 : raise NegativeDiameterError ( diameter ) self . _diains = diameter @property def diacable ( self ) -> float : \"\"\"Diameter of cable property of a cable\"\"\" return self . _diacable @diacable . setter def diacable ( self , diameter : float ) -> None : \"\"\"Diameter of cable setter method for a cable\"\"\" if diameter < 0 : raise NegativeDiameterError ( diameter ) self . _diacable = diameter @property def rstrand ( self ) -> float : \"\"\"Resistance of neutral strand property for a cable\"\"\" return self . _rstrand @rstrand . setter def rstrand ( self , r : float ) -> None : \"\"\"Resistance of neutral strand property setter method for a wire\"\"\" if r < 0 : raise NegativeResistanceError ( r ) self . _rstrand = r @property def gmrstrand ( self ) -> float : \"\"\"gmrac of neutral strand property of a wire\"\"\" return self . _gmrstrand @gmrstrand . setter def gmrstrand ( self , gmr : float ) -> None : \"\"\"gmrac of neutral strand setter method for a wire\"\"\" if gmr < 0 : raise NegativeGMRError ( gmr ) self . _gmrstrand = gmr @property def diastrand ( self ) -> float : \"\"\"Diameter of neutral strand property of a cable\"\"\" return self . _diastrand @diastrand . setter def diastrand ( self , diameter : float ) -> None : \"\"\"Diameter of neutral strand setter method for a cable\"\"\" if diameter < 0 : raise NegativeDiameterError ( diameter ) self . _diastrand = diameter @property def k ( self ) -> int : \"\"\"Number of neutral strands property of a cable\"\"\" return self . _k @k . setter def k ( self , num_of_strand : int ) -> None : \"\"\"Number of neutral strands setter method for a cable\"\"\" if num_of_strand < 0 : raise NegativeStrandsError ( num_of_strand ) self . _k = num_of_strand def __eq__ ( self , other ): if ( super () . __eq__ ( other ) and self . inslayer == other . inslayer and self . diains == other . diains and self . diacable == other . diacable and self . rstrand == other . rstrand and self . gmrstrand == other . gmrstrand and self . diastrand == other . diastrand and self . k == other . k ): return True else : False def __repr__ ( self ): repr = super () . __repr__ () return ( f \" { self . __class__ . __name__ } ( { repr . split ( '(' )[ 1 ] . split ( ')' )[ 0 ] } , Insulation thickness = { self . _inslayer } , Diameter over insulation = { self . _diains } \" + f \" Diameter of cable = { self . _diacable } , Neutral strand resistance (ohm per) = { self . _rstrand } , Neutral strand GMR = { self . _gmrstrand } \" + f \"Neutral strand diameter = { self . _diastrand } , Number of neutral strands = { self . _k } )\" )","title":"Cable"},{"location":"line_section/#shift.line_section.Cable.diacable","text":"Diameter of cable property of a cable Source code in shift\\line_section.py 194 195 196 197 @property def diacable ( self ) -> float : \"\"\"Diameter of cable property of a cable\"\"\" return self . _diacable","title":"diacable()"},{"location":"line_section/#shift.line_section.Cable.diains","text":"Diameter over insulation property of a cable Source code in shift\\line_section.py 182 183 184 185 @property def diains ( self ) -> float : \"\"\"Diameter over insulation property of a cable\"\"\" return self . _diains","title":"diains()"},{"location":"line_section/#shift.line_section.Cable.diastrand","text":"Diameter of neutral strand property of a cable Source code in shift\\line_section.py 230 231 232 233 @property def diastrand ( self ) -> float : \"\"\"Diameter of neutral strand property of a cable\"\"\" return self . _diastrand","title":"diastrand()"},{"location":"line_section/#shift.line_section.Cable.gmrstrand","text":"gmrac of neutral strand property of a wire Source code in shift\\line_section.py 218 219 220 221 @property def gmrstrand ( self ) -> float : \"\"\"gmrac of neutral strand property of a wire\"\"\" return self . _gmrstrand","title":"gmrstrand()"},{"location":"line_section/#shift.line_section.Cable.inslayer","text":"Thickness of insulation property of a cable Source code in shift\\line_section.py 170 171 172 173 @property def inslayer ( self ) -> float : \"\"\"Thickness of insulation property of a cable\"\"\" return self . _inslayer","title":"inslayer()"},{"location":"line_section/#shift.line_section.Cable.k","text":"Number of neutral strands property of a cable Source code in shift\\line_section.py 242 243 244 245 @property def k ( self ) -> int : \"\"\"Number of neutral strands property of a cable\"\"\" return self . _k","title":"k()"},{"location":"line_section/#shift.line_section.Cable.rstrand","text":"Resistance of neutral strand property for a cable Source code in shift\\line_section.py 206 207 208 209 @property def rstrand ( self ) -> float : \"\"\"Resistance of neutral strand property for a cable\"\"\" return self . _rstrand","title":"rstrand()"},{"location":"line_section/#shift.line_section.GeometryBasedLine","text":"Bases: Line Interface for geometry based line. Source code in shift\\line_section.py 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 class GeometryBasedLine ( Line ): \"\"\"Interface for geometry based line.\"\"\" @property def geometry ( self ) -> LineGeometry : \"\"\"Geometry of the line element\"\"\" return self . _geometry @geometry . setter def geometry ( self , geometry : LineGeometry ) -> None : \"\"\"Geometry setter method for the line element\"\"\" self . _geometry = geometry def __repr__ ( self ): return ( f \" { self . __class__ . __name__ } (Name = { self . _name } , FromNode = { self . _fromnode } , ToNode = { self . _tonode } , Length = { self . _length } \" + f \"NumPhase = { self . _num_phase } , Length unit = { self . _length_unit } , Geometry = { self . _geometry } )\" )","title":"GeometryBasedLine"},{"location":"line_section/#shift.line_section.GeometryBasedLine.geometry","text":"Geometry of the line element Source code in shift\\line_section.py 703 704 705 706 @property def geometry ( self ) -> LineGeometry : \"\"\"Geometry of the line element\"\"\" return self . _geometry","title":"geometry()"},{"location":"line_section/#shift.line_section.HorizontalSinglePhaseConfiguration","text":"Bases: LineGeometryConfiguration Concrete implementation for single phase horizontal configuration. Attributes: Name Type Description unit str Unit of height height_of_conductor float Height of conductor from ground Source code in shift\\line_section.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 class HorizontalSinglePhaseConfiguration ( LineGeometryConfiguration ): \"\"\"Concrete implementation for single phase horizontal configuration. Attributes: unit (str): Unit of height height_of_conductor (float): Height of conductor from ground \"\"\" def __init__ ( self , height_of_conductor : float , unit : str ) -> None : \"\"\"Constructor class for `HorizontalSinglePhaseConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor def get_x_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ 0 ] def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor ]","title":"HorizontalSinglePhaseConfiguration"},{"location":"line_section/#shift.line_section.HorizontalSinglePhaseConfiguration.__init__","text":"Constructor class for HorizontalSinglePhaseConfiguration class. Parameters: Name Type Description Default height_of_conductor float Height of conductor from ground required unit str Unit of height required Source code in shift\\line_section.py 332 333 334 335 336 337 338 339 340 def __init__ ( self , height_of_conductor : float , unit : str ) -> None : \"\"\"Constructor class for `HorizontalSinglePhaseConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor","title":"__init__()"},{"location":"line_section/#shift.line_section.HorizontalSinglePhaseConfiguration.get_h_array","text":"Refer to base class for details. Source code in shift\\line_section.py 346 347 348 def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor ]","title":"get_h_array()"},{"location":"line_section/#shift.line_section.HorizontalSinglePhaseConfiguration.get_x_array","text":"Refer to base class for details. Source code in shift\\line_section.py 342 343 344 def get_x_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ 0 ]","title":"get_x_array()"},{"location":"line_section/#shift.line_section.HorizontalSinglePhaseNeutralConfiguration","text":"Bases: LineGeometryConfiguration Concrete implementation for single phase horizontal configuration with neutral wire. Attributes: Name Type Description unit str Unit of height height_of_conductor float Height of conductor from ground separation_between_conductor float Distance between phase and neutral wire Source code in shift\\line_section.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 class HorizontalSinglePhaseNeutralConfiguration ( LineGeometryConfiguration ): \"\"\"Concrete implementation for single phase horizontal configuration with neutral wire. Attributes: unit (str): Unit of height height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire \"\"\" def __init__ ( self , height_of_conductor : float , separation_between_conductor : float , unit : str , ) -> None : \"\"\"Constructor for `HorizontalSinglePhaseNeutralConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor self . separation_between_conductor = separation_between_conductor def get_x_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ - self . separation_between_conductor / 2 , self . separation_between_conductor / 2 , ] def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor , self . height_of_conductor ]","title":"HorizontalSinglePhaseNeutralConfiguration"},{"location":"line_section/#shift.line_section.HorizontalSinglePhaseNeutralConfiguration.__init__","text":"Constructor for HorizontalSinglePhaseNeutralConfiguration class. Parameters: Name Type Description Default height_of_conductor float Height of conductor from ground required separation_between_conductor float Distance between phase and neutral wire required unit str Unit of height required Source code in shift\\line_section.py 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 def __init__ ( self , height_of_conductor : float , separation_between_conductor : float , unit : str , ) -> None : \"\"\"Constructor for `HorizontalSinglePhaseNeutralConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor self . separation_between_conductor = separation_between_conductor","title":"__init__()"},{"location":"line_section/#shift.line_section.HorizontalSinglePhaseNeutralConfiguration.get_h_array","text":"Refer to base class for details. Source code in shift\\line_section.py 385 386 387 def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor , self . height_of_conductor ]","title":"get_h_array()"},{"location":"line_section/#shift.line_section.HorizontalSinglePhaseNeutralConfiguration.get_x_array","text":"Refer to base class for details. Source code in shift\\line_section.py 378 379 380 381 382 383 def get_x_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ - self . separation_between_conductor / 2 , self . separation_between_conductor / 2 , ]","title":"get_x_array()"},{"location":"line_section/#shift.line_section.HorizontalThreePhaseConfiguration","text":"Bases: LineGeometryConfiguration Concrete implementation for three phase horizontal configuration. Attributes: Name Type Description unit str Unit of height height_of_conductor float Height of conductor from ground separation_between_conductor float Distance between phase and neutral wire Source code in shift\\line_section.py 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 class HorizontalThreePhaseConfiguration ( LineGeometryConfiguration ): \"\"\"Concrete implementation for three phase horizontal configuration. Attributes: unit (str): Unit of height height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire \"\"\" def __init__ ( self , height_of_conductor , separation_between_conductor , unit ): \"\"\"Constructor for `HorizontalThreePhaseConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor self . separation_between_conductor = separation_between_conductor def get_x_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ - self . separation_between_conductor , 0 , self . separation_between_conductor , ] def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor , self . height_of_conductor , self . height_of_conductor , ]","title":"HorizontalThreePhaseConfiguration"},{"location":"line_section/#shift.line_section.HorizontalThreePhaseConfiguration.__init__","text":"Constructor for HorizontalThreePhaseConfiguration class. Parameters: Name Type Description Default height_of_conductor float Height of conductor from ground required separation_between_conductor float Distance between phase and neutral wire required unit str Unit of height required Source code in shift\\line_section.py 399 400 401 402 403 404 405 406 407 408 409 def __init__ ( self , height_of_conductor , separation_between_conductor , unit ): \"\"\"Constructor for `HorizontalThreePhaseConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor self . separation_between_conductor = separation_between_conductor","title":"__init__()"},{"location":"line_section/#shift.line_section.HorizontalThreePhaseConfiguration.get_h_array","text":"Refer to base class for details. Source code in shift\\line_section.py 419 420 421 422 423 424 425 def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor , self . height_of_conductor , self . height_of_conductor , ]","title":"get_h_array()"},{"location":"line_section/#shift.line_section.HorizontalThreePhaseConfiguration.get_x_array","text":"Refer to base class for details. Source code in shift\\line_section.py 411 412 413 414 415 416 417 def get_x_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ - self . separation_between_conductor , 0 , self . separation_between_conductor , ]","title":"get_x_array()"},{"location":"line_section/#shift.line_section.HorizontalThreePhaseNeutralConfiguration","text":"Bases: LineGeometryConfiguration Concrete implementation for three phase horizontal configuration with neutral. Attributes: Name Type Description unit str Unit of height height_of_conductor float Height of conductor from ground separation_between_conductor float Distance between phase and neutral wire height_of_neutral_conductor float Height of neutral conductor Source code in shift\\line_section.py 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 class HorizontalThreePhaseNeutralConfiguration ( LineGeometryConfiguration ): \"\"\"Concrete implementation for three phase horizontal configuration with neutral. Attributes: unit (str): Unit of height height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire height_of_neutral_conductor (float): Height of neutral conductor \"\"\" def __init__ ( self , height_of_conductor : float , separation_between_conductor : float , height_of_neutral_conductor : float , unit : str , ) -> None : \"\"\"Constructor for `HorizontalThreePhaseNeutralConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire height_of_neutral_conductor (float): Height of neutral conductor unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor self . separation_between_conductor = separation_between_conductor self . height_of_neutral_conductor = height_of_neutral_conductor def get_x_array ( self ): \"\"\"Refer to base class for details.\"\"\" return [ - self . separation_between_conductor , 0 , self . separation_between_conductor , 0 , ] def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor , self . height_of_conductor , self . height_of_conductor , self . height_of_neutral_conductor , ]","title":"HorizontalThreePhaseNeutralConfiguration"},{"location":"line_section/#shift.line_section.HorizontalThreePhaseNeutralConfiguration.__init__","text":"Constructor for HorizontalThreePhaseNeutralConfiguration class. Parameters: Name Type Description Default height_of_conductor float Height of conductor from ground required separation_between_conductor float Distance between phase and neutral wire required height_of_neutral_conductor float Height of neutral conductor required unit str Unit of height required Source code in shift\\line_section.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 def __init__ ( self , height_of_conductor : float , separation_between_conductor : float , height_of_neutral_conductor : float , unit : str , ) -> None : \"\"\"Constructor for `HorizontalThreePhaseNeutralConfiguration` class. Args: height_of_conductor (float): Height of conductor from ground separation_between_conductor (float): Distance between phase and neutral wire height_of_neutral_conductor (float): Height of neutral conductor unit (str): Unit of height \"\"\" self . unit = unit self . height_of_conductor = height_of_conductor self . separation_between_conductor = separation_between_conductor self . height_of_neutral_conductor = height_of_neutral_conductor","title":"__init__()"},{"location":"line_section/#shift.line_section.HorizontalThreePhaseNeutralConfiguration.get_h_array","text":"Refer to base class for details. Source code in shift\\line_section.py 468 469 470 471 472 473 474 475 def get_h_array ( self ) -> list : \"\"\"Refer to base class for details.\"\"\" return [ self . height_of_conductor , self . height_of_conductor , self . height_of_conductor , self . height_of_neutral_conductor , ]","title":"get_h_array()"},{"location":"line_section/#shift.line_section.HorizontalThreePhaseNeutralConfiguration.get_x_array","text":"Refer to base class for details. Source code in shift\\line_section.py 459 460 461 462 463 464 465 466 def get_x_array ( self ): \"\"\"Refer to base class for details.\"\"\" return [ - self . separation_between_conductor , 0 , self . separation_between_conductor , 0 , ]","title":"get_x_array()"},{"location":"line_section/#shift.line_section.Line","text":"Bases: ABC Interface for line section representation Source code in shift\\line_section.py 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 class Line ( ABC ): \"\"\"Interface for line section representation\"\"\" @property def name ( self ) -> str : \"\"\"Name property of a line element\"\"\" return self . _name @name . setter def name ( self , name : str ) -> None : \"\"\"Name setter method for a line element\"\"\" self . _name = name @property def fromnode ( self ) -> str : \"\"\"From node property of a line element\"\"\" return self . _fromnode @fromnode . setter def fromnode ( self , node : str ): \"\"\"From node setter method for a line element\"\"\" self . _fromnode = node @property def tonode ( self ) -> str : \"\"\"To node property of a line element\"\"\" return self . _tonode @tonode . setter def tonode ( self , node : str ): \"\"\"To node setter method for a line element\"\"\" self . _tonode = node @property def length ( self ) -> float : \"\"\"Length property of a line element\"\"\" return self . _length @length . setter def length ( self , length : float ): \"\"\"Length setter method for a line element\"\"\" if length < 0 : raise NegativeLineLengthError ( length ) self . _length = length @property def length_unit ( self ) -> str : \"\"\"Length unit property of a line element\"\"\" return self . _length_unit @length_unit . setter def length_unit ( self , unit : str ): \"\"\"Length setter method for a line element\"\"\" if unit not in VALID_LENGTH_UNITS : raise InvalidLengthUnitError ( unit ) self . _length_unit = unit @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property of the line element\"\"\" return self . _num_phase @num_phase . setter def num_phase ( self , num_phase : NumPhase ) -> None : \"\"\"Number of phase setter method for the line element\"\"\" self . _num_phase = num_phase @property def fromnode_phase ( self ) -> Phase : \"\"\"Phase property of the line element\"\"\" return self . _fromnode_phase @fromnode_phase . setter def fromnode_phase ( self , phase : Phase ) -> None : \"\"\"Phase setter method for the line element\"\"\" self . _fromnode_phase = phase @property def tonode_phase ( self ) -> Phase : \"\"\"Phase property of the line element\"\"\" return self . _tonode_phase @tonode_phase . setter def tonode_phase ( self , phase : Phase ) -> None : \"\"\"Phase setter method for the line element\"\"\" self . _tonode_phase = phase","title":"Line"},{"location":"line_section/#shift.line_section.Line.fromnode","text":"From node property of a line element Source code in shift\\line_section.py 625 626 627 628 @property def fromnode ( self ) -> str : \"\"\"From node property of a line element\"\"\" return self . _fromnode","title":"fromnode()"},{"location":"line_section/#shift.line_section.Line.fromnode_phase","text":"Phase property of the line element Source code in shift\\line_section.py 679 680 681 682 @property def fromnode_phase ( self ) -> Phase : \"\"\"Phase property of the line element\"\"\" return self . _fromnode_phase","title":"fromnode_phase()"},{"location":"line_section/#shift.line_section.Line.length","text":"Length property of a line element Source code in shift\\line_section.py 645 646 647 648 @property def length ( self ) -> float : \"\"\"Length property of a line element\"\"\" return self . _length","title":"length()"},{"location":"line_section/#shift.line_section.Line.length_unit","text":"Length unit property of a line element Source code in shift\\line_section.py 657 658 659 660 @property def length_unit ( self ) -> str : \"\"\"Length unit property of a line element\"\"\" return self . _length_unit","title":"length_unit()"},{"location":"line_section/#shift.line_section.Line.name","text":"Name property of a line element Source code in shift\\line_section.py 615 616 617 618 @property def name ( self ) -> str : \"\"\"Name property of a line element\"\"\" return self . _name","title":"name()"},{"location":"line_section/#shift.line_section.Line.num_phase","text":"Number of phase property of the line element Source code in shift\\line_section.py 669 670 671 672 @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property of the line element\"\"\" return self . _num_phase","title":"num_phase()"},{"location":"line_section/#shift.line_section.Line.tonode","text":"To node property of a line element Source code in shift\\line_section.py 635 636 637 638 @property def tonode ( self ) -> str : \"\"\"To node property of a line element\"\"\" return self . _tonode","title":"tonode()"},{"location":"line_section/#shift.line_section.Line.tonode_phase","text":"Phase property of the line element Source code in shift\\line_section.py 689 690 691 692 @property def tonode_phase ( self ) -> Phase : \"\"\"Phase property of the line element\"\"\" return self . _tonode_phase","title":"tonode_phase()"},{"location":"line_section/#shift.line_section.LineGeometry","text":"Bases: ABC Interface for line geometry. Source code in shift\\line_section.py 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 class LineGeometry ( ABC ): \"\"\"Interface for line geometry.\"\"\" @property def name ( self ) -> str : \"\"\"Name property of a line geometry\"\"\" return self . _name @name . setter def name ( self , name : str ) -> None : \"\"\"Name setter method for a line geometry\"\"\" self . _name = name @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property of the line geometry\"\"\" return self . _num_phase @num_phase . setter def num_phase ( self , num_phase : NumPhase ) -> None : \"\"\"Number of phase setter method for a line geometry\"\"\" self . _num_phase = num_phase @property def num_conds ( self ) -> int : \"\"\"Number of conductors property of the line geometry\"\"\" return self . _num_conds @num_conds . setter def num_conds ( self , num_of_conds : int ) -> None : \"\"\"Number of conductors setter method for a line geometry\"\"\" self . _num_conds = num_of_conds @property def configuration ( self ) -> LineGeometryConfiguration : \"\"\"Phase wire property of a line geometry\"\"\" return self . _configuration @configuration . setter def configuration ( self , configuration : LineGeometryConfiguration ) -> None : \"\"\"Phase wire setter method for a line geometry\"\"\" self . _configuration = configuration def __eq__ ( self , other ): if ( self . num_phase == other . num_phase and self . num_conds == other . num_conds and self . configuration == other . configuration ): return True else : False def __repr__ ( self ): return f \" { self . __class__ . __name__ } (Name = { self . _name } , NumPhase = { self . _num_phase } , \\ Number of conductors = { self . _num_conds } , Configuration = { self . _configuration } )\"","title":"LineGeometry"},{"location":"line_section/#shift.line_section.LineGeometry.configuration","text":"Phase wire property of a line geometry Source code in shift\\line_section.py 511 512 513 514 @property def configuration ( self ) -> LineGeometryConfiguration : \"\"\"Phase wire property of a line geometry\"\"\" return self . _configuration","title":"configuration()"},{"location":"line_section/#shift.line_section.LineGeometry.name","text":"Name property of a line geometry Source code in shift\\line_section.py 481 482 483 484 @property def name ( self ) -> str : \"\"\"Name property of a line geometry\"\"\" return self . _name","title":"name()"},{"location":"line_section/#shift.line_section.LineGeometry.num_conds","text":"Number of conductors property of the line geometry Source code in shift\\line_section.py 501 502 503 504 @property def num_conds ( self ) -> int : \"\"\"Number of conductors property of the line geometry\"\"\" return self . _num_conds","title":"num_conds()"},{"location":"line_section/#shift.line_section.LineGeometry.num_phase","text":"Number of phase property of the line geometry Source code in shift\\line_section.py 491 492 493 494 @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property of the line geometry\"\"\" return self . _num_phase","title":"num_phase()"},{"location":"line_section/#shift.line_section.LineGeometryConfiguration","text":"Bases: ABC Interface for line geometry configuration data. Source code in shift\\line_section.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 class LineGeometryConfiguration ( ABC ): \"\"\"Interface for line geometry configuration data.\"\"\" @property def unit ( self ) -> str : \"\"\"Unit property for configuration\"\"\" return self . _unit @unit . setter def unit ( self , unit_ : str ) -> None : \"\"\"Name setter method for a line geometry\"\"\" if unit_ not in VALID_LENGTH_UNITS : raise InvalidLengthUnitError ( unit_ ) self . _unit = unit_ @abstractmethod def get_x_array ( self ) -> list : \"\"\"Abstract method for getting x array to model line geometry. Returns: list: e.g [-0.4, 0, 0.4] \"\"\" pass @abstractmethod def get_h_array ( self ) -> list : \"\"\"Abstract method for getting h array to model line geometry. Returns: list: e.g. [9.0, 9.0, 9.0] \"\"\" pass def __eq__ ( self , other ): if ( self . unit == other . unit and self . get_x_array () == other . get_x_array () and self . get_h_array () == other . get_h_array () ): return True else : return False","title":"LineGeometryConfiguration"},{"location":"line_section/#shift.line_section.LineGeometryConfiguration.get_h_array","text":"Abstract method for getting h array to model line geometry. Returns: Name Type Description list list e.g. [9.0, 9.0, 9.0] Source code in shift\\line_section.py 303 304 305 306 307 308 309 310 @abstractmethod def get_h_array ( self ) -> list : \"\"\"Abstract method for getting h array to model line geometry. Returns: list: e.g. [9.0, 9.0, 9.0] \"\"\" pass","title":"get_h_array()"},{"location":"line_section/#shift.line_section.LineGeometryConfiguration.get_x_array","text":"Abstract method for getting x array to model line geometry. Returns: Name Type Description list list e.g [-0.4, 0, 0.4] Source code in shift\\line_section.py 294 295 296 297 298 299 300 301 @abstractmethod def get_x_array ( self ) -> list : \"\"\"Abstract method for getting x array to model line geometry. Returns: list: e.g [-0.4, 0, 0.4] \"\"\" pass","title":"get_x_array()"},{"location":"line_section/#shift.line_section.LineGeometryConfiguration.unit","text":"Unit property for configuration Source code in shift\\line_section.py 282 283 284 285 @property def unit ( self ) -> str : \"\"\"Unit property for configuration\"\"\" return self . _unit","title":"unit()"},{"location":"line_section/#shift.line_section.OverheadLineGeometry","text":"Bases: LineGeometry Interface for overhead line geometry. Source code in shift\\line_section.py 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 class OverheadLineGeometry ( LineGeometry ): \"\"\"Interface for overhead line geometry.\"\"\" @property def phase_wire ( self ) -> Wire : \"\"\"Phase wire property of a line geometry\"\"\" return self . _phase_wire @phase_wire . setter def phase_wire ( self , wire : Wire ) -> None : \"\"\"Phase wire setter method for a line geometry\"\"\" self . _phase_wire = wire def __eq__ ( self , other ): if super () . __eq__ ( other ) and self . phase_wire == other . phase_wire : return True else : False def __repr__ ( self ): repr = super () . __repr__ () return f \" { self . __class__ . __name__ } ( { repr . split ( '(' )[ 1 ] . split ( ')' )[ 0 ] } , Phase wire = { self . _phase_wire } )\"","title":"OverheadLineGeometry"},{"location":"line_section/#shift.line_section.OverheadLineGeometry.phase_wire","text":"Phase wire property of a line geometry Source code in shift\\line_section.py 540 541 542 543 @property def phase_wire ( self ) -> Wire : \"\"\"Phase wire property of a line geometry\"\"\" return self . _phase_wire","title":"phase_wire()"},{"location":"line_section/#shift.line_section.OverheadLinewithNeutralGeometry","text":"Bases: OverheadLineGeometry Interface for overhead line with neutral geometry. Source code in shift\\line_section.py 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 class OverheadLinewithNeutralGeometry ( OverheadLineGeometry ): \"\"\"Interface for overhead line with neutral geometry.\"\"\" @property def neutral_wire ( self ) -> str : \"\"\"Neutral wire property of a line geometry\"\"\" return self . _neutral_wire @neutral_wire . setter def neutral_wire ( self , wire : Wire ) -> None : \"\"\"Neutral wire setter method for a line geometry\"\"\" self . _neutral_wire = wire def __eq__ ( self , other ): if super () . __eq__ ( other ) and self . neutral_wire == other . neutral_wire : return True else : False def __repr__ ( self ): repr = super () . __repr__ () return f \" { self . __class__ . __name__ } ( { repr . split ( '(' )[ 1 ] . split ( ')' )[ 0 ] } , Neutral wire = { self . _neutral_wire } )\"","title":"OverheadLinewithNeutralGeometry"},{"location":"line_section/#shift.line_section.OverheadLinewithNeutralGeometry.neutral_wire","text":"Neutral wire property of a line geometry Source code in shift\\line_section.py 565 566 567 568 @property def neutral_wire ( self ) -> str : \"\"\"Neutral wire property of a line geometry\"\"\" return self . _neutral_wire","title":"neutral_wire()"},{"location":"line_section/#shift.line_section.UndergroundLineGeometry","text":"Bases: LineGeometry Interface for underground line geometry Source code in shift\\line_section.py 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 class UndergroundLineGeometry ( LineGeometry ): \"\"\"Interface for underground line geometry\"\"\" @property def phase_cable ( self ) -> Cable : \"\"\"Phase cable property of a line geometry\"\"\" return self . _phase_cable @phase_cable . setter def phase_cable ( self , cable : Cable ) -> None : \"\"\"Phase cable setter method for a line geometry\"\"\" self . _phase_cable = cable def __eq__ ( self , other ): if super () . __eq__ ( other ) and self . phase_cable == other . phase_cable : return True else : False def __repr__ ( self ): repr = super () . __repr__ () return f \" { self . __class__ . __name__ } ( { repr . split ( '(' )[ 1 ] . split ( ')' )[ 0 ] } , Phase cable = { self . _phase_cable } )\"","title":"UndergroundLineGeometry"},{"location":"line_section/#shift.line_section.UndergroundLineGeometry.phase_cable","text":"Phase cable property of a line geometry Source code in shift\\line_section.py 590 591 592 593 @property def phase_cable ( self ) -> Cable : \"\"\"Phase cable property of a line geometry\"\"\" return self . _phase_cable","title":"phase_cable()"},{"location":"line_section/#shift.line_section.Wire","text":"Class for storing wire data. Source code in shift\\line_section.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class Wire : \"\"\"Class for storing wire data.\"\"\" @property def name ( self ) -> str : \"\"\"Name property of a wire\"\"\" return self . _name @name . setter def name ( self , name : str ) -> None : \"\"\"Name setter method of a wire\"\"\" self . _name = name @property def runits ( self ) -> str : \"\"\"Unit for reistance property of a wire\"\"\" return self . _runits @runits . setter def runits ( self , unit : str ) -> None : \"\"\"runits setter method for a wire\"\"\" if unit not in VALID_LENGTH_UNITS : raise InvalidLengthUnitError ( unit ) self . _runits = unit @property def gmrunits ( self ) -> str : \"\"\"gmrunits for diamater property for a wire\"\"\" return self . _gmrunits @gmrunits . setter def gmrunits ( self , unit : str ) -> None : \"\"\"gmrunits setter method for a wire\"\"\" if unit not in VALID_LENGTH_UNITS : raise InvalidLengthUnitError ( unit ) self . _gmrunits = unit @property def radunits ( self ) -> str : \"\"\"Units for diamater property for a wire\"\"\" return self . _radunits @radunits . setter def radunits ( self , unit : str ) -> None : \"\"\"radunits setter method for a wire\"\"\" if unit not in VALID_LENGTH_UNITS : raise InvalidLengthUnitError ( unit ) self . _radunits = unit @property def rac ( self ) -> float : \"\"\"AC resistance property for a wire\"\"\" return self . _rac @rac . setter def rac ( self , r : float ) -> None : \"\"\"AC resistance property setter method for a wire\"\"\" if r < 0 : raise NegativeResistanceError ( r ) self . _rac = r @property def diam ( self ) -> float : \"\"\"Diameter property of a wire\"\"\" return self . _diam @diam . setter def diam ( self , diameter : float ) -> None : \"\"\"Diameter setter method for a wire\"\"\" if diameter < 0 : raise NegativeDiameterError ( diameter ) self . _diam = diameter @property def gmrac ( self ) -> float : \"\"\"gmrac property of a wire\"\"\" return self . _gmrac @gmrac . setter def gmrac ( self , gmr : float ) -> None : \"\"\"gmrac setter method for a wire\"\"\" if gmr < 0 : raise NegativeGMRError ( gmr ) self . _gmrac = gmr @property def normamps ( self ) -> float : \"\"\"Normal ampacity property of a wire\"\"\" return self . _normamps @normamps . setter def normamps ( self , current : float ) -> None : \"\"\"AC resistance property setter method for a wire\"\"\" if current < 0 : raise NegativeAmpacityError ( current ) self . _normamps = current def __eq__ ( self , other ): if ( self . name == other . name and self . runits == other . runits and self . gmrunits == other . gmrunits and self . radunits == other . radunits and self . rac == other . rac and self . diam == other . diam and self . gmrac == other . gmrac and self . normamps == other . normamps ): return True else : False def __repr__ ( self ): return ( f \" { self . __class__ . __name__ } (Name = { self . _name } , Resistance unit = { self . _runits } , GMR unit = { self . _gmrunits } , Radius unit = { self . _radunits } \" + f \", AC resistance (ohm per) = { self . _rac } , Diameter = { self . _diam } , GMR AC = { self . _gmrac } , Ampacity = { self . _normamps } )\" )","title":"Wire"},{"location":"line_section/#shift.line_section.Wire.diam","text":"Diameter property of a wire Source code in shift\\line_section.py 108 109 110 111 @property def diam ( self ) -> float : \"\"\"Diameter property of a wire\"\"\" return self . _diam","title":"diam()"},{"location":"line_section/#shift.line_section.Wire.gmrac","text":"gmrac property of a wire Source code in shift\\line_section.py 120 121 122 123 @property def gmrac ( self ) -> float : \"\"\"gmrac property of a wire\"\"\" return self . _gmrac","title":"gmrac()"},{"location":"line_section/#shift.line_section.Wire.gmrunits","text":"gmrunits for diamater property for a wire Source code in shift\\line_section.py 72 73 74 75 @property def gmrunits ( self ) -> str : \"\"\"gmrunits for diamater property for a wire\"\"\" return self . _gmrunits","title":"gmrunits()"},{"location":"line_section/#shift.line_section.Wire.name","text":"Name property of a wire Source code in shift\\line_section.py 50 51 52 53 @property def name ( self ) -> str : \"\"\"Name property of a wire\"\"\" return self . _name","title":"name()"},{"location":"line_section/#shift.line_section.Wire.normamps","text":"Normal ampacity property of a wire Source code in shift\\line_section.py 132 133 134 135 @property def normamps ( self ) -> float : \"\"\"Normal ampacity property of a wire\"\"\" return self . _normamps","title":"normamps()"},{"location":"line_section/#shift.line_section.Wire.rac","text":"AC resistance property for a wire Source code in shift\\line_section.py 96 97 98 99 @property def rac ( self ) -> float : \"\"\"AC resistance property for a wire\"\"\" return self . _rac","title":"rac()"},{"location":"line_section/#shift.line_section.Wire.radunits","text":"Units for diamater property for a wire Source code in shift\\line_section.py 84 85 86 87 @property def radunits ( self ) -> str : \"\"\"Units for diamater property for a wire\"\"\" return self . _radunits","title":"radunits()"},{"location":"line_section/#shift.line_section.Wire.runits","text":"Unit for reistance property of a wire Source code in shift\\line_section.py 60 61 62 63 @property def runits ( self ) -> str : \"\"\"Unit for reistance property of a wire\"\"\" return self . _runits","title":"runits()"},{"location":"load/","text":"This module contains classes for representing different type of power system loads. Examples: >>> from shift.load import ConstantPowerLoad >>> load = ConstantPowerLoad () >>> load . name = \"Load1\" >>> load . latitude = 60.233 >>> load . longitude = 23.455 >>> load . phase = Phase . A >>> load . num_phase = NumPhase . SINGLE >>> load . conn_type = LoadConnection . STAR >>> load . kv = 12.7 >>> load . kw = 4.8 >>> load . kvar = 3.4 >>> print ( load ) ConstantPowerFactorLoad Bases: Load Implementation for constant power factor load. Source code in shift\\load.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class ConstantPowerFactorLoad ( Load ): \"\"\"Implementation for constant power factor load.\"\"\" @property def kw ( self ) -> float : \"\"\"kw property of the load\"\"\" return self . _kw @kw . setter def kw ( self , kw : float ) -> None : \"\"\"kw setter method for the load\"\"\" self . _kw = kw @property def pf ( self ) -> float : \"\"\"power factor setter method for the load\"\"\" return self . _pf @pf . setter def pf ( self , pf : float ) -> None : \"\"\"power factor setter method for the load\"\"\" if pf < MIN_POWER_FACTOR or pf > MAX_POWER_FACTOR : raise PowerFactorNotInRangeError ( pf ) self . _pf = pf def __repr__ ( self ): return ( f \"ConstantPowerFactorLoad(Name = { self . _name } , Latitude = { self . _latitude } , Longitude = { self . _longitude } , Phase = { self . _phase } \" + f \"NumPhase = { self . _num_phase } , Connection Type = { self . _conn_type } , kw = { self . _kw } , pf = { self . _pf } , kv = { self . _kv } )\" ) kw () property writable kw property of the load Source code in shift\\load.py 184 185 186 187 @property def kw ( self ) -> float : \"\"\"kw property of the load\"\"\" return self . _kw pf () property writable power factor setter method for the load Source code in shift\\load.py 194 195 196 197 @property def pf ( self ) -> float : \"\"\"power factor setter method for the load\"\"\" return self . _pf ConstantPowerLoad Bases: Load Implementation for constant power load. Source code in shift\\load.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 class ConstantPowerLoad ( Load ): \"\"\"Implementation for constant power load.\"\"\" @property def kw ( self ) -> float : \"\"\"kw property of the load\"\"\" return self . _kw @kw . setter def kw ( self , kw : float ) -> None : \"\"\"kw setter method for the load\"\"\" self . _kw = kw @property def kvar ( self ) -> float : \"\"\"kvar property of the load\"\"\" return self . _kvar @kvar . setter def kvar ( self , kvar : float ) -> None : \"\"\"kvar setter method for the load\"\"\" self . _kvar = kvar def __repr__ ( self ): return ( f \"ConstantPowerLoad(Name = { self . _name } , Latitude = { self . _latitude } , Longitude = { self . _longitude } , Phase = { self . _phase } \" + f \"NumPhase = { self . _num_phase } , Connection Type = { self . _conn_type } , kw = { self . _kw } , kvar = { self . _kvar } , kv = { self . _kv } )\" ) kvar () property writable kvar property of the load Source code in shift\\load.py 164 165 166 167 @property def kvar ( self ) -> float : \"\"\"kvar property of the load\"\"\" return self . _kvar kw () property writable kw property of the load Source code in shift\\load.py 154 155 156 157 @property def kw ( self ) -> float : \"\"\"kw property of the load\"\"\" return self . _kw Load Bases: ABC Interface for single load point. Source code in shift\\load.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 class Load ( ABC ): \"\"\"Interface for single load point.\"\"\" @property def name ( self ) -> str : \"\"\"Name property of load\"\"\" return self . _name @name . setter def name ( self , name : str ) -> None : \"\"\"Name setter method for a load\"\"\" self . _name = name @property def latitude ( self ) -> float : \"\"\"Latitude property where load is located\"\"\" return self . _latitude @latitude . setter def latitude ( self , latitude : float ) -> None : \"\"\"Latitude setter method for the load\"\"\" if latitude < MIN_LATITUDE or latitude > MAX_LATITUDE : raise LatitudeNotInRangeError ( latitude ) self . _latitude = latitude @property def longitude ( self ) -> float : \"\"\"Longitude property where load is located\"\"\" return self . _longitude @longitude . setter def longitude ( self , longitude : float ) -> None : \"\"\"Longitude setter method for the load\"\"\" if longitude < MIN_LONGITUDE or longitude > MAX_LONGITUDE : raise LongitudeNotInRangeError ( longitude ) self . _longitude = longitude @property def phase ( self ) -> Phase : \"\"\"Phase property where load is connected\"\"\" return self . _phase @phase . setter def phase ( self , phase : Phase ) -> None : \"\"\"Phase setter method for the load\"\"\" self . _phase = phase @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property of the load\"\"\" return self . _num_phase @num_phase . setter def num_phase ( self , num_phase : NumPhase ) -> None : \"\"\"Number of phase setter method for the load\"\"\" self . _num_phase = num_phase @property def conn_type ( self ) -> LoadConnection : \"\"\"Connection type property of the load\"\"\" return self . _conn_type @conn_type . setter def conn_type ( self , connection : LoadConnection ) -> None : \"\"\"Abstract connection type setter method for the load\"\"\" self . _conn_type = connection @property def kv ( self ) -> float : \"\"\"kv property of the load\"\"\" return self . _kv @kv . setter def kv ( self , kv : float ) -> None : \"\"\"kv setter method for the load\"\"\" if kv < 0 : raise NegativeKVError ( kv ) if kv == 0 : raise ZeroKVError () self . _kv = kv conn_type () property writable Connection type property of the load Source code in shift\\load.py 126 127 128 129 @property def conn_type ( self ) -> LoadConnection : \"\"\"Connection type property of the load\"\"\" return self . _conn_type kv () property writable kv property of the load Source code in shift\\load.py 136 137 138 139 @property def kv ( self ) -> float : \"\"\"kv property of the load\"\"\" return self . _kv latitude () property writable Latitude property where load is located Source code in shift\\load.py 82 83 84 85 @property def latitude ( self ) -> float : \"\"\"Latitude property where load is located\"\"\" return self . _latitude longitude () property writable Longitude property where load is located Source code in shift\\load.py 94 95 96 97 @property def longitude ( self ) -> float : \"\"\"Longitude property where load is located\"\"\" return self . _longitude name () property writable Name property of load Source code in shift\\load.py 72 73 74 75 @property def name ( self ) -> str : \"\"\"Name property of load\"\"\" return self . _name num_phase () property writable Number of phase property of the load Source code in shift\\load.py 116 117 118 119 @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property of the load\"\"\" return self . _num_phase phase () property writable Phase property where load is connected Source code in shift\\load.py 106 107 108 109 @property def phase ( self ) -> Phase : \"\"\"Phase property where load is connected\"\"\" return self . _phase","title":"load"},{"location":"load/#shift.load.ConstantPowerFactorLoad","text":"Bases: Load Implementation for constant power factor load. Source code in shift\\load.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 class ConstantPowerFactorLoad ( Load ): \"\"\"Implementation for constant power factor load.\"\"\" @property def kw ( self ) -> float : \"\"\"kw property of the load\"\"\" return self . _kw @kw . setter def kw ( self , kw : float ) -> None : \"\"\"kw setter method for the load\"\"\" self . _kw = kw @property def pf ( self ) -> float : \"\"\"power factor setter method for the load\"\"\" return self . _pf @pf . setter def pf ( self , pf : float ) -> None : \"\"\"power factor setter method for the load\"\"\" if pf < MIN_POWER_FACTOR or pf > MAX_POWER_FACTOR : raise PowerFactorNotInRangeError ( pf ) self . _pf = pf def __repr__ ( self ): return ( f \"ConstantPowerFactorLoad(Name = { self . _name } , Latitude = { self . _latitude } , Longitude = { self . _longitude } , Phase = { self . _phase } \" + f \"NumPhase = { self . _num_phase } , Connection Type = { self . _conn_type } , kw = { self . _kw } , pf = { self . _pf } , kv = { self . _kv } )\" )","title":"ConstantPowerFactorLoad"},{"location":"load/#shift.load.ConstantPowerFactorLoad.kw","text":"kw property of the load Source code in shift\\load.py 184 185 186 187 @property def kw ( self ) -> float : \"\"\"kw property of the load\"\"\" return self . _kw","title":"kw()"},{"location":"load/#shift.load.ConstantPowerFactorLoad.pf","text":"power factor setter method for the load Source code in shift\\load.py 194 195 196 197 @property def pf ( self ) -> float : \"\"\"power factor setter method for the load\"\"\" return self . _pf","title":"pf()"},{"location":"load/#shift.load.ConstantPowerLoad","text":"Bases: Load Implementation for constant power load. Source code in shift\\load.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 class ConstantPowerLoad ( Load ): \"\"\"Implementation for constant power load.\"\"\" @property def kw ( self ) -> float : \"\"\"kw property of the load\"\"\" return self . _kw @kw . setter def kw ( self , kw : float ) -> None : \"\"\"kw setter method for the load\"\"\" self . _kw = kw @property def kvar ( self ) -> float : \"\"\"kvar property of the load\"\"\" return self . _kvar @kvar . setter def kvar ( self , kvar : float ) -> None : \"\"\"kvar setter method for the load\"\"\" self . _kvar = kvar def __repr__ ( self ): return ( f \"ConstantPowerLoad(Name = { self . _name } , Latitude = { self . _latitude } , Longitude = { self . _longitude } , Phase = { self . _phase } \" + f \"NumPhase = { self . _num_phase } , Connection Type = { self . _conn_type } , kw = { self . _kw } , kvar = { self . _kvar } , kv = { self . _kv } )\" )","title":"ConstantPowerLoad"},{"location":"load/#shift.load.ConstantPowerLoad.kvar","text":"kvar property of the load Source code in shift\\load.py 164 165 166 167 @property def kvar ( self ) -> float : \"\"\"kvar property of the load\"\"\" return self . _kvar","title":"kvar()"},{"location":"load/#shift.load.ConstantPowerLoad.kw","text":"kw property of the load Source code in shift\\load.py 154 155 156 157 @property def kw ( self ) -> float : \"\"\"kw property of the load\"\"\" return self . _kw","title":"kw()"},{"location":"load/#shift.load.Load","text":"Bases: ABC Interface for single load point. Source code in shift\\load.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 class Load ( ABC ): \"\"\"Interface for single load point.\"\"\" @property def name ( self ) -> str : \"\"\"Name property of load\"\"\" return self . _name @name . setter def name ( self , name : str ) -> None : \"\"\"Name setter method for a load\"\"\" self . _name = name @property def latitude ( self ) -> float : \"\"\"Latitude property where load is located\"\"\" return self . _latitude @latitude . setter def latitude ( self , latitude : float ) -> None : \"\"\"Latitude setter method for the load\"\"\" if latitude < MIN_LATITUDE or latitude > MAX_LATITUDE : raise LatitudeNotInRangeError ( latitude ) self . _latitude = latitude @property def longitude ( self ) -> float : \"\"\"Longitude property where load is located\"\"\" return self . _longitude @longitude . setter def longitude ( self , longitude : float ) -> None : \"\"\"Longitude setter method for the load\"\"\" if longitude < MIN_LONGITUDE or longitude > MAX_LONGITUDE : raise LongitudeNotInRangeError ( longitude ) self . _longitude = longitude @property def phase ( self ) -> Phase : \"\"\"Phase property where load is connected\"\"\" return self . _phase @phase . setter def phase ( self , phase : Phase ) -> None : \"\"\"Phase setter method for the load\"\"\" self . _phase = phase @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property of the load\"\"\" return self . _num_phase @num_phase . setter def num_phase ( self , num_phase : NumPhase ) -> None : \"\"\"Number of phase setter method for the load\"\"\" self . _num_phase = num_phase @property def conn_type ( self ) -> LoadConnection : \"\"\"Connection type property of the load\"\"\" return self . _conn_type @conn_type . setter def conn_type ( self , connection : LoadConnection ) -> None : \"\"\"Abstract connection type setter method for the load\"\"\" self . _conn_type = connection @property def kv ( self ) -> float : \"\"\"kv property of the load\"\"\" return self . _kv @kv . setter def kv ( self , kv : float ) -> None : \"\"\"kv setter method for the load\"\"\" if kv < 0 : raise NegativeKVError ( kv ) if kv == 0 : raise ZeroKVError () self . _kv = kv","title":"Load"},{"location":"load/#shift.load.Load.conn_type","text":"Connection type property of the load Source code in shift\\load.py 126 127 128 129 @property def conn_type ( self ) -> LoadConnection : \"\"\"Connection type property of the load\"\"\" return self . _conn_type","title":"conn_type()"},{"location":"load/#shift.load.Load.kv","text":"kv property of the load Source code in shift\\load.py 136 137 138 139 @property def kv ( self ) -> float : \"\"\"kv property of the load\"\"\" return self . _kv","title":"kv()"},{"location":"load/#shift.load.Load.latitude","text":"Latitude property where load is located Source code in shift\\load.py 82 83 84 85 @property def latitude ( self ) -> float : \"\"\"Latitude property where load is located\"\"\" return self . _latitude","title":"latitude()"},{"location":"load/#shift.load.Load.longitude","text":"Longitude property where load is located Source code in shift\\load.py 94 95 96 97 @property def longitude ( self ) -> float : \"\"\"Longitude property where load is located\"\"\" return self . _longitude","title":"longitude()"},{"location":"load/#shift.load.Load.name","text":"Name property of load Source code in shift\\load.py 72 73 74 75 @property def name ( self ) -> str : \"\"\"Name property of load\"\"\" return self . _name","title":"name()"},{"location":"load/#shift.load.Load.num_phase","text":"Number of phase property of the load Source code in shift\\load.py 116 117 118 119 @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property of the load\"\"\" return self . _num_phase","title":"num_phase()"},{"location":"load/#shift.load.Load.phase","text":"Phase property where load is connected Source code in shift\\load.py 106 107 108 109 @property def phase ( self ) -> Phase : \"\"\"Phase property where load is connected\"\"\" return self . _phase","title":"phase()"},{"location":"load_builder/","text":"This module contains builder for building load models for distribution system. Examples >>> from shift.load_builder import ConstantPowerFactorBuildingGeometryLoadBuilder >>> from shift.geometry import BuildingGeometry >>> g1 = BuildingGeometry() >>> g1.latitude = 56.567 >>> g1.longitude = 67.8889 >>> g1.area = 2 >>> g2 = BuildingGeometry() >>> g2.latitude = 56.567 >>> g2.longitude = 67.8889 >>> g2.area = 2 >>> builder = ConstantPowerFactorBuildingGeometryLoadBuilder(g1, RandomPhaseAllocator(50, 0, 50, [g1,g2]), ProportionalBuildingAreaToConsumptionConverter(2,5,0,10), SimpleVoltageSetter(13.2),DefaultConnSetter(),1.0) >>> b = LoadBuilderEngineer(builder) >>> print(b.get_load()) BuildingAreaToConsumptionConverter Bases: ABC Interface for computing power consumption from building area. Source code in shift\\load_builder.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class BuildingAreaToConsumptionConverter ( ABC ): \"\"\"Interface for computing power consumption from building area.\"\"\" @abstractmethod def convert ( self , area : float ) -> float : \"\"\"Abstract method for computing the power consumption. Args: area (float): Building area Returns: float: Power consumption in kW \"\"\" pass convert ( area ) abstractmethod Abstract method for computing the power consumption. Parameters: Name Type Description Default area float Building area required Returns: Name Type Description float float Power consumption in kW Source code in shift\\load_builder.py 71 72 73 74 75 76 77 78 79 80 81 @abstractmethod def convert ( self , area : float ) -> float : \"\"\"Abstract method for computing the power consumption. Args: area (float): Building area Returns: float: Power consumption in kW \"\"\" pass ConnSetter Bases: ABC Interface for setting the connection type for load object. Source code in shift\\load_builder.py 319 320 321 322 323 324 325 326 327 328 329 330 331 332 class ConnSetter ( ABC ): \"\"\"Interface for setting the connection type for load object.\"\"\" @abstractmethod def get_conn ( self , load : Load ) -> LoadConnection : \"\"\"Abstract method for setting connection type for load object. Args: load (Load): Load instance Returns: LoadConnection: Connection type for the load \"\"\" pass get_conn ( load ) abstractmethod Abstract method for setting connection type for load object. Parameters: Name Type Description Default load Load Load instance required Returns: Name Type Description LoadConnection LoadConnection Connection type for the load Source code in shift\\load_builder.py 322 323 324 325 326 327 328 329 330 331 332 @abstractmethod def get_conn ( self , load : Load ) -> LoadConnection : \"\"\"Abstract method for setting connection type for load object. Args: load (Load): Load instance Returns: LoadConnection: Connection type for the load \"\"\" pass ConstantPowerFactorBuildingGeometryLoadBuilder Bases: GeometryLoadBuilder Concerete implementation for building constant power factor type load from geometry object. Refer to the base class for base attributes. Attributes: Name Type Description power_factor float Power factor area_converter BuildingAreaToConsumptionConverter BuildingAreaToConsumptionConverter instance Source code in shift\\load_builder.py 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 class ConstantPowerFactorBuildingGeometryLoadBuilder ( GeometryLoadBuilder ): \"\"\"Concerete implementation for building constant power factor type load from geometry object. Refer to the base class for base attributes. Attributes: power_factor (float): Power factor area_converter (BuildingAreaToConsumptionConverter): BuildingAreaToConsumptionConverter instance \"\"\" def __init__ ( self , geometry : Geometry , phaseallocator : PhaseAllocator , area_converter : BuildingAreaToConsumptionConverter , kv_setter : VoltageSetter , conn_setter : ConnSetter , power_factor : float , ) -> None : \"\"\"Constructor for `ConstantPowerFactorBuildingGeometryLoadBuilder` class. Refer to base class for base arguments. Args: area_converter (BuildingAreaToConsumptionConverter): BuildingAreaToConsumptionConverter instance power_factor (float): Power factor \"\"\" super () . __init__ ( geometry , phaseallocator , kv_setter , conn_setter , ConstantPowerFactorLoad (), ) self . power_factor = power_factor self . area_converter = area_converter def set_power_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . pf = self . power_factor self . load . kw = self . area_converter . convert ( self . geometry . area ) __init__ ( geometry , phaseallocator , area_converter , kv_setter , conn_setter , power_factor ) Constructor for ConstantPowerFactorBuildingGeometryLoadBuilder class. Refer to base class for base arguments. Parameters: Name Type Description Default area_converter BuildingAreaToConsumptionConverter BuildingAreaToConsumptionConverter instance required power_factor float Power factor required Source code in shift\\load_builder.py 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 def __init__ ( self , geometry : Geometry , phaseallocator : PhaseAllocator , area_converter : BuildingAreaToConsumptionConverter , kv_setter : VoltageSetter , conn_setter : ConnSetter , power_factor : float , ) -> None : \"\"\"Constructor for `ConstantPowerFactorBuildingGeometryLoadBuilder` class. Refer to base class for base arguments. Args: area_converter (BuildingAreaToConsumptionConverter): BuildingAreaToConsumptionConverter instance power_factor (float): Power factor \"\"\" super () . __init__ ( geometry , phaseallocator , kv_setter , conn_setter , ConstantPowerFactorLoad (), ) self . power_factor = power_factor self . area_converter = area_converter set_power_data () Refer to base class for more details. Source code in shift\\load_builder.py 467 468 469 470 def set_power_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . pf = self . power_factor self . load . kw = self . area_converter . convert ( self . geometry . area ) ConstantPowerFactorSimpleLoadGeometryLoadBuilder Bases: GeometryLoadBuilder Concerete implementation for building constant power factor type load from simple load point geometry object. Refer to base class for base attributes. Attributes: Name Type Description power_factor float Power factor Source code in shift\\load_builder.py 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 class ConstantPowerFactorSimpleLoadGeometryLoadBuilder ( GeometryLoadBuilder ): \"\"\"Concerete implementation for building constant power factor type load from simple load point geometry object. Refer to base class for base attributes. Attributes: power_factor (float): Power factor \"\"\" def __init__ ( self , geometry : Geometry , phaseallocator : PhaseAllocator , kv_setter : VoltageSetter , conn_setter : ConnSetter , power_factor : float , ) -> None : \"\"\"Constructor for `ConstantPowerFactorSimpleLoadGeometryLoadBuilder` class. Refer to base class for base arguments. Args: power_factor (float): Power factor \"\"\" super () . __init__ ( geometry , phaseallocator , kv_setter , conn_setter , ConstantPowerFactorLoad (), ) self . power_factor = power_factor def set_power_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . pf = self . power_factor self . load . kw = self . geometry . kw __init__ ( geometry , phaseallocator , kv_setter , conn_setter , power_factor ) Constructor for ConstantPowerFactorSimpleLoadGeometryLoadBuilder class. Refer to base class for base arguments. Parameters: Name Type Description Default power_factor float Power factor required Source code in shift\\load_builder.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 def __init__ ( self , geometry : Geometry , phaseallocator : PhaseAllocator , kv_setter : VoltageSetter , conn_setter : ConnSetter , power_factor : float , ) -> None : \"\"\"Constructor for `ConstantPowerFactorSimpleLoadGeometryLoadBuilder` class. Refer to base class for base arguments. Args: power_factor (float): Power factor \"\"\" super () . __init__ ( geometry , phaseallocator , kv_setter , conn_setter , ConstantPowerFactorLoad (), ) self . power_factor = power_factor set_power_data () Refer to base class for more details. Source code in shift\\load_builder.py 507 508 509 510 def set_power_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . pf = self . power_factor self . load . kw = self . geometry . kw DefaultConnSetter Bases: ConnSetter Class for handling default connection type. Source code in shift\\load_builder.py 335 336 337 338 339 340 341 342 343 344 class DefaultConnSetter ( ConnSetter ): \"\"\"Class for handling default connection type.\"\"\" def get_conn ( self , load : Load ) -> LoadConnection : \"\"\"Refer to the base class for more details.\"\"\" return ( LoadConnection . DELTA if load . num_phase == NumPhase . TWO else LoadConnection . STAR ) get_conn ( load ) Refer to the base class for more details. Source code in shift\\load_builder.py 338 339 340 341 342 343 344 def get_conn ( self , load : Load ) -> LoadConnection : \"\"\"Refer to the base class for more details.\"\"\" return ( LoadConnection . DELTA if load . num_phase == NumPhase . TWO else LoadConnection . STAR ) GeometryLoadBuilder Bases: LoadBuilder Concrete implementation for converting geometry to load. Attributes: Name Type Description geometry Geometry Geometry instance phaseallocator PhaseAllocator PhaseAllocator instance kv_setter VoltageSetter VoltageSetter instance conn_setter conn_setter ConnSetter Instance load Load Load instance Source code in shift\\load_builder.py 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 class GeometryLoadBuilder ( LoadBuilder ): \"\"\"Concrete implementation for converting geometry to load. Attributes: geometry (Geometry): Geometry instance phaseallocator (PhaseAllocator): PhaseAllocator instance kv_setter (VoltageSetter): VoltageSetter instance conn_setter (conn_setter): ConnSetter Instance load (Load): Load instance \"\"\" def __init__ ( self , geometry : Geometry , phaseallocator : PhaseAllocator , kv_setter : VoltageSetter , conn_setter : ConnSetter , load : Load , ) -> None : \"\"\"Constructor for GeometryLoadBuilder class. Args: geometry (Geometry): Geometry instance phaseallocator (PhaseAllocator): PhaseAllocator instance kv_setter (VoltageSetter): VoltageSetter instance conn_setter (conn_setter): ConnSetter Instance load (Load): Load instance \"\"\" self . geometry = geometry self . load = load self . phase_allocator = phaseallocator self . kvsetter = kv_setter self . connsetter = conn_setter def set_name_and_location ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . name = ( f \" { self . geometry . longitude } _ { self . geometry . latitude } _load\" ) self . load . latitude = self . geometry . latitude self . load . longitude = self . geometry . longitude def set_power_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" pass def set_phase_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . phase = self . phase_allocator . get_phase ( self . geometry ) self . load . num_phase = self . phase_allocator . get_num_phase ( self . geometry ) def set_kv_and_conn ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . kv = self . kvsetter . get_kv ( self . load ) self . load . conn_type = self . connsetter . get_conn ( self . load ) __init__ ( geometry , phaseallocator , kv_setter , conn_setter , load ) Constructor for GeometryLoadBuilder class. Parameters: Name Type Description Default geometry Geometry Geometry instance required phaseallocator PhaseAllocator PhaseAllocator instance required kv_setter VoltageSetter VoltageSetter instance required conn_setter conn_setter ConnSetter Instance required load Load Load instance required Source code in shift\\load_builder.py 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def __init__ ( self , geometry : Geometry , phaseallocator : PhaseAllocator , kv_setter : VoltageSetter , conn_setter : ConnSetter , load : Load , ) -> None : \"\"\"Constructor for GeometryLoadBuilder class. Args: geometry (Geometry): Geometry instance phaseallocator (PhaseAllocator): PhaseAllocator instance kv_setter (VoltageSetter): VoltageSetter instance conn_setter (conn_setter): ConnSetter Instance load (Load): Load instance \"\"\" self . geometry = geometry self . load = load self . phase_allocator = phaseallocator self . kvsetter = kv_setter self . connsetter = conn_setter set_kv_and_conn () Refer to base class for more details. Source code in shift\\load_builder.py 423 424 425 426 def set_kv_and_conn ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . kv = self . kvsetter . get_kv ( self . load ) self . load . conn_type = self . connsetter . get_conn ( self . load ) set_name_and_location () Refer to base class for more details. Source code in shift\\load_builder.py 406 407 408 409 410 411 412 def set_name_and_location ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . name = ( f \" { self . geometry . longitude } _ { self . geometry . latitude } _load\" ) self . load . latitude = self . geometry . latitude self . load . longitude = self . geometry . longitude set_phase_data () Refer to base class for more details. Source code in shift\\load_builder.py 418 419 420 421 def set_phase_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . phase = self . phase_allocator . get_phase ( self . geometry ) self . load . num_phase = self . phase_allocator . get_num_phase ( self . geometry ) set_power_data () Refer to base class for more details. Source code in shift\\load_builder.py 414 415 416 def set_power_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" pass LoadBuilder Bases: ABC Builder interface for converting geometries to power system loads. Source code in shift\\load_builder.py 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 class LoadBuilder ( ABC ): \"\"\"Builder interface for converting geometries to power system loads.\"\"\" @abstractmethod def set_name_and_location ( self ) -> None : \"\"\"Abstract method for setting name and location.\"\"\" pass @abstractmethod def set_power_data ( self ) -> None : \"\"\"Abstract method for setting the power consumption for load.\"\"\" pass @abstractmethod def set_phase_data ( self ) -> None : \"\"\"Abstract method for setting phase to load.\"\"\" pass @abstractmethod def set_kv_and_conn ( self ) -> None : \"\"\"Abstract methid for setting kv and connection.\"\"\" pass set_kv_and_conn () abstractmethod Abstract methid for setting kv and connection. Source code in shift\\load_builder.py 365 366 367 368 @abstractmethod def set_kv_and_conn ( self ) -> None : \"\"\"Abstract methid for setting kv and connection.\"\"\" pass set_name_and_location () abstractmethod Abstract method for setting name and location. Source code in shift\\load_builder.py 350 351 352 353 @abstractmethod def set_name_and_location ( self ) -> None : \"\"\"Abstract method for setting name and location.\"\"\" pass set_phase_data () abstractmethod Abstract method for setting phase to load. Source code in shift\\load_builder.py 360 361 362 363 @abstractmethod def set_phase_data ( self ) -> None : \"\"\"Abstract method for setting phase to load.\"\"\" pass set_power_data () abstractmethod Abstract method for setting the power consumption for load. Source code in shift\\load_builder.py 355 356 357 358 @abstractmethod def set_power_data ( self ) -> None : \"\"\"Abstract method for setting the power consumption for load.\"\"\" pass LoadBuilderEngineer Director for building loads. Attributes: Name Type Description builder LoadBuilder LoadBuilder instance Source code in shift\\load_builder.py 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 class LoadBuilderEngineer : \"\"\"Director for building loads. Attributes: builder (LoadBuilder): LoadBuilder instance \"\"\" def __init__ ( self , builder : LoadBuilder ) -> None : \"\"\"Constructor for `LoadBuilderEngineer` class. Args: builder (LoadBuilder): LoadBuilder instance \"\"\" self . builder = builder self . builder . set_name_and_location () self . builder . set_power_data () self . builder . set_phase_data () self . builder . set_kv_and_conn () def get_load ( self ) -> Load : \"\"\"Returns a `Load` instance.\"\"\" return self . builder . load __init__ ( builder ) Constructor for LoadBuilderEngineer class. Parameters: Name Type Description Default builder LoadBuilder LoadBuilder instance required Source code in shift\\load_builder.py 520 521 522 523 524 525 526 527 528 529 530 def __init__ ( self , builder : LoadBuilder ) -> None : \"\"\"Constructor for `LoadBuilderEngineer` class. Args: builder (LoadBuilder): LoadBuilder instance \"\"\" self . builder = builder self . builder . set_name_and_location () self . builder . set_power_data () self . builder . set_phase_data () self . builder . set_kv_and_conn () get_load () Returns a Load instance. Source code in shift\\load_builder.py 532 533 534 def get_load ( self ) -> Load : \"\"\"Returns a `Load` instance.\"\"\" return self . builder . load PhaseAllocator Bases: ABC Interface for allocating phase. Source code in shift\\load_builder.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 class PhaseAllocator ( ABC ): \"\"\"Interface for allocating phase.\"\"\" @abstractmethod def get_phase ( self , geometry : Geometry ) -> Phase : \"\"\"Abstract method for getting a phase. Args: geometry (Geometry): Geometry instance for which phase is to be determined Returns: Phase: Phase instance for the geometry \"\"\" pass @abstractmethod def get_num_phase ( self , geometry : Geometry ) -> NumPhase : \"\"\"Abstract method for getting number of phase. Args: geometry (Geometry): Geometry instance for which num_phase is to be determined Returns: NumPhase: NumPhase instance for the geometry \"\"\" pass get_num_phase ( geometry ) abstractmethod Abstract method for getting number of phase. Parameters: Name Type Description Default geometry Geometry Geometry instance for which num_phase is to be determined required Returns: Name Type Description NumPhase NumPhase NumPhase instance for the geometry Source code in shift\\load_builder.py 169 170 171 172 173 174 175 176 177 178 179 @abstractmethod def get_num_phase ( self , geometry : Geometry ) -> NumPhase : \"\"\"Abstract method for getting number of phase. Args: geometry (Geometry): Geometry instance for which num_phase is to be determined Returns: NumPhase: NumPhase instance for the geometry \"\"\" pass get_phase ( geometry ) abstractmethod Abstract method for getting a phase. Parameters: Name Type Description Default geometry Geometry Geometry instance for which phase is to be determined required Returns: Name Type Description Phase Phase Phase instance for the geometry Source code in shift\\load_builder.py 157 158 159 160 161 162 163 164 165 166 167 @abstractmethod def get_phase ( self , geometry : Geometry ) -> Phase : \"\"\"Abstract method for getting a phase. Args: geometry (Geometry): Geometry instance for which phase is to be determined Returns: Phase: Phase instance for the geometry \"\"\" pass PiecewiseBuildingAreaToConsumptionConverter Bases: BuildingAreaToConsumptionConverter Class for handling computation of power consumption using piecewide linear function. Attributes: Name Type Description curve List [ list ] Piecewise linear function e.g. [[1,2], [3,4]] Source code in shift\\load_builder.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class PiecewiseBuildingAreaToConsumptionConverter ( BuildingAreaToConsumptionConverter ): \"\"\"Class for handling computation of power consumption using piecewide linear function. Attributes: curve (List[list]): Piecewise linear function e.g. [[1,2], [3,4]] \"\"\" def __init__ ( self , area_to_kw_curve : List [ list ]) -> None : \"\"\"Constructor for `PiecewiseBuildingAreaToConsumptionConverter` class. Args: area_to_kw_curve (List[list]): Piecewise linear function e.g. [[1,2], [3,4]] \"\"\" self . curve = area_to_kw_curve def convert ( self , area : float ) -> float : \"\"\"Refer to base class for more details.\"\"\" return get_point_from_curve ( self . curve , area ) __init__ ( area_to_kw_curve ) Constructor for PiecewiseBuildingAreaToConsumptionConverter class. Parameters: Name Type Description Default area_to_kw_curve List [ list ] Piecewise linear function e.g. [[1,2], [3,4]] required Source code in shift\\load_builder.py 93 94 95 96 97 98 99 def __init__ ( self , area_to_kw_curve : List [ list ]) -> None : \"\"\"Constructor for `PiecewiseBuildingAreaToConsumptionConverter` class. Args: area_to_kw_curve (List[list]): Piecewise linear function e.g. [[1,2], [3,4]] \"\"\" self . curve = area_to_kw_curve convert ( area ) Refer to base class for more details. Source code in shift\\load_builder.py 101 102 103 def convert ( self , area : float ) -> float : \"\"\"Refer to base class for more details.\"\"\" return get_point_from_curve ( self . curve , area ) ProportionalBuildingAreaToConsumptionConverter Bases: BuildingAreaToConsumptionConverter Class for handling computation of power consumption using proportional allocation method. Attributes: Name Type Description min_kw float Minimum kw to be assigned max_kw float Maximum kw to be assigned max_area float Maximum area of all the buildings min_area float Minimum area of all the buildings Source code in shift\\load_builder.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 class ProportionalBuildingAreaToConsumptionConverter ( BuildingAreaToConsumptionConverter ): \"\"\"Class for handling computation of power consumption using proportional allocation method. Attributes: min_kw (float): Minimum kw to be assigned max_kw (float): Maximum kw to be assigned max_area (float): Maximum area of all the buildings min_area (float): Minimum area of all the buildings \"\"\" def __init__ ( self , min_kw : float , max_kw : float , max_area : float , min_area : float ) -> None : \"\"\"Constructor for `ProportionalBuildingAreaToConsumptionConverter` class. Args: min_kw (float): Minimum kw to be assigned max_kw (float): Maximum kw to be assigned max_area (float): Maximum area of all the buildings min_area (float): Minimum area of all the buildings Raises: InvalidInputError: If min_kw is greater than or equal to max_kw \"\"\" self . min_kw = min_kw self . max_kw = max_kw self . max_area = max_area self . min_area = min_area if self . min_kw >= self . max_kw : raise InvalidInputError ( f \"Min kW { min_kw } is greater than or equal to Max kW { max_kw } \" ) def convert ( self , area : float ) -> float : \"\"\"Refer to base class for more details.\"\"\" if self . max_area != 0 : kw = self . min_kw + ( self . max_kw - self . min_kw ) * ( area - self . min_area ) / ( self . max_area - self . min_area ) else : kw = self . min_kw return kw __init__ ( min_kw , max_kw , max_area , min_area ) Constructor for ProportionalBuildingAreaToConsumptionConverter class. Parameters: Name Type Description Default min_kw float Minimum kw to be assigned required max_kw float Maximum kw to be assigned required max_area float Maximum area of all the buildings required min_area float Minimum area of all the buildings required Raises: Type Description InvalidInputError If min_kw is greater than or equal to max_kw Source code in shift\\load_builder.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def __init__ ( self , min_kw : float , max_kw : float , max_area : float , min_area : float ) -> None : \"\"\"Constructor for `ProportionalBuildingAreaToConsumptionConverter` class. Args: min_kw (float): Minimum kw to be assigned max_kw (float): Maximum kw to be assigned max_area (float): Maximum area of all the buildings min_area (float): Minimum area of all the buildings Raises: InvalidInputError: If min_kw is greater than or equal to max_kw \"\"\" self . min_kw = min_kw self . max_kw = max_kw self . max_area = max_area self . min_area = min_area if self . min_kw >= self . max_kw : raise InvalidInputError ( f \"Min kW { min_kw } is greater than or equal to Max kW { max_kw } \" ) convert ( area ) Refer to base class for more details. Source code in shift\\load_builder.py 142 143 144 145 146 147 148 149 150 151 def convert ( self , area : float ) -> float : \"\"\"Refer to base class for more details.\"\"\" if self . max_area != 0 : kw = self . min_kw + ( self . max_kw - self . min_kw ) * ( area - self . min_area ) / ( self . max_area - self . min_area ) else : kw = self . min_kw return kw RandomPhaseAllocator Bases: PhaseAllocator Allocates the phase to all geometries uniformly randomly. Attributes: Name Type Description pct_single_phases float Percentage of single phase geometries pct_two_phases float Percentage of two phase geometries pct_three_phases float Percentage of three phase geometries geometries List [ Geometry ] List of Geometry objects geometry_to_phase dict A dictionary holding the phase for geometries Source code in shift\\load_builder.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class RandomPhaseAllocator ( PhaseAllocator ): \"\"\"Allocates the phase to all geometries uniformly randomly. Attributes: pct_single_phases (float): Percentage of single phase geometries pct_two_phases (float): Percentage of two phase geometries pct_three_phases (float): Percentage of three phase geometries geometries (List[Geometry]): List of Geometry objects geometry_to_phase (dict): A dictionary holding the phase for geometries \"\"\" def __init__ ( self , pct_single_phases : float , pct_two_phases : float , pct_three_phases : float , geometries : List [ Geometry ], ) -> None : \"\"\"Constructor for `RandomPhaseAllocator` class. Args: pct_single_phases (float): Percentage of single phase geometries pct_two_phases (float): Percentage of two phase geometries pct_three_phases (float): Percentage of three phase geometries geometries (List[Geometry]): List of Geometry objects Raises: PercentageSumNotHundred: If the sume of percentages is not 100 \"\"\" self . pct_single_phases = pct_single_phases self . pct_two_phases = pct_two_phases self . pct_three_phases = pct_three_phases self . geometries = geometries if pct_single_phases + pct_two_phases + pct_three_phases != 100 : raise PercentageSumNotHundred ( pct_single_phases + pct_two_phases + pct_three_phases ) random . shuffle ( self . geometries ) three_phase_geometries = self . geometries [ : int ( len ( self . geometries ) * self . pct_three_phases / 100 ) ] self . geometry_to_phase = { g : Phase . ABCN for g in three_phase_geometries } self . geometry_to_numphase = { g : NumPhase . THREE for g in three_phase_geometries } single_phases = [ Phase . AN , Phase . BN , Phase . CN ] two_phases = [ Phase . AB , Phase . BC , Phase . CA ] two_phase_geometries = self . geometries [ int ( len ( self . geometries ) * self . pct_three_phases / 100 ) : int ( len ( self . geometries ) * self . pct_two_phases / 100 ) ] self . geometry_to_phase . update ( { g : random . choice ( two_phases ) for g in two_phase_geometries } ) self . geometry_to_numphase . update ( { g : NumPhase . TWO for g in two_phase_geometries } ) single_phase_geometries = [ g for g in self . geometries if g not in self . geometry_to_phase ] self . geometry_to_phase . update ( { g : random . choice ( single_phases ) for g in single_phase_geometries } ) self . geometry_to_numphase . update ( { g : NumPhase . SINGLE for g in single_phase_geometries } ) def get_phase ( self , geometry : Geometry ) -> Phase : \"\"\"Refer to the base class for more details.\"\"\" return self . geometry_to_phase [ geometry ] def get_num_phase ( self , geometry : Geometry ) -> NumPhase : \"\"\"Refer to the base class for more details.\"\"\" return self . geometry_to_numphase [ geometry ] __init__ ( pct_single_phases , pct_two_phases , pct_three_phases , geometries ) Constructor for RandomPhaseAllocator class. Parameters: Name Type Description Default pct_single_phases float Percentage of single phase geometries required pct_two_phases float Percentage of two phase geometries required pct_three_phases float Percentage of three phase geometries required geometries List [ Geometry ] List of Geometry objects required Raises: Type Description PercentageSumNotHundred If the sume of percentages is not 100 Source code in shift\\load_builder.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def __init__ ( self , pct_single_phases : float , pct_two_phases : float , pct_three_phases : float , geometries : List [ Geometry ], ) -> None : \"\"\"Constructor for `RandomPhaseAllocator` class. Args: pct_single_phases (float): Percentage of single phase geometries pct_two_phases (float): Percentage of two phase geometries pct_three_phases (float): Percentage of three phase geometries geometries (List[Geometry]): List of Geometry objects Raises: PercentageSumNotHundred: If the sume of percentages is not 100 \"\"\" self . pct_single_phases = pct_single_phases self . pct_two_phases = pct_two_phases self . pct_three_phases = pct_three_phases self . geometries = geometries if pct_single_phases + pct_two_phases + pct_three_phases != 100 : raise PercentageSumNotHundred ( pct_single_phases + pct_two_phases + pct_three_phases ) random . shuffle ( self . geometries ) three_phase_geometries = self . geometries [ : int ( len ( self . geometries ) * self . pct_three_phases / 100 ) ] self . geometry_to_phase = { g : Phase . ABCN for g in three_phase_geometries } self . geometry_to_numphase = { g : NumPhase . THREE for g in three_phase_geometries } single_phases = [ Phase . AN , Phase . BN , Phase . CN ] two_phases = [ Phase . AB , Phase . BC , Phase . CA ] two_phase_geometries = self . geometries [ int ( len ( self . geometries ) * self . pct_three_phases / 100 ) : int ( len ( self . geometries ) * self . pct_two_phases / 100 ) ] self . geometry_to_phase . update ( { g : random . choice ( two_phases ) for g in two_phase_geometries } ) self . geometry_to_numphase . update ( { g : NumPhase . TWO for g in two_phase_geometries } ) single_phase_geometries = [ g for g in self . geometries if g not in self . geometry_to_phase ] self . geometry_to_phase . update ( { g : random . choice ( single_phases ) for g in single_phase_geometries } ) self . geometry_to_numphase . update ( { g : NumPhase . SINGLE for g in single_phase_geometries } ) get_num_phase ( geometry ) Refer to the base class for more details. Source code in shift\\load_builder.py 261 262 263 def get_num_phase ( self , geometry : Geometry ) -> NumPhase : \"\"\"Refer to the base class for more details.\"\"\" return self . geometry_to_numphase [ geometry ] get_phase ( geometry ) Refer to the base class for more details. Source code in shift\\load_builder.py 257 258 259 def get_phase ( self , geometry : Geometry ) -> Phase : \"\"\"Refer to the base class for more details.\"\"\" return self . geometry_to_phase [ geometry ] SimpleVoltageSetter Simple voltage setter for setting kv for loads. Attributes: Name Type Description line_to_line_voltage float Line to line voltage in kV voltage_dict dict NumPhase to voltage mapper Source code in shift\\load_builder.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 class SimpleVoltageSetter : \"\"\"Simple voltage setter for setting kv for loads. Attributes: line_to_line_voltage (float): Line to line voltage in kV voltage_dict (dict): NumPhase to voltage mapper \"\"\" def __init__ ( self , line_to_line_voltage : float ) -> None : \"\"\"Constructor for `SimpleVoltageSetter` class. Args: line_to_line_voltage (float): Line to line voltage in kV Raises: NegativeKVError: If the `line_to_line_voltage` is negative ZeroKVError: if the `line_to_line_voltage` is 0 \"\"\" self . line_to_line_voltage = line_to_line_voltage if self . line_to_line_voltage < 0 : raise NegativeKVError ( self . line_to_line_voltage ) if self . line_to_line_voltage == 0 : raise ZeroKVError () self . voltage_dict = { NumPhase . SINGLE : round ( self . line_to_line_voltage / math . sqrt ( 3 ), 3 ), NumPhase . TWO : self . line_to_line_voltage , NumPhase . THREE : self . line_to_line_voltage , } def get_kv ( self , load : Load ) -> float : \"\"\"Refer to the base class for more details.\"\"\" return self . voltage_dict [ load . num_phase ] __init__ ( line_to_line_voltage ) Constructor for SimpleVoltageSetter class. Parameters: Name Type Description Default line_to_line_voltage float Line to line voltage in kV required Raises: Type Description NegativeKVError If the line_to_line_voltage is negative ZeroKVError if the line_to_line_voltage is 0 Source code in shift\\load_builder.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def __init__ ( self , line_to_line_voltage : float ) -> None : \"\"\"Constructor for `SimpleVoltageSetter` class. Args: line_to_line_voltage (float): Line to line voltage in kV Raises: NegativeKVError: If the `line_to_line_voltage` is negative ZeroKVError: if the `line_to_line_voltage` is 0 \"\"\" self . line_to_line_voltage = line_to_line_voltage if self . line_to_line_voltage < 0 : raise NegativeKVError ( self . line_to_line_voltage ) if self . line_to_line_voltage == 0 : raise ZeroKVError () self . voltage_dict = { NumPhase . SINGLE : round ( self . line_to_line_voltage / math . sqrt ( 3 ), 3 ), NumPhase . TWO : self . line_to_line_voltage , NumPhase . THREE : self . line_to_line_voltage , } get_kv ( load ) Refer to the base class for more details. Source code in shift\\load_builder.py 314 315 316 def get_kv ( self , load : Load ) -> float : \"\"\"Refer to the base class for more details.\"\"\" return self . voltage_dict [ load . num_phase ] VoltageSetter Bases: ABC Interface for setting voltage for loads. Source code in shift\\load_builder.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 class VoltageSetter ( ABC ): \"\"\"Interface for setting voltage for loads.\"\"\" @abstractmethod def get_kv ( self , load : Load ) -> float : \"\"\"Abstract method for getting voltage level for load object. Args: load (Load): Load instance Returns: float: Voltage in kV for load object \"\"\" pass get_kv ( load ) abstractmethod Abstract method for getting voltage level for load object. Parameters: Name Type Description Default load Load Load instance required Returns: Name Type Description float float Voltage in kV for load object Source code in shift\\load_builder.py 269 270 271 272 273 274 275 276 277 278 279 @abstractmethod def get_kv ( self , load : Load ) -> float : \"\"\"Abstract method for getting voltage level for load object. Args: load (Load): Load instance Returns: float: Voltage in kV for load object \"\"\" pass","title":"load_builder"},{"location":"load_builder/#shift.load_builder.BuildingAreaToConsumptionConverter","text":"Bases: ABC Interface for computing power consumption from building area. Source code in shift\\load_builder.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class BuildingAreaToConsumptionConverter ( ABC ): \"\"\"Interface for computing power consumption from building area.\"\"\" @abstractmethod def convert ( self , area : float ) -> float : \"\"\"Abstract method for computing the power consumption. Args: area (float): Building area Returns: float: Power consumption in kW \"\"\" pass","title":"BuildingAreaToConsumptionConverter"},{"location":"load_builder/#shift.load_builder.BuildingAreaToConsumptionConverter.convert","text":"Abstract method for computing the power consumption. Parameters: Name Type Description Default area float Building area required Returns: Name Type Description float float Power consumption in kW Source code in shift\\load_builder.py 71 72 73 74 75 76 77 78 79 80 81 @abstractmethod def convert ( self , area : float ) -> float : \"\"\"Abstract method for computing the power consumption. Args: area (float): Building area Returns: float: Power consumption in kW \"\"\" pass","title":"convert()"},{"location":"load_builder/#shift.load_builder.ConnSetter","text":"Bases: ABC Interface for setting the connection type for load object. Source code in shift\\load_builder.py 319 320 321 322 323 324 325 326 327 328 329 330 331 332 class ConnSetter ( ABC ): \"\"\"Interface for setting the connection type for load object.\"\"\" @abstractmethod def get_conn ( self , load : Load ) -> LoadConnection : \"\"\"Abstract method for setting connection type for load object. Args: load (Load): Load instance Returns: LoadConnection: Connection type for the load \"\"\" pass","title":"ConnSetter"},{"location":"load_builder/#shift.load_builder.ConnSetter.get_conn","text":"Abstract method for setting connection type for load object. Parameters: Name Type Description Default load Load Load instance required Returns: Name Type Description LoadConnection LoadConnection Connection type for the load Source code in shift\\load_builder.py 322 323 324 325 326 327 328 329 330 331 332 @abstractmethod def get_conn ( self , load : Load ) -> LoadConnection : \"\"\"Abstract method for setting connection type for load object. Args: load (Load): Load instance Returns: LoadConnection: Connection type for the load \"\"\" pass","title":"get_conn()"},{"location":"load_builder/#shift.load_builder.ConstantPowerFactorBuildingGeometryLoadBuilder","text":"Bases: GeometryLoadBuilder Concerete implementation for building constant power factor type load from geometry object. Refer to the base class for base attributes. Attributes: Name Type Description power_factor float Power factor area_converter BuildingAreaToConsumptionConverter BuildingAreaToConsumptionConverter instance Source code in shift\\load_builder.py 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 class ConstantPowerFactorBuildingGeometryLoadBuilder ( GeometryLoadBuilder ): \"\"\"Concerete implementation for building constant power factor type load from geometry object. Refer to the base class for base attributes. Attributes: power_factor (float): Power factor area_converter (BuildingAreaToConsumptionConverter): BuildingAreaToConsumptionConverter instance \"\"\" def __init__ ( self , geometry : Geometry , phaseallocator : PhaseAllocator , area_converter : BuildingAreaToConsumptionConverter , kv_setter : VoltageSetter , conn_setter : ConnSetter , power_factor : float , ) -> None : \"\"\"Constructor for `ConstantPowerFactorBuildingGeometryLoadBuilder` class. Refer to base class for base arguments. Args: area_converter (BuildingAreaToConsumptionConverter): BuildingAreaToConsumptionConverter instance power_factor (float): Power factor \"\"\" super () . __init__ ( geometry , phaseallocator , kv_setter , conn_setter , ConstantPowerFactorLoad (), ) self . power_factor = power_factor self . area_converter = area_converter def set_power_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . pf = self . power_factor self . load . kw = self . area_converter . convert ( self . geometry . area )","title":"ConstantPowerFactorBuildingGeometryLoadBuilder"},{"location":"load_builder/#shift.load_builder.ConstantPowerFactorBuildingGeometryLoadBuilder.__init__","text":"Constructor for ConstantPowerFactorBuildingGeometryLoadBuilder class. Refer to base class for base arguments. Parameters: Name Type Description Default area_converter BuildingAreaToConsumptionConverter BuildingAreaToConsumptionConverter instance required power_factor float Power factor required Source code in shift\\load_builder.py 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 def __init__ ( self , geometry : Geometry , phaseallocator : PhaseAllocator , area_converter : BuildingAreaToConsumptionConverter , kv_setter : VoltageSetter , conn_setter : ConnSetter , power_factor : float , ) -> None : \"\"\"Constructor for `ConstantPowerFactorBuildingGeometryLoadBuilder` class. Refer to base class for base arguments. Args: area_converter (BuildingAreaToConsumptionConverter): BuildingAreaToConsumptionConverter instance power_factor (float): Power factor \"\"\" super () . __init__ ( geometry , phaseallocator , kv_setter , conn_setter , ConstantPowerFactorLoad (), ) self . power_factor = power_factor self . area_converter = area_converter","title":"__init__()"},{"location":"load_builder/#shift.load_builder.ConstantPowerFactorBuildingGeometryLoadBuilder.set_power_data","text":"Refer to base class for more details. Source code in shift\\load_builder.py 467 468 469 470 def set_power_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . pf = self . power_factor self . load . kw = self . area_converter . convert ( self . geometry . area )","title":"set_power_data()"},{"location":"load_builder/#shift.load_builder.ConstantPowerFactorSimpleLoadGeometryLoadBuilder","text":"Bases: GeometryLoadBuilder Concerete implementation for building constant power factor type load from simple load point geometry object. Refer to base class for base attributes. Attributes: Name Type Description power_factor float Power factor Source code in shift\\load_builder.py 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 class ConstantPowerFactorSimpleLoadGeometryLoadBuilder ( GeometryLoadBuilder ): \"\"\"Concerete implementation for building constant power factor type load from simple load point geometry object. Refer to base class for base attributes. Attributes: power_factor (float): Power factor \"\"\" def __init__ ( self , geometry : Geometry , phaseallocator : PhaseAllocator , kv_setter : VoltageSetter , conn_setter : ConnSetter , power_factor : float , ) -> None : \"\"\"Constructor for `ConstantPowerFactorSimpleLoadGeometryLoadBuilder` class. Refer to base class for base arguments. Args: power_factor (float): Power factor \"\"\" super () . __init__ ( geometry , phaseallocator , kv_setter , conn_setter , ConstantPowerFactorLoad (), ) self . power_factor = power_factor def set_power_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . pf = self . power_factor self . load . kw = self . geometry . kw","title":"ConstantPowerFactorSimpleLoadGeometryLoadBuilder"},{"location":"load_builder/#shift.load_builder.ConstantPowerFactorSimpleLoadGeometryLoadBuilder.__init__","text":"Constructor for ConstantPowerFactorSimpleLoadGeometryLoadBuilder class. Refer to base class for base arguments. Parameters: Name Type Description Default power_factor float Power factor required Source code in shift\\load_builder.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 def __init__ ( self , geometry : Geometry , phaseallocator : PhaseAllocator , kv_setter : VoltageSetter , conn_setter : ConnSetter , power_factor : float , ) -> None : \"\"\"Constructor for `ConstantPowerFactorSimpleLoadGeometryLoadBuilder` class. Refer to base class for base arguments. Args: power_factor (float): Power factor \"\"\" super () . __init__ ( geometry , phaseallocator , kv_setter , conn_setter , ConstantPowerFactorLoad (), ) self . power_factor = power_factor","title":"__init__()"},{"location":"load_builder/#shift.load_builder.ConstantPowerFactorSimpleLoadGeometryLoadBuilder.set_power_data","text":"Refer to base class for more details. Source code in shift\\load_builder.py 507 508 509 510 def set_power_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . pf = self . power_factor self . load . kw = self . geometry . kw","title":"set_power_data()"},{"location":"load_builder/#shift.load_builder.DefaultConnSetter","text":"Bases: ConnSetter Class for handling default connection type. Source code in shift\\load_builder.py 335 336 337 338 339 340 341 342 343 344 class DefaultConnSetter ( ConnSetter ): \"\"\"Class for handling default connection type.\"\"\" def get_conn ( self , load : Load ) -> LoadConnection : \"\"\"Refer to the base class for more details.\"\"\" return ( LoadConnection . DELTA if load . num_phase == NumPhase . TWO else LoadConnection . STAR )","title":"DefaultConnSetter"},{"location":"load_builder/#shift.load_builder.DefaultConnSetter.get_conn","text":"Refer to the base class for more details. Source code in shift\\load_builder.py 338 339 340 341 342 343 344 def get_conn ( self , load : Load ) -> LoadConnection : \"\"\"Refer to the base class for more details.\"\"\" return ( LoadConnection . DELTA if load . num_phase == NumPhase . TWO else LoadConnection . STAR )","title":"get_conn()"},{"location":"load_builder/#shift.load_builder.GeometryLoadBuilder","text":"Bases: LoadBuilder Concrete implementation for converting geometry to load. Attributes: Name Type Description geometry Geometry Geometry instance phaseallocator PhaseAllocator PhaseAllocator instance kv_setter VoltageSetter VoltageSetter instance conn_setter conn_setter ConnSetter Instance load Load Load instance Source code in shift\\load_builder.py 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 class GeometryLoadBuilder ( LoadBuilder ): \"\"\"Concrete implementation for converting geometry to load. Attributes: geometry (Geometry): Geometry instance phaseallocator (PhaseAllocator): PhaseAllocator instance kv_setter (VoltageSetter): VoltageSetter instance conn_setter (conn_setter): ConnSetter Instance load (Load): Load instance \"\"\" def __init__ ( self , geometry : Geometry , phaseallocator : PhaseAllocator , kv_setter : VoltageSetter , conn_setter : ConnSetter , load : Load , ) -> None : \"\"\"Constructor for GeometryLoadBuilder class. Args: geometry (Geometry): Geometry instance phaseallocator (PhaseAllocator): PhaseAllocator instance kv_setter (VoltageSetter): VoltageSetter instance conn_setter (conn_setter): ConnSetter Instance load (Load): Load instance \"\"\" self . geometry = geometry self . load = load self . phase_allocator = phaseallocator self . kvsetter = kv_setter self . connsetter = conn_setter def set_name_and_location ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . name = ( f \" { self . geometry . longitude } _ { self . geometry . latitude } _load\" ) self . load . latitude = self . geometry . latitude self . load . longitude = self . geometry . longitude def set_power_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" pass def set_phase_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . phase = self . phase_allocator . get_phase ( self . geometry ) self . load . num_phase = self . phase_allocator . get_num_phase ( self . geometry ) def set_kv_and_conn ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . kv = self . kvsetter . get_kv ( self . load ) self . load . conn_type = self . connsetter . get_conn ( self . load )","title":"GeometryLoadBuilder"},{"location":"load_builder/#shift.load_builder.GeometryLoadBuilder.__init__","text":"Constructor for GeometryLoadBuilder class. Parameters: Name Type Description Default geometry Geometry Geometry instance required phaseallocator PhaseAllocator PhaseAllocator instance required kv_setter VoltageSetter VoltageSetter instance required conn_setter conn_setter ConnSetter Instance required load Load Load instance required Source code in shift\\load_builder.py 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def __init__ ( self , geometry : Geometry , phaseallocator : PhaseAllocator , kv_setter : VoltageSetter , conn_setter : ConnSetter , load : Load , ) -> None : \"\"\"Constructor for GeometryLoadBuilder class. Args: geometry (Geometry): Geometry instance phaseallocator (PhaseAllocator): PhaseAllocator instance kv_setter (VoltageSetter): VoltageSetter instance conn_setter (conn_setter): ConnSetter Instance load (Load): Load instance \"\"\" self . geometry = geometry self . load = load self . phase_allocator = phaseallocator self . kvsetter = kv_setter self . connsetter = conn_setter","title":"__init__()"},{"location":"load_builder/#shift.load_builder.GeometryLoadBuilder.set_kv_and_conn","text":"Refer to base class for more details. Source code in shift\\load_builder.py 423 424 425 426 def set_kv_and_conn ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . kv = self . kvsetter . get_kv ( self . load ) self . load . conn_type = self . connsetter . get_conn ( self . load )","title":"set_kv_and_conn()"},{"location":"load_builder/#shift.load_builder.GeometryLoadBuilder.set_name_and_location","text":"Refer to base class for more details. Source code in shift\\load_builder.py 406 407 408 409 410 411 412 def set_name_and_location ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . name = ( f \" { self . geometry . longitude } _ { self . geometry . latitude } _load\" ) self . load . latitude = self . geometry . latitude self . load . longitude = self . geometry . longitude","title":"set_name_and_location()"},{"location":"load_builder/#shift.load_builder.GeometryLoadBuilder.set_phase_data","text":"Refer to base class for more details. Source code in shift\\load_builder.py 418 419 420 421 def set_phase_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . load . phase = self . phase_allocator . get_phase ( self . geometry ) self . load . num_phase = self . phase_allocator . get_num_phase ( self . geometry )","title":"set_phase_data()"},{"location":"load_builder/#shift.load_builder.GeometryLoadBuilder.set_power_data","text":"Refer to base class for more details. Source code in shift\\load_builder.py 414 415 416 def set_power_data ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" pass","title":"set_power_data()"},{"location":"load_builder/#shift.load_builder.LoadBuilder","text":"Bases: ABC Builder interface for converting geometries to power system loads. Source code in shift\\load_builder.py 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 class LoadBuilder ( ABC ): \"\"\"Builder interface for converting geometries to power system loads.\"\"\" @abstractmethod def set_name_and_location ( self ) -> None : \"\"\"Abstract method for setting name and location.\"\"\" pass @abstractmethod def set_power_data ( self ) -> None : \"\"\"Abstract method for setting the power consumption for load.\"\"\" pass @abstractmethod def set_phase_data ( self ) -> None : \"\"\"Abstract method for setting phase to load.\"\"\" pass @abstractmethod def set_kv_and_conn ( self ) -> None : \"\"\"Abstract methid for setting kv and connection.\"\"\" pass","title":"LoadBuilder"},{"location":"load_builder/#shift.load_builder.LoadBuilder.set_kv_and_conn","text":"Abstract methid for setting kv and connection. Source code in shift\\load_builder.py 365 366 367 368 @abstractmethod def set_kv_and_conn ( self ) -> None : \"\"\"Abstract methid for setting kv and connection.\"\"\" pass","title":"set_kv_and_conn()"},{"location":"load_builder/#shift.load_builder.LoadBuilder.set_name_and_location","text":"Abstract method for setting name and location. Source code in shift\\load_builder.py 350 351 352 353 @abstractmethod def set_name_and_location ( self ) -> None : \"\"\"Abstract method for setting name and location.\"\"\" pass","title":"set_name_and_location()"},{"location":"load_builder/#shift.load_builder.LoadBuilder.set_phase_data","text":"Abstract method for setting phase to load. Source code in shift\\load_builder.py 360 361 362 363 @abstractmethod def set_phase_data ( self ) -> None : \"\"\"Abstract method for setting phase to load.\"\"\" pass","title":"set_phase_data()"},{"location":"load_builder/#shift.load_builder.LoadBuilder.set_power_data","text":"Abstract method for setting the power consumption for load. Source code in shift\\load_builder.py 355 356 357 358 @abstractmethod def set_power_data ( self ) -> None : \"\"\"Abstract method for setting the power consumption for load.\"\"\" pass","title":"set_power_data()"},{"location":"load_builder/#shift.load_builder.LoadBuilderEngineer","text":"Director for building loads. Attributes: Name Type Description builder LoadBuilder LoadBuilder instance Source code in shift\\load_builder.py 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 class LoadBuilderEngineer : \"\"\"Director for building loads. Attributes: builder (LoadBuilder): LoadBuilder instance \"\"\" def __init__ ( self , builder : LoadBuilder ) -> None : \"\"\"Constructor for `LoadBuilderEngineer` class. Args: builder (LoadBuilder): LoadBuilder instance \"\"\" self . builder = builder self . builder . set_name_and_location () self . builder . set_power_data () self . builder . set_phase_data () self . builder . set_kv_and_conn () def get_load ( self ) -> Load : \"\"\"Returns a `Load` instance.\"\"\" return self . builder . load","title":"LoadBuilderEngineer"},{"location":"load_builder/#shift.load_builder.LoadBuilderEngineer.__init__","text":"Constructor for LoadBuilderEngineer class. Parameters: Name Type Description Default builder LoadBuilder LoadBuilder instance required Source code in shift\\load_builder.py 520 521 522 523 524 525 526 527 528 529 530 def __init__ ( self , builder : LoadBuilder ) -> None : \"\"\"Constructor for `LoadBuilderEngineer` class. Args: builder (LoadBuilder): LoadBuilder instance \"\"\" self . builder = builder self . builder . set_name_and_location () self . builder . set_power_data () self . builder . set_phase_data () self . builder . set_kv_and_conn ()","title":"__init__()"},{"location":"load_builder/#shift.load_builder.LoadBuilderEngineer.get_load","text":"Returns a Load instance. Source code in shift\\load_builder.py 532 533 534 def get_load ( self ) -> Load : \"\"\"Returns a `Load` instance.\"\"\" return self . builder . load","title":"get_load()"},{"location":"load_builder/#shift.load_builder.PhaseAllocator","text":"Bases: ABC Interface for allocating phase. Source code in shift\\load_builder.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 class PhaseAllocator ( ABC ): \"\"\"Interface for allocating phase.\"\"\" @abstractmethod def get_phase ( self , geometry : Geometry ) -> Phase : \"\"\"Abstract method for getting a phase. Args: geometry (Geometry): Geometry instance for which phase is to be determined Returns: Phase: Phase instance for the geometry \"\"\" pass @abstractmethod def get_num_phase ( self , geometry : Geometry ) -> NumPhase : \"\"\"Abstract method for getting number of phase. Args: geometry (Geometry): Geometry instance for which num_phase is to be determined Returns: NumPhase: NumPhase instance for the geometry \"\"\" pass","title":"PhaseAllocator"},{"location":"load_builder/#shift.load_builder.PhaseAllocator.get_num_phase","text":"Abstract method for getting number of phase. Parameters: Name Type Description Default geometry Geometry Geometry instance for which num_phase is to be determined required Returns: Name Type Description NumPhase NumPhase NumPhase instance for the geometry Source code in shift\\load_builder.py 169 170 171 172 173 174 175 176 177 178 179 @abstractmethod def get_num_phase ( self , geometry : Geometry ) -> NumPhase : \"\"\"Abstract method for getting number of phase. Args: geometry (Geometry): Geometry instance for which num_phase is to be determined Returns: NumPhase: NumPhase instance for the geometry \"\"\" pass","title":"get_num_phase()"},{"location":"load_builder/#shift.load_builder.PhaseAllocator.get_phase","text":"Abstract method for getting a phase. Parameters: Name Type Description Default geometry Geometry Geometry instance for which phase is to be determined required Returns: Name Type Description Phase Phase Phase instance for the geometry Source code in shift\\load_builder.py 157 158 159 160 161 162 163 164 165 166 167 @abstractmethod def get_phase ( self , geometry : Geometry ) -> Phase : \"\"\"Abstract method for getting a phase. Args: geometry (Geometry): Geometry instance for which phase is to be determined Returns: Phase: Phase instance for the geometry \"\"\" pass","title":"get_phase()"},{"location":"load_builder/#shift.load_builder.PiecewiseBuildingAreaToConsumptionConverter","text":"Bases: BuildingAreaToConsumptionConverter Class for handling computation of power consumption using piecewide linear function. Attributes: Name Type Description curve List [ list ] Piecewise linear function e.g. [[1,2], [3,4]] Source code in shift\\load_builder.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class PiecewiseBuildingAreaToConsumptionConverter ( BuildingAreaToConsumptionConverter ): \"\"\"Class for handling computation of power consumption using piecewide linear function. Attributes: curve (List[list]): Piecewise linear function e.g. [[1,2], [3,4]] \"\"\" def __init__ ( self , area_to_kw_curve : List [ list ]) -> None : \"\"\"Constructor for `PiecewiseBuildingAreaToConsumptionConverter` class. Args: area_to_kw_curve (List[list]): Piecewise linear function e.g. [[1,2], [3,4]] \"\"\" self . curve = area_to_kw_curve def convert ( self , area : float ) -> float : \"\"\"Refer to base class for more details.\"\"\" return get_point_from_curve ( self . curve , area )","title":"PiecewiseBuildingAreaToConsumptionConverter"},{"location":"load_builder/#shift.load_builder.PiecewiseBuildingAreaToConsumptionConverter.__init__","text":"Constructor for PiecewiseBuildingAreaToConsumptionConverter class. Parameters: Name Type Description Default area_to_kw_curve List [ list ] Piecewise linear function e.g. [[1,2], [3,4]] required Source code in shift\\load_builder.py 93 94 95 96 97 98 99 def __init__ ( self , area_to_kw_curve : List [ list ]) -> None : \"\"\"Constructor for `PiecewiseBuildingAreaToConsumptionConverter` class. Args: area_to_kw_curve (List[list]): Piecewise linear function e.g. [[1,2], [3,4]] \"\"\" self . curve = area_to_kw_curve","title":"__init__()"},{"location":"load_builder/#shift.load_builder.PiecewiseBuildingAreaToConsumptionConverter.convert","text":"Refer to base class for more details. Source code in shift\\load_builder.py 101 102 103 def convert ( self , area : float ) -> float : \"\"\"Refer to base class for more details.\"\"\" return get_point_from_curve ( self . curve , area )","title":"convert()"},{"location":"load_builder/#shift.load_builder.ProportionalBuildingAreaToConsumptionConverter","text":"Bases: BuildingAreaToConsumptionConverter Class for handling computation of power consumption using proportional allocation method. Attributes: Name Type Description min_kw float Minimum kw to be assigned max_kw float Maximum kw to be assigned max_area float Maximum area of all the buildings min_area float Minimum area of all the buildings Source code in shift\\load_builder.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 class ProportionalBuildingAreaToConsumptionConverter ( BuildingAreaToConsumptionConverter ): \"\"\"Class for handling computation of power consumption using proportional allocation method. Attributes: min_kw (float): Minimum kw to be assigned max_kw (float): Maximum kw to be assigned max_area (float): Maximum area of all the buildings min_area (float): Minimum area of all the buildings \"\"\" def __init__ ( self , min_kw : float , max_kw : float , max_area : float , min_area : float ) -> None : \"\"\"Constructor for `ProportionalBuildingAreaToConsumptionConverter` class. Args: min_kw (float): Minimum kw to be assigned max_kw (float): Maximum kw to be assigned max_area (float): Maximum area of all the buildings min_area (float): Minimum area of all the buildings Raises: InvalidInputError: If min_kw is greater than or equal to max_kw \"\"\" self . min_kw = min_kw self . max_kw = max_kw self . max_area = max_area self . min_area = min_area if self . min_kw >= self . max_kw : raise InvalidInputError ( f \"Min kW { min_kw } is greater than or equal to Max kW { max_kw } \" ) def convert ( self , area : float ) -> float : \"\"\"Refer to base class for more details.\"\"\" if self . max_area != 0 : kw = self . min_kw + ( self . max_kw - self . min_kw ) * ( area - self . min_area ) / ( self . max_area - self . min_area ) else : kw = self . min_kw return kw","title":"ProportionalBuildingAreaToConsumptionConverter"},{"location":"load_builder/#shift.load_builder.ProportionalBuildingAreaToConsumptionConverter.__init__","text":"Constructor for ProportionalBuildingAreaToConsumptionConverter class. Parameters: Name Type Description Default min_kw float Minimum kw to be assigned required max_kw float Maximum kw to be assigned required max_area float Maximum area of all the buildings required min_area float Minimum area of all the buildings required Raises: Type Description InvalidInputError If min_kw is greater than or equal to max_kw Source code in shift\\load_builder.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def __init__ ( self , min_kw : float , max_kw : float , max_area : float , min_area : float ) -> None : \"\"\"Constructor for `ProportionalBuildingAreaToConsumptionConverter` class. Args: min_kw (float): Minimum kw to be assigned max_kw (float): Maximum kw to be assigned max_area (float): Maximum area of all the buildings min_area (float): Minimum area of all the buildings Raises: InvalidInputError: If min_kw is greater than or equal to max_kw \"\"\" self . min_kw = min_kw self . max_kw = max_kw self . max_area = max_area self . min_area = min_area if self . min_kw >= self . max_kw : raise InvalidInputError ( f \"Min kW { min_kw } is greater than or equal to Max kW { max_kw } \" )","title":"__init__()"},{"location":"load_builder/#shift.load_builder.ProportionalBuildingAreaToConsumptionConverter.convert","text":"Refer to base class for more details. Source code in shift\\load_builder.py 142 143 144 145 146 147 148 149 150 151 def convert ( self , area : float ) -> float : \"\"\"Refer to base class for more details.\"\"\" if self . max_area != 0 : kw = self . min_kw + ( self . max_kw - self . min_kw ) * ( area - self . min_area ) / ( self . max_area - self . min_area ) else : kw = self . min_kw return kw","title":"convert()"},{"location":"load_builder/#shift.load_builder.RandomPhaseAllocator","text":"Bases: PhaseAllocator Allocates the phase to all geometries uniformly randomly. Attributes: Name Type Description pct_single_phases float Percentage of single phase geometries pct_two_phases float Percentage of two phase geometries pct_three_phases float Percentage of three phase geometries geometries List [ Geometry ] List of Geometry objects geometry_to_phase dict A dictionary holding the phase for geometries Source code in shift\\load_builder.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 class RandomPhaseAllocator ( PhaseAllocator ): \"\"\"Allocates the phase to all geometries uniformly randomly. Attributes: pct_single_phases (float): Percentage of single phase geometries pct_two_phases (float): Percentage of two phase geometries pct_three_phases (float): Percentage of three phase geometries geometries (List[Geometry]): List of Geometry objects geometry_to_phase (dict): A dictionary holding the phase for geometries \"\"\" def __init__ ( self , pct_single_phases : float , pct_two_phases : float , pct_three_phases : float , geometries : List [ Geometry ], ) -> None : \"\"\"Constructor for `RandomPhaseAllocator` class. Args: pct_single_phases (float): Percentage of single phase geometries pct_two_phases (float): Percentage of two phase geometries pct_three_phases (float): Percentage of three phase geometries geometries (List[Geometry]): List of Geometry objects Raises: PercentageSumNotHundred: If the sume of percentages is not 100 \"\"\" self . pct_single_phases = pct_single_phases self . pct_two_phases = pct_two_phases self . pct_three_phases = pct_three_phases self . geometries = geometries if pct_single_phases + pct_two_phases + pct_three_phases != 100 : raise PercentageSumNotHundred ( pct_single_phases + pct_two_phases + pct_three_phases ) random . shuffle ( self . geometries ) three_phase_geometries = self . geometries [ : int ( len ( self . geometries ) * self . pct_three_phases / 100 ) ] self . geometry_to_phase = { g : Phase . ABCN for g in three_phase_geometries } self . geometry_to_numphase = { g : NumPhase . THREE for g in three_phase_geometries } single_phases = [ Phase . AN , Phase . BN , Phase . CN ] two_phases = [ Phase . AB , Phase . BC , Phase . CA ] two_phase_geometries = self . geometries [ int ( len ( self . geometries ) * self . pct_three_phases / 100 ) : int ( len ( self . geometries ) * self . pct_two_phases / 100 ) ] self . geometry_to_phase . update ( { g : random . choice ( two_phases ) for g in two_phase_geometries } ) self . geometry_to_numphase . update ( { g : NumPhase . TWO for g in two_phase_geometries } ) single_phase_geometries = [ g for g in self . geometries if g not in self . geometry_to_phase ] self . geometry_to_phase . update ( { g : random . choice ( single_phases ) for g in single_phase_geometries } ) self . geometry_to_numphase . update ( { g : NumPhase . SINGLE for g in single_phase_geometries } ) def get_phase ( self , geometry : Geometry ) -> Phase : \"\"\"Refer to the base class for more details.\"\"\" return self . geometry_to_phase [ geometry ] def get_num_phase ( self , geometry : Geometry ) -> NumPhase : \"\"\"Refer to the base class for more details.\"\"\" return self . geometry_to_numphase [ geometry ]","title":"RandomPhaseAllocator"},{"location":"load_builder/#shift.load_builder.RandomPhaseAllocator.__init__","text":"Constructor for RandomPhaseAllocator class. Parameters: Name Type Description Default pct_single_phases float Percentage of single phase geometries required pct_two_phases float Percentage of two phase geometries required pct_three_phases float Percentage of three phase geometries required geometries List [ Geometry ] List of Geometry objects required Raises: Type Description PercentageSumNotHundred If the sume of percentages is not 100 Source code in shift\\load_builder.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def __init__ ( self , pct_single_phases : float , pct_two_phases : float , pct_three_phases : float , geometries : List [ Geometry ], ) -> None : \"\"\"Constructor for `RandomPhaseAllocator` class. Args: pct_single_phases (float): Percentage of single phase geometries pct_two_phases (float): Percentage of two phase geometries pct_three_phases (float): Percentage of three phase geometries geometries (List[Geometry]): List of Geometry objects Raises: PercentageSumNotHundred: If the sume of percentages is not 100 \"\"\" self . pct_single_phases = pct_single_phases self . pct_two_phases = pct_two_phases self . pct_three_phases = pct_three_phases self . geometries = geometries if pct_single_phases + pct_two_phases + pct_three_phases != 100 : raise PercentageSumNotHundred ( pct_single_phases + pct_two_phases + pct_three_phases ) random . shuffle ( self . geometries ) three_phase_geometries = self . geometries [ : int ( len ( self . geometries ) * self . pct_three_phases / 100 ) ] self . geometry_to_phase = { g : Phase . ABCN for g in three_phase_geometries } self . geometry_to_numphase = { g : NumPhase . THREE for g in three_phase_geometries } single_phases = [ Phase . AN , Phase . BN , Phase . CN ] two_phases = [ Phase . AB , Phase . BC , Phase . CA ] two_phase_geometries = self . geometries [ int ( len ( self . geometries ) * self . pct_three_phases / 100 ) : int ( len ( self . geometries ) * self . pct_two_phases / 100 ) ] self . geometry_to_phase . update ( { g : random . choice ( two_phases ) for g in two_phase_geometries } ) self . geometry_to_numphase . update ( { g : NumPhase . TWO for g in two_phase_geometries } ) single_phase_geometries = [ g for g in self . geometries if g not in self . geometry_to_phase ] self . geometry_to_phase . update ( { g : random . choice ( single_phases ) for g in single_phase_geometries } ) self . geometry_to_numphase . update ( { g : NumPhase . SINGLE for g in single_phase_geometries } )","title":"__init__()"},{"location":"load_builder/#shift.load_builder.RandomPhaseAllocator.get_num_phase","text":"Refer to the base class for more details. Source code in shift\\load_builder.py 261 262 263 def get_num_phase ( self , geometry : Geometry ) -> NumPhase : \"\"\"Refer to the base class for more details.\"\"\" return self . geometry_to_numphase [ geometry ]","title":"get_num_phase()"},{"location":"load_builder/#shift.load_builder.RandomPhaseAllocator.get_phase","text":"Refer to the base class for more details. Source code in shift\\load_builder.py 257 258 259 def get_phase ( self , geometry : Geometry ) -> Phase : \"\"\"Refer to the base class for more details.\"\"\" return self . geometry_to_phase [ geometry ]","title":"get_phase()"},{"location":"load_builder/#shift.load_builder.SimpleVoltageSetter","text":"Simple voltage setter for setting kv for loads. Attributes: Name Type Description line_to_line_voltage float Line to line voltage in kV voltage_dict dict NumPhase to voltage mapper Source code in shift\\load_builder.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 class SimpleVoltageSetter : \"\"\"Simple voltage setter for setting kv for loads. Attributes: line_to_line_voltage (float): Line to line voltage in kV voltage_dict (dict): NumPhase to voltage mapper \"\"\" def __init__ ( self , line_to_line_voltage : float ) -> None : \"\"\"Constructor for `SimpleVoltageSetter` class. Args: line_to_line_voltage (float): Line to line voltage in kV Raises: NegativeKVError: If the `line_to_line_voltage` is negative ZeroKVError: if the `line_to_line_voltage` is 0 \"\"\" self . line_to_line_voltage = line_to_line_voltage if self . line_to_line_voltage < 0 : raise NegativeKVError ( self . line_to_line_voltage ) if self . line_to_line_voltage == 0 : raise ZeroKVError () self . voltage_dict = { NumPhase . SINGLE : round ( self . line_to_line_voltage / math . sqrt ( 3 ), 3 ), NumPhase . TWO : self . line_to_line_voltage , NumPhase . THREE : self . line_to_line_voltage , } def get_kv ( self , load : Load ) -> float : \"\"\"Refer to the base class for more details.\"\"\" return self . voltage_dict [ load . num_phase ]","title":"SimpleVoltageSetter"},{"location":"load_builder/#shift.load_builder.SimpleVoltageSetter.__init__","text":"Constructor for SimpleVoltageSetter class. Parameters: Name Type Description Default line_to_line_voltage float Line to line voltage in kV required Raises: Type Description NegativeKVError If the line_to_line_voltage is negative ZeroKVError if the line_to_line_voltage is 0 Source code in shift\\load_builder.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def __init__ ( self , line_to_line_voltage : float ) -> None : \"\"\"Constructor for `SimpleVoltageSetter` class. Args: line_to_line_voltage (float): Line to line voltage in kV Raises: NegativeKVError: If the `line_to_line_voltage` is negative ZeroKVError: if the `line_to_line_voltage` is 0 \"\"\" self . line_to_line_voltage = line_to_line_voltage if self . line_to_line_voltage < 0 : raise NegativeKVError ( self . line_to_line_voltage ) if self . line_to_line_voltage == 0 : raise ZeroKVError () self . voltage_dict = { NumPhase . SINGLE : round ( self . line_to_line_voltage / math . sqrt ( 3 ), 3 ), NumPhase . TWO : self . line_to_line_voltage , NumPhase . THREE : self . line_to_line_voltage , }","title":"__init__()"},{"location":"load_builder/#shift.load_builder.SimpleVoltageSetter.get_kv","text":"Refer to the base class for more details. Source code in shift\\load_builder.py 314 315 316 def get_kv ( self , load : Load ) -> float : \"\"\"Refer to the base class for more details.\"\"\" return self . voltage_dict [ load . num_phase ]","title":"get_kv()"},{"location":"load_builder/#shift.load_builder.VoltageSetter","text":"Bases: ABC Interface for setting voltage for loads. Source code in shift\\load_builder.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 class VoltageSetter ( ABC ): \"\"\"Interface for setting voltage for loads.\"\"\" @abstractmethod def get_kv ( self , load : Load ) -> float : \"\"\"Abstract method for getting voltage level for load object. Args: load (Load): Load instance Returns: float: Voltage in kV for load object \"\"\" pass","title":"VoltageSetter"},{"location":"load_builder/#shift.load_builder.VoltageSetter.get_kv","text":"Abstract method for getting voltage level for load object. Parameters: Name Type Description Default load Load Load instance required Returns: Name Type Description float float Voltage in kV for load object Source code in shift\\load_builder.py 269 270 271 272 273 274 275 276 277 278 279 @abstractmethod def get_kv ( self , load : Load ) -> float : \"\"\"Abstract method for getting voltage level for load object. Args: load (Load): Load instance Returns: float: Voltage in kV for load object \"\"\" pass","title":"get_kv()"},{"location":"network_plots/","text":"This module contains classes for managing network plots. NetworkPlot Bases: ABC Interface for plotting a network. Source code in shift\\network_plots.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class NetworkPlot ( ABC ): \"\"\"Interface for plotting a network.\"\"\" @abstractmethod def show ( self ) -> None : \"\"\"Abstract method for showing the plot.\"\"\" pass @abstractmethod def html_export ( self , html_file_path : str ): \"\"\"Abstract method for exporting network plot in html format. Args: html_file_path (str): Valid html file path \"\"\" pass html_export ( html_file_path ) abstractmethod Abstract method for exporting network plot in html format. Parameters: Name Type Description Default html_file_path str Valid html file path required Source code in shift\\network_plots.py 59 60 61 62 63 64 65 66 @abstractmethod def html_export ( self , html_file_path : str ): \"\"\"Abstract method for exporting network plot in html format. Args: html_file_path (str): Valid html file path \"\"\" pass show () abstractmethod Abstract method for showing the plot. Source code in shift\\network_plots.py 54 55 56 57 @abstractmethod def show ( self ) -> None : \"\"\"Abstract method for showing the plot.\"\"\" pass PlotlyGISNetworkPlot Bases: NetworkPlot \" Class for plotting network along with GIS layer using plotly. Attributes: Name Type Description network nx . Graph Graph to plot access_token str MapBox token style str Valid MapBox style zoom_level int Initial Zoom level for the plot asset_specific_style Union [None, dict ] Asset specific style dict data dict Plot data managed internally fig go . Figure go.Figure instance managed internally Source code in shift\\network_plots.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 class PlotlyGISNetworkPlot ( NetworkPlot ): \"\"\" \" Class for plotting network along with GIS layer using plotly. Attributes: network (nx.Graph): Graph to plot access_token (str): MapBox token style (str): Valid MapBox style zoom_level (int): Initial Zoom level for the plot asset_specific_style (Union[None, dict]): Asset specific style dict data (dict): Plot data managed internally fig (go.Figure): go.Figure instance managed internally \"\"\" def __init__ ( self , network : nx . Graph , access_token : str , style : str = \"satellite\" , zoom_level : int = 13 , asset_specific_style : Union [ None , dict ] = None , ) -> None : \"\"\"Constructor for `PlotlyGISNetworkPlot` class. Args: network (nx.Graph): Graph to plot access_token (str): MapBox token style (str): Valid MapBox style zoom_level (int): Initial Zoom level for the plot asset_specific_style (Union[None, dict]): Asset specific style dict Raises: InvalidMapboxStyle: If invalid mapbox style is passed ZoomLevelNotInRangeError: If invalid zoom level is passed EmptyAssetStyleDict: If `asset_specific_style` is empty \"\"\" self . access_token = access_token self . network = network self . style = style if self . style not in MAP_STYLES : raise InvalidMapboxStyle ( self . style ) self . zoom_level = zoom_level if self . zoom_level < MIN_ZOOM_LEVEL or self . zoom_level > MAX_ZOOM_LEVEL : raise ZoomLevelNotInRangeError ( self . zoom_level ) self . asset_specific_style = ( asset_specific_style if asset_specific_style is not None else {} ) if not self . asset_specific_style : raise EmptyAssetStyleDict () self . data = [] self . _add_data () self . _prepare_plot () def _add_data ( self ): \"\"\"Private method to add data for generating plot.\"\"\" scatter_data = {} for node in self . network . nodes . data (): if \"type\" not in node [ 1 ]: raise MissingKeyDataForNetworkNode ( \"type\" ) if \"data\" not in node [ 1 ]: node [ 1 ][ \"data\" ] = {} if node [ 1 ][ \"type\" ] not in scatter_data : scatter_data [ node [ 1 ][ \"type\" ]] = { \"longitudes\" : [], \"latitudes\" : [], \"texts\" : [], } scatter_data [ node [ 1 ][ \"type\" ]][ \"latitudes\" ] . append ( node [ 1 ][ \"pos\" ][ 1 ]) scatter_data [ node [ 1 ][ \"type\" ]][ \"longitudes\" ] . append ( node [ 1 ][ \"pos\" ][ 0 ] ) text = \"<br>\" . join ([ f \" { k } : { v } \" for k , v in node [ 1 ][ \"data\" ] . items ()]) scatter_data [ node [ 1 ][ \"type\" ]][ \"texts\" ] . append ( text ) for key , style_dict in self . asset_specific_style . get ( \"nodes\" , {} ) . items (): if key in scatter_data : self . add_scatter_data ( scatter_data [ key ][ \"longitudes\" ], scatter_data [ key ][ \"latitudes\" ], scatter_data [ key ][ \"texts\" ], color = style_dict . get ( \"color\" , \"blue\" ), size = style_dict . get ( \"size\" , 5 ), ) else : raise InvalidNodeType ( key ) line_data = {} node_data = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data ()} for edge in self . network . edges (): edge_data = self . network . get_edge_data ( * edge ) if \"type\" not in edge_data : raise MissingKeyDataForNetworkNode ( \"type\" ) if edge_data [ \"type\" ] not in line_data : line_data [ edge_data [ \"type\" ]] = { \"longitudes\" : [], \"latitudes\" : [], } line_data [ edge_data [ \"type\" ]][ \"latitudes\" ] . extend ( [ node_data [ edge [ 0 ]][ \"pos\" ][ 1 ], node_data [ edge [ 1 ]][ \"pos\" ][ 1 ], None , ] ) line_data [ edge_data [ \"type\" ]][ \"longitudes\" ] . extend ( [ node_data [ edge [ 0 ]][ \"pos\" ][ 0 ], node_data [ edge [ 1 ]][ \"pos\" ][ 0 ], None , ] ) for key , style_dict in self . asset_specific_style . get ( \"edges\" , {} ) . items (): if key in line_data : self . add_line_data ( line_data [ key ][ \"latitudes\" ], line_data [ key ][ \"longitudes\" ], line_color = style_dict . get ( \"color\" , \"red\" ), size = style_dict . get ( \"size\" , 10 ), ) else : raise InvalidNodeType ( key ) def add_scatter_data ( self , lons : List [ float ], lats : List [ float ], texts : List [ str ], color : str = \"blue\" , size : int = 5 , ) -> None : \"\"\"Add scatter data to the map. Args: lons (List[float]): List of longitudes lats (List[float]): List of latitudes texts (List[str]): List of hover texts color (str): Color for scatter plot size (int): Size for scatter plot \"\"\" self . data . append ( go . Scattermapbox ( mode = \"markers\" , lon = lons , lat = lats , text = texts , marker = { \"size\" : size , \"color\" : color }, ) ) def add_line_data ( self , lats : List [ float ], lons : List [ float ], line_color : str = \"red\" , size : int = 10 , ) -> None : \"\"\"Method for adding line data. Args: lats (List[float]): List of latitudes lons (List[float]): List of longitudes line_color (str): Color for line plot size (int): Size for line plot \"\"\" self . data . append ( go . Scattermapbox ( mode = \"markers+lines\" , lon = lons , lat = lats , marker = { \"size\" : 2 }, line = { \"color\" : line_color }, ) ) def _get_map_centre ( self ) -> dict : \"\"\"Private method to get map center.\"\"\" longitudes = [ node [ 1 ][ \"pos\" ][ 0 ] for node in self . network . nodes . data ()] latitudes = [ node [ 1 ][ \"pos\" ][ 1 ] for node in self . network . nodes . data ()] return { \"lon\" : sum ( longitudes ) / len ( longitudes ), \"lat\" : sum ( latitudes ) / len ( latitudes ), } def _prepare_plot ( self ) -> None : \"\"\"Private method to prepare the plot\"\"\" self . fig = go . Figure ( data = self . data ) self . fig . update_layout ( margin = { \"r\" : 0 , \"t\" : 0 , \"l\" : 0 , \"b\" : 0 }) self . fig . update_mapboxes ( { \"accesstoken\" : self . access_token , \"style\" : self . style , \"center\" : self . _get_map_centre (), \"zoom\" : self . zoom_level , } ) def show ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . fig . show () def html_export ( self , html_file_path : str ) -> None : \"\"\"Refer to base class for more details.\"\"\" if not os . path . exists ( os . path . dirname ( html_file_path )): raise FolderNotFoundError ( os . path . dirname ( html_file_path )) self . fig . write_html ( html_file_path ) __init__ ( network , access_token , style = 'satellite' , zoom_level = 13 , asset_specific_style = None ) Constructor for PlotlyGISNetworkPlot class. Parameters: Name Type Description Default network nx . Graph Graph to plot required access_token str MapBox token required style str Valid MapBox style 'satellite' zoom_level int Initial Zoom level for the plot 13 asset_specific_style Union [None, dict ] Asset specific style dict None Raises: Type Description InvalidMapboxStyle If invalid mapbox style is passed ZoomLevelNotInRangeError If invalid zoom level is passed EmptyAssetStyleDict If asset_specific_style is empty Source code in shift\\network_plots.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def __init__ ( self , network : nx . Graph , access_token : str , style : str = \"satellite\" , zoom_level : int = 13 , asset_specific_style : Union [ None , dict ] = None , ) -> None : \"\"\"Constructor for `PlotlyGISNetworkPlot` class. Args: network (nx.Graph): Graph to plot access_token (str): MapBox token style (str): Valid MapBox style zoom_level (int): Initial Zoom level for the plot asset_specific_style (Union[None, dict]): Asset specific style dict Raises: InvalidMapboxStyle: If invalid mapbox style is passed ZoomLevelNotInRangeError: If invalid zoom level is passed EmptyAssetStyleDict: If `asset_specific_style` is empty \"\"\" self . access_token = access_token self . network = network self . style = style if self . style not in MAP_STYLES : raise InvalidMapboxStyle ( self . style ) self . zoom_level = zoom_level if self . zoom_level < MIN_ZOOM_LEVEL or self . zoom_level > MAX_ZOOM_LEVEL : raise ZoomLevelNotInRangeError ( self . zoom_level ) self . asset_specific_style = ( asset_specific_style if asset_specific_style is not None else {} ) if not self . asset_specific_style : raise EmptyAssetStyleDict () self . data = [] self . _add_data () self . _prepare_plot () add_line_data ( lats , lons , line_color = 'red' , size = 10 ) Method for adding line data. Parameters: Name Type Description Default lats List [ float ] List of latitudes required lons List [ float ] List of longitudes required line_color str Color for line plot 'red' size int Size for line plot 10 Source code in shift\\network_plots.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 def add_line_data ( self , lats : List [ float ], lons : List [ float ], line_color : str = \"red\" , size : int = 10 , ) -> None : \"\"\"Method for adding line data. Args: lats (List[float]): List of latitudes lons (List[float]): List of longitudes line_color (str): Color for line plot size (int): Size for line plot \"\"\" self . data . append ( go . Scattermapbox ( mode = \"markers+lines\" , lon = lons , lat = lats , marker = { \"size\" : 2 }, line = { \"color\" : line_color }, ) ) add_scatter_data ( lons , lats , texts , color = 'blue' , size = 5 ) Add scatter data to the map. Parameters: Name Type Description Default lons List [ float ] List of longitudes required lats List [ float ] List of latitudes required texts List [ str ] List of hover texts required color str Color for scatter plot 'blue' size int Size for scatter plot 5 Source code in shift\\network_plots.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def add_scatter_data ( self , lons : List [ float ], lats : List [ float ], texts : List [ str ], color : str = \"blue\" , size : int = 5 , ) -> None : \"\"\"Add scatter data to the map. Args: lons (List[float]): List of longitudes lats (List[float]): List of latitudes texts (List[str]): List of hover texts color (str): Color for scatter plot size (int): Size for scatter plot \"\"\" self . data . append ( go . Scattermapbox ( mode = \"markers\" , lon = lons , lat = lats , text = texts , marker = { \"size\" : size , \"color\" : color }, ) ) html_export ( html_file_path ) Refer to base class for more details. Source code in shift\\network_plots.py 291 292 293 294 295 def html_export ( self , html_file_path : str ) -> None : \"\"\"Refer to base class for more details.\"\"\" if not os . path . exists ( os . path . dirname ( html_file_path )): raise FolderNotFoundError ( os . path . dirname ( html_file_path )) self . fig . write_html ( html_file_path ) show () Refer to base class for more details. Source code in shift\\network_plots.py 287 288 289 def show ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . fig . show ()","title":"network_plots"},{"location":"network_plots/#shift.network_plots.NetworkPlot","text":"Bases: ABC Interface for plotting a network. Source code in shift\\network_plots.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class NetworkPlot ( ABC ): \"\"\"Interface for plotting a network.\"\"\" @abstractmethod def show ( self ) -> None : \"\"\"Abstract method for showing the plot.\"\"\" pass @abstractmethod def html_export ( self , html_file_path : str ): \"\"\"Abstract method for exporting network plot in html format. Args: html_file_path (str): Valid html file path \"\"\" pass","title":"NetworkPlot"},{"location":"network_plots/#shift.network_plots.NetworkPlot.html_export","text":"Abstract method for exporting network plot in html format. Parameters: Name Type Description Default html_file_path str Valid html file path required Source code in shift\\network_plots.py 59 60 61 62 63 64 65 66 @abstractmethod def html_export ( self , html_file_path : str ): \"\"\"Abstract method for exporting network plot in html format. Args: html_file_path (str): Valid html file path \"\"\" pass","title":"html_export()"},{"location":"network_plots/#shift.network_plots.NetworkPlot.show","text":"Abstract method for showing the plot. Source code in shift\\network_plots.py 54 55 56 57 @abstractmethod def show ( self ) -> None : \"\"\"Abstract method for showing the plot.\"\"\" pass","title":"show()"},{"location":"network_plots/#shift.network_plots.PlotlyGISNetworkPlot","text":"Bases: NetworkPlot \" Class for plotting network along with GIS layer using plotly. Attributes: Name Type Description network nx . Graph Graph to plot access_token str MapBox token style str Valid MapBox style zoom_level int Initial Zoom level for the plot asset_specific_style Union [None, dict ] Asset specific style dict data dict Plot data managed internally fig go . Figure go.Figure instance managed internally Source code in shift\\network_plots.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 class PlotlyGISNetworkPlot ( NetworkPlot ): \"\"\" \" Class for plotting network along with GIS layer using plotly. Attributes: network (nx.Graph): Graph to plot access_token (str): MapBox token style (str): Valid MapBox style zoom_level (int): Initial Zoom level for the plot asset_specific_style (Union[None, dict]): Asset specific style dict data (dict): Plot data managed internally fig (go.Figure): go.Figure instance managed internally \"\"\" def __init__ ( self , network : nx . Graph , access_token : str , style : str = \"satellite\" , zoom_level : int = 13 , asset_specific_style : Union [ None , dict ] = None , ) -> None : \"\"\"Constructor for `PlotlyGISNetworkPlot` class. Args: network (nx.Graph): Graph to plot access_token (str): MapBox token style (str): Valid MapBox style zoom_level (int): Initial Zoom level for the plot asset_specific_style (Union[None, dict]): Asset specific style dict Raises: InvalidMapboxStyle: If invalid mapbox style is passed ZoomLevelNotInRangeError: If invalid zoom level is passed EmptyAssetStyleDict: If `asset_specific_style` is empty \"\"\" self . access_token = access_token self . network = network self . style = style if self . style not in MAP_STYLES : raise InvalidMapboxStyle ( self . style ) self . zoom_level = zoom_level if self . zoom_level < MIN_ZOOM_LEVEL or self . zoom_level > MAX_ZOOM_LEVEL : raise ZoomLevelNotInRangeError ( self . zoom_level ) self . asset_specific_style = ( asset_specific_style if asset_specific_style is not None else {} ) if not self . asset_specific_style : raise EmptyAssetStyleDict () self . data = [] self . _add_data () self . _prepare_plot () def _add_data ( self ): \"\"\"Private method to add data for generating plot.\"\"\" scatter_data = {} for node in self . network . nodes . data (): if \"type\" not in node [ 1 ]: raise MissingKeyDataForNetworkNode ( \"type\" ) if \"data\" not in node [ 1 ]: node [ 1 ][ \"data\" ] = {} if node [ 1 ][ \"type\" ] not in scatter_data : scatter_data [ node [ 1 ][ \"type\" ]] = { \"longitudes\" : [], \"latitudes\" : [], \"texts\" : [], } scatter_data [ node [ 1 ][ \"type\" ]][ \"latitudes\" ] . append ( node [ 1 ][ \"pos\" ][ 1 ]) scatter_data [ node [ 1 ][ \"type\" ]][ \"longitudes\" ] . append ( node [ 1 ][ \"pos\" ][ 0 ] ) text = \"<br>\" . join ([ f \" { k } : { v } \" for k , v in node [ 1 ][ \"data\" ] . items ()]) scatter_data [ node [ 1 ][ \"type\" ]][ \"texts\" ] . append ( text ) for key , style_dict in self . asset_specific_style . get ( \"nodes\" , {} ) . items (): if key in scatter_data : self . add_scatter_data ( scatter_data [ key ][ \"longitudes\" ], scatter_data [ key ][ \"latitudes\" ], scatter_data [ key ][ \"texts\" ], color = style_dict . get ( \"color\" , \"blue\" ), size = style_dict . get ( \"size\" , 5 ), ) else : raise InvalidNodeType ( key ) line_data = {} node_data = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data ()} for edge in self . network . edges (): edge_data = self . network . get_edge_data ( * edge ) if \"type\" not in edge_data : raise MissingKeyDataForNetworkNode ( \"type\" ) if edge_data [ \"type\" ] not in line_data : line_data [ edge_data [ \"type\" ]] = { \"longitudes\" : [], \"latitudes\" : [], } line_data [ edge_data [ \"type\" ]][ \"latitudes\" ] . extend ( [ node_data [ edge [ 0 ]][ \"pos\" ][ 1 ], node_data [ edge [ 1 ]][ \"pos\" ][ 1 ], None , ] ) line_data [ edge_data [ \"type\" ]][ \"longitudes\" ] . extend ( [ node_data [ edge [ 0 ]][ \"pos\" ][ 0 ], node_data [ edge [ 1 ]][ \"pos\" ][ 0 ], None , ] ) for key , style_dict in self . asset_specific_style . get ( \"edges\" , {} ) . items (): if key in line_data : self . add_line_data ( line_data [ key ][ \"latitudes\" ], line_data [ key ][ \"longitudes\" ], line_color = style_dict . get ( \"color\" , \"red\" ), size = style_dict . get ( \"size\" , 10 ), ) else : raise InvalidNodeType ( key ) def add_scatter_data ( self , lons : List [ float ], lats : List [ float ], texts : List [ str ], color : str = \"blue\" , size : int = 5 , ) -> None : \"\"\"Add scatter data to the map. Args: lons (List[float]): List of longitudes lats (List[float]): List of latitudes texts (List[str]): List of hover texts color (str): Color for scatter plot size (int): Size for scatter plot \"\"\" self . data . append ( go . Scattermapbox ( mode = \"markers\" , lon = lons , lat = lats , text = texts , marker = { \"size\" : size , \"color\" : color }, ) ) def add_line_data ( self , lats : List [ float ], lons : List [ float ], line_color : str = \"red\" , size : int = 10 , ) -> None : \"\"\"Method for adding line data. Args: lats (List[float]): List of latitudes lons (List[float]): List of longitudes line_color (str): Color for line plot size (int): Size for line plot \"\"\" self . data . append ( go . Scattermapbox ( mode = \"markers+lines\" , lon = lons , lat = lats , marker = { \"size\" : 2 }, line = { \"color\" : line_color }, ) ) def _get_map_centre ( self ) -> dict : \"\"\"Private method to get map center.\"\"\" longitudes = [ node [ 1 ][ \"pos\" ][ 0 ] for node in self . network . nodes . data ()] latitudes = [ node [ 1 ][ \"pos\" ][ 1 ] for node in self . network . nodes . data ()] return { \"lon\" : sum ( longitudes ) / len ( longitudes ), \"lat\" : sum ( latitudes ) / len ( latitudes ), } def _prepare_plot ( self ) -> None : \"\"\"Private method to prepare the plot\"\"\" self . fig = go . Figure ( data = self . data ) self . fig . update_layout ( margin = { \"r\" : 0 , \"t\" : 0 , \"l\" : 0 , \"b\" : 0 }) self . fig . update_mapboxes ( { \"accesstoken\" : self . access_token , \"style\" : self . style , \"center\" : self . _get_map_centre (), \"zoom\" : self . zoom_level , } ) def show ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . fig . show () def html_export ( self , html_file_path : str ) -> None : \"\"\"Refer to base class for more details.\"\"\" if not os . path . exists ( os . path . dirname ( html_file_path )): raise FolderNotFoundError ( os . path . dirname ( html_file_path )) self . fig . write_html ( html_file_path )","title":"PlotlyGISNetworkPlot"},{"location":"network_plots/#shift.network_plots.PlotlyGISNetworkPlot.__init__","text":"Constructor for PlotlyGISNetworkPlot class. Parameters: Name Type Description Default network nx . Graph Graph to plot required access_token str MapBox token required style str Valid MapBox style 'satellite' zoom_level int Initial Zoom level for the plot 13 asset_specific_style Union [None, dict ] Asset specific style dict None Raises: Type Description InvalidMapboxStyle If invalid mapbox style is passed ZoomLevelNotInRangeError If invalid zoom level is passed EmptyAssetStyleDict If asset_specific_style is empty Source code in shift\\network_plots.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def __init__ ( self , network : nx . Graph , access_token : str , style : str = \"satellite\" , zoom_level : int = 13 , asset_specific_style : Union [ None , dict ] = None , ) -> None : \"\"\"Constructor for `PlotlyGISNetworkPlot` class. Args: network (nx.Graph): Graph to plot access_token (str): MapBox token style (str): Valid MapBox style zoom_level (int): Initial Zoom level for the plot asset_specific_style (Union[None, dict]): Asset specific style dict Raises: InvalidMapboxStyle: If invalid mapbox style is passed ZoomLevelNotInRangeError: If invalid zoom level is passed EmptyAssetStyleDict: If `asset_specific_style` is empty \"\"\" self . access_token = access_token self . network = network self . style = style if self . style not in MAP_STYLES : raise InvalidMapboxStyle ( self . style ) self . zoom_level = zoom_level if self . zoom_level < MIN_ZOOM_LEVEL or self . zoom_level > MAX_ZOOM_LEVEL : raise ZoomLevelNotInRangeError ( self . zoom_level ) self . asset_specific_style = ( asset_specific_style if asset_specific_style is not None else {} ) if not self . asset_specific_style : raise EmptyAssetStyleDict () self . data = [] self . _add_data () self . _prepare_plot ()","title":"__init__()"},{"location":"network_plots/#shift.network_plots.PlotlyGISNetworkPlot.add_line_data","text":"Method for adding line data. Parameters: Name Type Description Default lats List [ float ] List of latitudes required lons List [ float ] List of longitudes required line_color str Color for line plot 'red' size int Size for line plot 10 Source code in shift\\network_plots.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 def add_line_data ( self , lats : List [ float ], lons : List [ float ], line_color : str = \"red\" , size : int = 10 , ) -> None : \"\"\"Method for adding line data. Args: lats (List[float]): List of latitudes lons (List[float]): List of longitudes line_color (str): Color for line plot size (int): Size for line plot \"\"\" self . data . append ( go . Scattermapbox ( mode = \"markers+lines\" , lon = lons , lat = lats , marker = { \"size\" : 2 }, line = { \"color\" : line_color }, ) )","title":"add_line_data()"},{"location":"network_plots/#shift.network_plots.PlotlyGISNetworkPlot.add_scatter_data","text":"Add scatter data to the map. Parameters: Name Type Description Default lons List [ float ] List of longitudes required lats List [ float ] List of latitudes required texts List [ str ] List of hover texts required color str Color for scatter plot 'blue' size int Size for scatter plot 5 Source code in shift\\network_plots.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def add_scatter_data ( self , lons : List [ float ], lats : List [ float ], texts : List [ str ], color : str = \"blue\" , size : int = 5 , ) -> None : \"\"\"Add scatter data to the map. Args: lons (List[float]): List of longitudes lats (List[float]): List of latitudes texts (List[str]): List of hover texts color (str): Color for scatter plot size (int): Size for scatter plot \"\"\" self . data . append ( go . Scattermapbox ( mode = \"markers\" , lon = lons , lat = lats , text = texts , marker = { \"size\" : size , \"color\" : color }, ) )","title":"add_scatter_data()"},{"location":"network_plots/#shift.network_plots.PlotlyGISNetworkPlot.html_export","text":"Refer to base class for more details. Source code in shift\\network_plots.py 291 292 293 294 295 def html_export ( self , html_file_path : str ) -> None : \"\"\"Refer to base class for more details.\"\"\" if not os . path . exists ( os . path . dirname ( html_file_path )): raise FolderNotFoundError ( os . path . dirname ( html_file_path )) self . fig . write_html ( html_file_path )","title":"html_export()"},{"location":"network_plots/#shift.network_plots.PlotlyGISNetworkPlot.show","text":"Refer to base class for more details. Source code in shift\\network_plots.py 287 288 289 def show ( self ) -> None : \"\"\"Refer to base class for more details.\"\"\" self . fig . show ()","title":"show()"},{"location":"primary_network_builder/","text":"This module contains classes for managing creation of primary network sections. BaseNetworkBuilder Bases: ABC Interface for building distribution network. Attributes: Name Type Description div_func Callable [[ float ], float ] Diversity factor function coefficients kv_ll float Line to line voltage in KV max_pole_to_pole_distance float Maximum pole to pole distance in meter power_factor float Power factor used to compute kva adjustment_factor float Adjustment factor for adjusting kva planned_avg_annual_growth float Planned average annual load growth rate in percentage actual_avg_annual_growth float Actual average annual load growth rate in percentage actual_years_in_operation float Actual years in operation planned_years_in_operation float Planned years in operation Source code in shift\\primary_network_builder.py 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 class BaseNetworkBuilder ( ABC ): \"\"\"Interface for building distribution network. Attributes: div_func (Callable[[float], float]): Diversity factor function coefficients kv_ll (float): Line to line voltage in KV max_pole_to_pole_distance (float): Maximum pole to pole distance in meter power_factor (float): Power factor used to compute kva adjustment_factor (float): Adjustment factor for adjusting kva planned_avg_annual_growth (float): Planned average annual load growth rate in percentage actual_avg_annual_growth (float): Actual average annual load growth rate in percentage actual_years_in_operation (float): Actual years in operation planned_years_in_operation (float): Planned years in operation \"\"\" def __init__ ( self , div_func : Callable [[ float ], float ], kv_ll : float , max_pole_to_pole_distance : float = 100 , power_factor : float = 0.9 , adjustment_factor : float = 1.2 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ) -> None : \"\"\"Constructor for `BaseNetworkBuilder` class. Args: div_func (Callable[[float], float]): Diversity factor function coefficients kv_ll (float): Line to line voltage in KV max_pole_to_pole_distance (float): Maximum pole to pole distance in meter power_factor (float): Power factor used to compute kva adjustment_factor (float): Adjustment factor for adjusting kva planned_avg_annual_growth (float): Planned average annual load growth rate in percentage actual_avg_annual_growth (float): Actual average annual load growth rate in percentage actual_years_in_operation (float): Actual years in operation planned_years_in_operation (float): Planned years in operation Raises: NegativeKVError: If `kv_ll` is negative ZeroKVError: If `kv_ll` is zero AdjustmentFactorNotInRangeError: If invalid adjustement factor is passed PowerFactorNotInRangeError: If power factor is not in valid range PoleToPoleDistanceNotInRange: If pole to pole distance passed in invalid PercentageNotInRangeError: If percentages passed are not valid OperationYearNotInRange: If operation year passed is invalid \"\"\" self . max_pole_to_pole_distance = max_pole_to_pole_distance self . div_func = div_func self . kv_ll = kv_ll self . adjustment_factor = adjustment_factor self . power_factor = power_factor self . planned_avg_annual_growth = planned_avg_annual_growth self . actual_avg_annual_growth = actual_avg_annual_growth self . actual_years_in_operation = actual_years_in_operation self . planned_years_in_operation = planned_years_in_operation if self . kv_ll < 0 : raise NegativeKVError ( self . kv_ll ) if self . kv_ll == 0 : raise ZeroKVError () if ( self . adjustment_factor < MIN_ADJUSTMENT_FACTOR or self . adjustment_factor > MAX_ADJUSTMENT_FACTOR ): raise AdjustmentFactorNotInRangeError ( self . adjustment_factor ) if ( self . power_factor < MIN_POWER_FACTOR or self . power_factor > MAX_POWER_FACTOR ): raise PowerFactorNotInRangeError ( self . power_factor ) if ( self . max_pole_to_pole_distance < MIN_POLE_TO_POLE_DISTANCE or self . max_pole_to_pole_distance > MAX_POLE_TO_POLE_DISTANCE ): raise PoleToPoleDistanceNotInRange ( self . max_pole_to_pole_distance ) if ( self . planned_avg_annual_growth < MIN_PERCENTAGE or self . planned_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . planned_avg_annual_growth ) if ( self . actual_avg_annual_growth < MIN_PERCENTAGE or self . actual_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . actual_avg_annual_growth ) if ( self . actual_years_in_operation < MIN_YEAR_OPERATION or self . actual_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . actual_years_in_operation ) if ( self . planned_years_in_operation < MIN_YEAR_OPERATION or self . planned_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . planned_years_in_operation ) def _compute_ampacity ( self , non_coincident_peak : float , num_of_customers : int ) -> float : \"\"\"Private method to compute ampacity. Args: non_coincident_peak (float): Non coincident peak consumption num_of_customers (int): Number of customers Returns: float: conductor ampacity \"\"\" # Initial step is to compute maximum diversified demand div_factor = ( self . div_func ( num_of_customers ) if num_of_customers > 1 else 1 ) max_diversified_demand = non_coincident_peak / div_factor max_diversified_kva = ( max_diversified_demand * self . adjustment_factor / self . power_factor ) max_diversified_ampacity = max_diversified_kva / ( 1.732 * self . kv_ll ) original_max_diversified_ampacity = max_diversified_ampacity / math . pow ( 1 + self . actual_avg_annual_growth / 100 , self . actual_years_in_operation , ) conductor_ampacity = original_max_diversified_ampacity * math . pow ( 1 + self . planned_avg_annual_growth / 100 , self . planned_years_in_operation , ) return conductor_ampacity @abstractmethod def update_network_with_ampacity ( self ): \"\"\"Abstract method for updating ampacity for all line sections.\"\"\" pass __init__ ( div_func , kv_ll , max_pole_to_pole_distance = 100 , power_factor = 0.9 , adjustment_factor = 1.2 , planned_avg_annual_growth = 2 , actual_avg_annual_growth = 4 , actual_years_in_operation = 15 , planned_years_in_operation = 10 ) Constructor for BaseNetworkBuilder class. Parameters: Name Type Description Default div_func Callable [[ float ], float ] Diversity factor function coefficients required kv_ll float Line to line voltage in KV required max_pole_to_pole_distance float Maximum pole to pole distance in meter 100 power_factor float Power factor used to compute kva 0.9 adjustment_factor float Adjustment factor for adjusting kva 1.2 planned_avg_annual_growth float Planned average annual load growth rate in percentage 2 actual_avg_annual_growth float Actual average annual load growth rate in percentage 4 actual_years_in_operation float Actual years in operation 15 planned_years_in_operation float Planned years in operation 10 Raises: Type Description NegativeKVError If kv_ll is negative ZeroKVError If kv_ll is zero AdjustmentFactorNotInRangeError If invalid adjustement factor is passed PowerFactorNotInRangeError If power factor is not in valid range PoleToPoleDistanceNotInRange If pole to pole distance passed in invalid PercentageNotInRangeError If percentages passed are not valid OperationYearNotInRange If operation year passed is invalid Source code in shift\\primary_network_builder.py 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 def __init__ ( self , div_func : Callable [[ float ], float ], kv_ll : float , max_pole_to_pole_distance : float = 100 , power_factor : float = 0.9 , adjustment_factor : float = 1.2 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ) -> None : \"\"\"Constructor for `BaseNetworkBuilder` class. Args: div_func (Callable[[float], float]): Diversity factor function coefficients kv_ll (float): Line to line voltage in KV max_pole_to_pole_distance (float): Maximum pole to pole distance in meter power_factor (float): Power factor used to compute kva adjustment_factor (float): Adjustment factor for adjusting kva planned_avg_annual_growth (float): Planned average annual load growth rate in percentage actual_avg_annual_growth (float): Actual average annual load growth rate in percentage actual_years_in_operation (float): Actual years in operation planned_years_in_operation (float): Planned years in operation Raises: NegativeKVError: If `kv_ll` is negative ZeroKVError: If `kv_ll` is zero AdjustmentFactorNotInRangeError: If invalid adjustement factor is passed PowerFactorNotInRangeError: If power factor is not in valid range PoleToPoleDistanceNotInRange: If pole to pole distance passed in invalid PercentageNotInRangeError: If percentages passed are not valid OperationYearNotInRange: If operation year passed is invalid \"\"\" self . max_pole_to_pole_distance = max_pole_to_pole_distance self . div_func = div_func self . kv_ll = kv_ll self . adjustment_factor = adjustment_factor self . power_factor = power_factor self . planned_avg_annual_growth = planned_avg_annual_growth self . actual_avg_annual_growth = actual_avg_annual_growth self . actual_years_in_operation = actual_years_in_operation self . planned_years_in_operation = planned_years_in_operation if self . kv_ll < 0 : raise NegativeKVError ( self . kv_ll ) if self . kv_ll == 0 : raise ZeroKVError () if ( self . adjustment_factor < MIN_ADJUSTMENT_FACTOR or self . adjustment_factor > MAX_ADJUSTMENT_FACTOR ): raise AdjustmentFactorNotInRangeError ( self . adjustment_factor ) if ( self . power_factor < MIN_POWER_FACTOR or self . power_factor > MAX_POWER_FACTOR ): raise PowerFactorNotInRangeError ( self . power_factor ) if ( self . max_pole_to_pole_distance < MIN_POLE_TO_POLE_DISTANCE or self . max_pole_to_pole_distance > MAX_POLE_TO_POLE_DISTANCE ): raise PoleToPoleDistanceNotInRange ( self . max_pole_to_pole_distance ) if ( self . planned_avg_annual_growth < MIN_PERCENTAGE or self . planned_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . planned_avg_annual_growth ) if ( self . actual_avg_annual_growth < MIN_PERCENTAGE or self . actual_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . actual_avg_annual_growth ) if ( self . actual_years_in_operation < MIN_YEAR_OPERATION or self . actual_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . actual_years_in_operation ) if ( self . planned_years_in_operation < MIN_YEAR_OPERATION or self . planned_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . planned_years_in_operation ) update_network_with_ampacity () abstractmethod Abstract method for updating ampacity for all line sections. Source code in shift\\primary_network_builder.py 658 659 660 661 @abstractmethod def update_network_with_ampacity ( self ): \"\"\"Abstract method for updating ampacity for all line sections.\"\"\" pass BaseSectionsBuilder Interface for sections builder. Attributes: Name Type Description network nx . Graph Graph instance conductor_type ConductorType ConductorType instance geometry_configuration dict Line configuration data num_phase NumPhase NumPhase instance phase Phase Phase instance neutral_present bool Indicates whether neutral is present or not material str Conductor material overhead_conductor_catalog pd . DataFrame DataFrame containing catalogs for overhead conductors concentric_cable_catalog pd . DataFrame DataFrame containing catalogs for concentric cables catalog_dict dict Mapping between conductor type and conductor catalogs Source code in shift\\primary_network_builder.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 class BaseSectionsBuilder : \"\"\"Interface for sections builder. Attributes: network (nx.Graph): Graph instance conductor_type (ConductorType): ConductorType instance geometry_configuration (dict): Line configuration data num_phase (NumPhase): NumPhase instance phase (Phase): Phase instance neutral_present (bool): Indicates whether neutral is present or not material (str): Conductor material overhead_conductor_catalog (pd.DataFrame): DataFrame containing catalogs for overhead conductors concentric_cable_catalog (pd.DataFrame): DataFrame containing catalogs for concentric cables catalog_dict (dict): Mapping between conductor type and conductor catalogs \"\"\" def __init__ ( self , network : nx . Graph , conductor_type : ConductorType , configuration : dict , num_phase : NumPhase , phase : Phase , neutral_present : bool = False , material : str = \"all\" , ) -> None : \"\"\"Constructor for `BaseSectionsBuilder` class. Args: network (nx.Graph): Graph instance conductor_type (ConductorType): ConductorType instance configuration (dict): Line configuration data num_phase (NumPhase): NumPhase instance phase (Phase): Phase instance neutral_present (bool): Indicates whether neutral is present or not material (str): Conductor material \"\"\" self . network = network self . conductor_type = conductor_type self . geometry_configuration = configuration self . num_phase = num_phase self . neutral_present = neutral_present self . material = material self . phase = phase self . overhead_conductor_catalog = pd . read_excel ( OVERHEAD_CONDUCTOR_CATALOG_FILE ) df_validator ( OVERHEAD_CONDUCTOR_CATALAOG_SCHEMA , self . overhead_conductor_catalog ) self . concentric_cable_catalog = pd . read_excel ( UG_CONCENTRIC_CABLE_CATALOG_FILE ) df_validator ( UNDERGROUND_CONCENTRIC_CABLE_CATALOG_SCHEMA , self . concentric_cable_catalog , ) self . catalog_dict = { ConductorType . OVERHEAD : self . overhead_conductor_catalog , ConductorType . UNDERGROUND_CONCENTRIC : self . concentric_cable_catalog , } __init__ ( network , conductor_type , configuration , num_phase , phase , neutral_present = False , material = 'all' ) Constructor for BaseSectionsBuilder class. Parameters: Name Type Description Default network nx . Graph Graph instance required conductor_type ConductorType ConductorType instance required configuration dict Line configuration data required num_phase NumPhase NumPhase instance required phase Phase Phase instance required neutral_present bool Indicates whether neutral is present or not False material str Conductor material 'all' Source code in shift\\primary_network_builder.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 def __init__ ( self , network : nx . Graph , conductor_type : ConductorType , configuration : dict , num_phase : NumPhase , phase : Phase , neutral_present : bool = False , material : str = \"all\" , ) -> None : \"\"\"Constructor for `BaseSectionsBuilder` class. Args: network (nx.Graph): Graph instance conductor_type (ConductorType): ConductorType instance configuration (dict): Line configuration data num_phase (NumPhase): NumPhase instance phase (Phase): Phase instance neutral_present (bool): Indicates whether neutral is present or not material (str): Conductor material \"\"\" self . network = network self . conductor_type = conductor_type self . geometry_configuration = configuration self . num_phase = num_phase self . neutral_present = neutral_present self . material = material self . phase = phase self . overhead_conductor_catalog = pd . read_excel ( OVERHEAD_CONDUCTOR_CATALOG_FILE ) df_validator ( OVERHEAD_CONDUCTOR_CATALAOG_SCHEMA , self . overhead_conductor_catalog ) self . concentric_cable_catalog = pd . read_excel ( UG_CONCENTRIC_CABLE_CATALOG_FILE ) df_validator ( UNDERGROUND_CONCENTRIC_CABLE_CATALOG_SCHEMA , self . concentric_cable_catalog , ) self . catalog_dict = { ConductorType . OVERHEAD : self . overhead_conductor_catalog , ConductorType . UNDERGROUND_CONCENTRIC : self . concentric_cable_catalog , } PrimaryNetworkFromRoad Bases: BaseNetworkBuilder Builds primary network from OpenStreet road data. Refer to base class for base attributes. Attributes: Name Type Description road_network OpenStreetRoadNetwork OpenStreetRoadNetwork instance trans_cust_mapper dict Mapping between Transformer object and list of Load objects node_append_str Union [ str , None] Unique string to be appended to all primary nodes sliced_graph nx . Graph Sliced road network substation_node str Node representing substation substation_coords Sequence Actual substation coordinate retain_nodes List [ str ] List of primary nodes to be retained Source code in shift\\primary_network_builder.py 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 class PrimaryNetworkFromRoad ( BaseNetworkBuilder ): \"\"\"Builds primary network from OpenStreet road data. Refer to base class for base attributes. Attributes: road_network (OpenStreetRoadNetwork): OpenStreetRoadNetwork instance trans_cust_mapper (dict): Mapping between `Transformer` object and list of `Load` objects node_append_str (Union[str, None]): Unique string to be appended to all primary nodes sliced_graph (nx.Graph): Sliced road network substation_node (str): Node representing substation substation_coords (Sequence): Actual substation coordinate retain_nodes (List[str]): List of primary nodes to be retained \"\"\" def __init__ ( self , road_network : OpenStreetRoadNetwork , trans_cust_mapper : dict , substation_loc : tuple , div_func : Callable [[ float ], float ], kv_ll : float , max_pole_to_pole_distance : float = 100 , power_factor : float = 0.9 , adjustment_factor : float = 1.2 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , node_append_str : Union [ str , None ] = None , ) -> None : \"\"\"Constructor for `PrimaryNetworkFromRoad` class. Refer to base class for base class arguments. Args: road_network (OpenStreetRoadNetwork): OpenStreetRoadNetwork instance trans_cust_mapper (dict): Mapping between `Transformer` object and list of `Load` objects substation_loc (tuple): Tentative location for siting substation (longitude, latitude) pair node_append_str (Union[str, None]): Unique string to be appended to all primary nodes \"\"\" super () . __init__ ( div_func , kv_ll , max_pole_to_pole_distance , power_factor , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , ) # Get the road network from openstreet data self . node_append_str = node_append_str self . road_network = road_network self . road_network . get_network ( node_append_str ) self . trans_cust_mapper = trans_cust_mapper # Get sliced graph self . sliced_graph = slice_up_network_edges ( self . road_network . updated_network , self . max_pole_to_pole_distance ) # Get substation node self . substation_node = [ n for n in get_nearest_points_in_the_network ( self . sliced_graph , [ substation_loc ] ) ][ 0 ] self . substation_coords = self . sliced_graph . nodes [ self . substation_node ][ \"pos\" ] trans_location_to_retain = [ ( t . longitude , t . latitude ) for t in self . trans_cust_mapper ] self . retain_nodes = get_nearest_points_in_the_network ( self . sliced_graph , trans_location_to_retain + [ substation_loc ] ) def get_primary_network ( self ) -> nx . Graph : \"\"\"Algorithm to convert road network into distribution system primary network\"\"\" return ax . steinertree . steiner_tree ( self . sliced_graph , list ( self . retain_nodes . keys ()) ) def get_sliced_graph ( self ) -> nx . Graph : \"\"\"Return sliced graph\"\"\" return self . sliced_graph def get_network ( self ) -> nx . Graph : \"\"\"Returns a primary network with ampacity data. Raises: AttributeDoesNotExistError: If `update_network_with_ampacity` is not called first, absence of `network` attribute Returns: nx.Graph: primary network with ampacity data \"\"\" if hasattr ( self , \"network\" ): mapping_dict , relabel_rnodes = {}, {} for node in self . retain_nodes : node_new_name = \"_\" . join ( node . split ( \"_\" )[: 2 ]) + \"_htnode\" mapping_dict [ node ] = node_new_name relabel_rnodes [ node_new_name ] = self . retain_nodes [ node ] relable_snode = ( \"_\" . join ( self . substation_node . split ( \"_\" )[: 2 ]) + \"_ltnode\" ) mapping_dict [ self . substation_node ] = relable_snode relabel_rnodes [ relable_snode ] = self . retain_nodes [ self . substation_node ] self . network = nx . relabel_nodes ( self . network , mapping_dict ) self . retain_nodes = relabel_rnodes return self . network else : raise AttributeDoesNotExistError ( \"Please call 'update_network_with_ampacity' \\ method first before trying to access primary\" ) def get_trans_node_mapping ( self ) -> dict : \"\"\"Returns transformer to primary node mapping\"\"\" return self . retain_nodes def get_longest_length_in_kvameter ( self ) -> float : \"\"\"Returns longest length in kva meter\"\"\" return self . longest_length def update_network_with_ampacity ( self ) -> None : \"\"\"Method to update all line sections with ampacity\"\"\" # Get primary network tree self . network = self . get_primary_network () # Create a directed graph by providing source node \"\"\" dfs_tree = nx . dfs_tree ( self . network , source = self . substation_node ) # Mapping for transformer nodes \"\"\" transformer_nodes = {} for node , node_dict in self . retain_nodes . items (): for trans , cust_list in self . trans_cust_mapper . items (): if ( trans . longitude == node_dict [ \"centre\" ][ 0 ] and trans . latitude == node_dict [ \"centre\" ][ 1 ] ): transformer_nodes [ node ] = cust_list for edge in dfs_tree . edges (): # Compute distance from the source\"\"\" distance = nx . resistance_distance ( self . network , self . substation_node , edge [ 1 ] ) self . network [ edge [ 0 ]][ edge [ 1 ]][ \"distance\" ] = distance # Perform a depth first traversal to find all successor nodes\"\"\" dfs_successors = nx . dfs_successors ( dfs_tree , source = edge [ 1 ]) # Create a subgraph\"\"\" nodes_to_retain = [ edge [ 1 ]] for k , v in dfs_successors . items (): nodes_to_retain . extend ( v ) subgraph = self . network . subgraph ( nodes_to_retain ) # Let's compute maximum diversified kva demand downward of this edge\"\"\" noncoincident_kws = 0 num_of_customers = 0 for node in subgraph . nodes (): if node in transformer_nodes : num_of_customers += len ( transformer_nodes [ node ]) noncoincident_kws += sum ( [ l . kw for l in transformer_nodes [ node ]] ) self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] = self . _compute_ampacity ( noncoincident_kws , num_of_customers ) node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } bfs_tree = nx . bfs_tree ( self . network , self . substation_node ) for edge in bfs_tree . edges (): bfs_tree [ edge [ 0 ]][ edge [ 1 ]][ \"cost\" ] = ( get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ) * self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] * 1.732 * self . kv_ll ) self . longest_length = nx . dag_longest_path_length ( bfs_tree , weight = \"cost\" ) __init__ ( road_network , trans_cust_mapper , substation_loc , div_func , kv_ll , max_pole_to_pole_distance = 100 , power_factor = 0.9 , adjustment_factor = 1.2 , planned_avg_annual_growth = 2 , actual_avg_annual_growth = 4 , actual_years_in_operation = 15 , planned_years_in_operation = 10 , node_append_str = None ) Constructor for PrimaryNetworkFromRoad class. Refer to base class for base class arguments. Parameters: Name Type Description Default road_network OpenStreetRoadNetwork OpenStreetRoadNetwork instance required trans_cust_mapper dict Mapping between Transformer object and list of Load objects required substation_loc tuple Tentative location for siting substation (longitude, latitude) pair required node_append_str Union [ str , None] Unique string to be appended to all primary nodes None Source code in shift\\primary_network_builder.py 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 def __init__ ( self , road_network : OpenStreetRoadNetwork , trans_cust_mapper : dict , substation_loc : tuple , div_func : Callable [[ float ], float ], kv_ll : float , max_pole_to_pole_distance : float = 100 , power_factor : float = 0.9 , adjustment_factor : float = 1.2 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , node_append_str : Union [ str , None ] = None , ) -> None : \"\"\"Constructor for `PrimaryNetworkFromRoad` class. Refer to base class for base class arguments. Args: road_network (OpenStreetRoadNetwork): OpenStreetRoadNetwork instance trans_cust_mapper (dict): Mapping between `Transformer` object and list of `Load` objects substation_loc (tuple): Tentative location for siting substation (longitude, latitude) pair node_append_str (Union[str, None]): Unique string to be appended to all primary nodes \"\"\" super () . __init__ ( div_func , kv_ll , max_pole_to_pole_distance , power_factor , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , ) # Get the road network from openstreet data self . node_append_str = node_append_str self . road_network = road_network self . road_network . get_network ( node_append_str ) self . trans_cust_mapper = trans_cust_mapper # Get sliced graph self . sliced_graph = slice_up_network_edges ( self . road_network . updated_network , self . max_pole_to_pole_distance ) # Get substation node self . substation_node = [ n for n in get_nearest_points_in_the_network ( self . sliced_graph , [ substation_loc ] ) ][ 0 ] self . substation_coords = self . sliced_graph . nodes [ self . substation_node ][ \"pos\" ] trans_location_to_retain = [ ( t . longitude , t . latitude ) for t in self . trans_cust_mapper ] self . retain_nodes = get_nearest_points_in_the_network ( self . sliced_graph , trans_location_to_retain + [ substation_loc ] ) get_longest_length_in_kvameter () Returns longest length in kva meter Source code in shift\\primary_network_builder.py 796 797 798 def get_longest_length_in_kvameter ( self ) -> float : \"\"\"Returns longest length in kva meter\"\"\" return self . longest_length get_network () Returns a primary network with ampacity data. Raises: Type Description AttributeDoesNotExistError If update_network_with_ampacity is not called first, absence of network attribute Returns: Type Description nx . Graph nx.Graph: primary network with ampacity data Source code in shift\\primary_network_builder.py 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 def get_network ( self ) -> nx . Graph : \"\"\"Returns a primary network with ampacity data. Raises: AttributeDoesNotExistError: If `update_network_with_ampacity` is not called first, absence of `network` attribute Returns: nx.Graph: primary network with ampacity data \"\"\" if hasattr ( self , \"network\" ): mapping_dict , relabel_rnodes = {}, {} for node in self . retain_nodes : node_new_name = \"_\" . join ( node . split ( \"_\" )[: 2 ]) + \"_htnode\" mapping_dict [ node ] = node_new_name relabel_rnodes [ node_new_name ] = self . retain_nodes [ node ] relable_snode = ( \"_\" . join ( self . substation_node . split ( \"_\" )[: 2 ]) + \"_ltnode\" ) mapping_dict [ self . substation_node ] = relable_snode relabel_rnodes [ relable_snode ] = self . retain_nodes [ self . substation_node ] self . network = nx . relabel_nodes ( self . network , mapping_dict ) self . retain_nodes = relabel_rnodes return self . network else : raise AttributeDoesNotExistError ( \"Please call 'update_network_with_ampacity' \\ method first before trying to access primary\" ) get_primary_network () Algorithm to convert road network into distribution system primary network Source code in shift\\primary_network_builder.py 747 748 749 750 751 def get_primary_network ( self ) -> nx . Graph : \"\"\"Algorithm to convert road network into distribution system primary network\"\"\" return ax . steinertree . steiner_tree ( self . sliced_graph , list ( self . retain_nodes . keys ()) ) get_sliced_graph () Return sliced graph Source code in shift\\primary_network_builder.py 753 754 755 def get_sliced_graph ( self ) -> nx . Graph : \"\"\"Return sliced graph\"\"\" return self . sliced_graph get_trans_node_mapping () Returns transformer to primary node mapping Source code in shift\\primary_network_builder.py 792 793 794 def get_trans_node_mapping ( self ) -> dict : \"\"\"Returns transformer to primary node mapping\"\"\" return self . retain_nodes update_network_with_ampacity () Method to update all line sections with ampacity Source code in shift\\primary_network_builder.py 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 def update_network_with_ampacity ( self ) -> None : \"\"\"Method to update all line sections with ampacity\"\"\" # Get primary network tree self . network = self . get_primary_network () # Create a directed graph by providing source node \"\"\" dfs_tree = nx . dfs_tree ( self . network , source = self . substation_node ) # Mapping for transformer nodes \"\"\" transformer_nodes = {} for node , node_dict in self . retain_nodes . items (): for trans , cust_list in self . trans_cust_mapper . items (): if ( trans . longitude == node_dict [ \"centre\" ][ 0 ] and trans . latitude == node_dict [ \"centre\" ][ 1 ] ): transformer_nodes [ node ] = cust_list for edge in dfs_tree . edges (): # Compute distance from the source\"\"\" distance = nx . resistance_distance ( self . network , self . substation_node , edge [ 1 ] ) self . network [ edge [ 0 ]][ edge [ 1 ]][ \"distance\" ] = distance # Perform a depth first traversal to find all successor nodes\"\"\" dfs_successors = nx . dfs_successors ( dfs_tree , source = edge [ 1 ]) # Create a subgraph\"\"\" nodes_to_retain = [ edge [ 1 ]] for k , v in dfs_successors . items (): nodes_to_retain . extend ( v ) subgraph = self . network . subgraph ( nodes_to_retain ) # Let's compute maximum diversified kva demand downward of this edge\"\"\" noncoincident_kws = 0 num_of_customers = 0 for node in subgraph . nodes (): if node in transformer_nodes : num_of_customers += len ( transformer_nodes [ node ]) noncoincident_kws += sum ( [ l . kw for l in transformer_nodes [ node ]] ) self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] = self . _compute_ampacity ( noncoincident_kws , num_of_customers ) node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } bfs_tree = nx . bfs_tree ( self . network , self . substation_node ) for edge in bfs_tree . edges (): bfs_tree [ edge [ 0 ]][ edge [ 1 ]][ \"cost\" ] = ( get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ) * self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] * 1.732 * self . kv_ll ) self . longest_length = nx . dag_longest_path_length ( bfs_tree , weight = \"cost\" ) PrimarySectionsBuilder Bases: BaseSectionsBuilder Class handling generation of primary line sections. Source code in shift\\primary_network_builder.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 class PrimarySectionsBuilder ( BaseSectionsBuilder ): \"\"\"Class handling generation of primary line sections.\"\"\" def generate_primary_line_sections ( self , k_drop : float , kv_base : float ) -> List [ Line ]: \"\"\"Method for creating primary line sections. Args: k_drop (float): Expected percentage voltage drop per mile per kva kv_base (float): KV base used for computing kVA Returns: List[Line]: List of `Line` instances \"\"\" line_sections = [] node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } for edge in self . network . edges (): edge_data = self . network . get_edge_data ( * edge ) if self . num_phase not in self . geometry_configuration : raise IncompleteGeometryConfigurationDict ( self . num_phase , self . geometry_configuration ) line_section = geometry_based_line_section_builder ( edge [ 0 ], edge [ 1 ], self . num_phase , self . phase , self . phase , get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ), \"m\" , edge_data [ \"ampacity\" ], self . catalog_dict [ self . conductor_type ], self . neutral_present , self . conductor_type , self . geometry_configuration [ self . num_phase ], k_drop , kv_base , self . material , ) line_sections . append ( line_section ) return line_sections generate_primary_line_sections ( k_drop , kv_base ) Method for creating primary line sections. Parameters: Name Type Description Default k_drop float Expected percentage voltage drop per mile per kva required kv_base float KV base used for computing kVA required Returns: Type Description List [ Line ] List[Line]: List of Line instances Source code in shift\\primary_network_builder.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def generate_primary_line_sections ( self , k_drop : float , kv_base : float ) -> List [ Line ]: \"\"\"Method for creating primary line sections. Args: k_drop (float): Expected percentage voltage drop per mile per kva kv_base (float): KV base used for computing kVA Returns: List[Line]: List of `Line` instances \"\"\" line_sections = [] node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } for edge in self . network . edges (): edge_data = self . network . get_edge_data ( * edge ) if self . num_phase not in self . geometry_configuration : raise IncompleteGeometryConfigurationDict ( self . num_phase , self . geometry_configuration ) line_section = geometry_based_line_section_builder ( edge [ 0 ], edge [ 1 ], self . num_phase , self . phase , self . phase , get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ), \"m\" , edge_data [ \"ampacity\" ], self . catalog_dict [ self . conductor_type ], self . neutral_present , self . conductor_type , self . geometry_configuration [ self . num_phase ], k_drop , kv_base , self . material , ) line_sections . append ( line_section ) return line_sections choose_conductor ( catalog , ampacity , k_drop , geometry_configuration , num_of_phase , kv_base , pf = 0.9 ) Handles selection of conductor from the catalog. Parameters: Name Type Description Default catalog pd . DataFrame Dataframe containing all the catalogs required ampacity float Minimum ampacity required required k_drop float Percentage drop per kva per miles expected required geometry_configuration LineGeometryConfiguration LineGeometryConfiguration instance required num_of_phase NumPhase NumPhase Instance required kv_base float Line to line kv base to be used to compute kva required pf float Power factor to be used to compute kva 0.9 Raises: Type Description CatalogNotFoundError If the catalog record is not found for given ampacity Returns: Name Type Description dict dict Catalog record in dict format Source code in shift\\primary_network_builder.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def choose_conductor ( catalog : pd . DataFrame , ampacity : float , k_drop : float , geometry_configuration : LineGeometryConfiguration , num_of_phase : NumPhase , kv_base : float , pf : float = 0.9 , ) -> dict : \"\"\"Handles selection of conductor from the catalog. Args: catalog (pd.DataFrame): Dataframe containing all the catalogs ampacity (float): Minimum ampacity required k_drop (float): Percentage drop per kva per miles expected geometry_configuration (LineGeometryConfiguration): LineGeometryConfiguration instance num_of_phase (NumPhase): NumPhase Instance kv_base (float): Line to line kv base to be used to compute kva pf (float): Power factor to be used to compute kva Raises: CatalogNotFoundError: If the catalog record is not found for given ampacity Returns: dict: Catalog record in dict format \"\"\" # First thing is to find catalog for higher amps than required conductors_above_ampacity = catalog [ catalog [ \"ampacity\" ] > ampacity ] if conductors_above_ampacity . empty : raise CatalogNotFoundError ( f \"No conductor exists for ampacity { ampacity } A in the filtered set!\" ) conductors_above_ampacity = conductors_above_ampacity . sort_values ( by = [ \"ampacity\" ] ) for record in conductors_above_ampacity . to_dict ( orient = \"records\" ): # Get configuration array for conductors x_array = geometry_configuration . get_x_array ()[: num_of_phase ] # Compute the equivalent distance deq = ( np . power ( np . prod ( [ abs ( el [ 0 ] - el [ 1 ]) for el in itertools . combinations ( x_array , 2 ) ] ), 1 / len ( x_array ), ) if len ( x_array ) != 1 else record [ \"gmrac\" ] ) # Get the unit for deq deq_unit = ( geometry_configuration . unit if len ( x_array ) != 1 else record [ \"gmrunit\" ] ) # Convert deq to ft deq_ft = deq * LENGTH_CONVERTER_TO_CM [ deq_unit ] * 0.0328084 # Convert gmr to ft gmr_ft = ( record [ \"gmrac\" ] * LENGTH_CONVERTER_TO_CM [ record [ \"gmrunit\" ]] * 0.0328084 ) # Convert rac to ohm/mile r_mile = ( record [ \"rac\" ] * LENGTH_CONVERTER_TO_CM [ record [ \"runit\" ]] / 160934 ) # Compute positive sequence impedance ohm/mile zpos = complex ( r_mile , 0.12134 * np . log ( deq_ft / gmr_ft )) # Current current = complex ( ampacity * pf , - ampacity * np . power ( 1 - pf * pf , 1 / 2 ) ) # voltage drop vdrop_pct = ( ( zpos * current ) . real * 100 * math . sqrt ( 3 ) / ( kv_base * 1000 ) ) # Compute kdrop if ampacity == 0 : ampacity = 1 k_drop_computed = vdrop_pct / ( ampacity * kv_base * math . sqrt ( 3 )) # print('k_drop : ', k_drop, k_drop_computed, record['name'], record['ampacity']) if k_drop_computed <= k_drop : return record # print(k_drop_computed, k_drop, ampacity, record) # raise ConductorNotFoundForKdrop(k_drop) return record convert_oh_cond_info_to_wire ( data ) Converts catalog record into wire object. Parameters: Name Type Description Default data dict Catalog record required Returns: Name Type Description Wire Wire Wire object instance Source code in shift\\primary_network_builder.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def convert_oh_cond_info_to_wire ( data : dict ) -> Wire : \"\"\"Converts catalog record into wire object. Args: data (dict): Catalog record Returns: Wire: Wire object instance \"\"\" data = copy . deepcopy ( data ) wire = Wire () wire . name = data [ \"name\" ] wire . diam = data [ \"diameter\" ] wire . gmrac = data [ \"gmrac\" ] wire . gmrunits = data [ \"gmrunit\" ] wire . normamps = data [ \"ampacity\" ] wire . rac = data [ \"rac\" ] wire . runits = data [ \"runit\" ] wire . radunits = data [ \"diameterunit\" ] return wire convert_ug_cond_info_to_cable ( data ) Converts catalog record into cable object. Parameters: Name Type Description Default data dict Catalog record required Returns: Name Type Description Cable Cable Cable object instance Source code in shift\\primary_network_builder.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def convert_ug_cond_info_to_cable ( data : dict ) -> Cable : \"\"\"Converts catalog record into cable object. Args: data (dict): Catalog record Returns: Cable: Cable object instance \"\"\" data = copy . deepcopy ( data ) cable = Cable () cable . name = data [ \"name\" ] cable . diam = data [ \"diam\" ] cable . gmrac = data [ \"gmrac\" ] cable . gmrunits = data [ \"gmrunit\" ] cable . normamps = data [ \"ampacity\" ] cable . rac = data [ \"rac\" ] cable . runits = data [ \"runit\" ] cable . radunits = data [ \"radunits\" ] cable . inslayer = data [ \"inslayer\" ] cable . diains = data [ \"diains\" ] cable . diacable = data [ \"diacable\" ] cable . rstrand = data [ \"rstrand\" ] cable . gmrstrand = data [ \"gmrstrand\" ] cable . diastrand = data [ \"diastrand\" ] cable . k = data [ \"k\" ] return cable geometry_based_line_section_builder ( from_node , to_node , num_phase , from_phase , to_phase , length , length_unit , ampacity , catalog , neutral_present , conductor_type , geometry_configuration , k_drop , kv_base , material = 'all' ) Builds a line section. Parameters: Name Type Description Default from_node str From node required to_node str To node required num_phase NumPhase NumPhase Instance required from_phase Phase Phase instance for from node required to_phase Phase Phase instance for to node required length float Length of line segment required length_unit str Unit for line length required ampacity float Ampacity for the conductor required catalog pd . DataFrame DataFrame containing all the catalaogs required neutral_present bool Indicates whether neutral is present or not required conductor_type ConductorType ConductorType instance required geometry_configuration LineGeometryConfiguration LineGeometryConfiguration instance required k_drop float Expected percentage voltage drop per kva per mile required kv_base float kV base for computing kVA required material str Material for choosing conductor 'all' Raises: Type Description EmptyCatalog If the material is not found in catalog Returns: Name Type Description Line Line Line instance Source code in shift\\primary_network_builder.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def geometry_based_line_section_builder ( from_node : str , to_node : str , num_phase : NumPhase , from_phase : Phase , to_phase : Phase , length : float , length_unit : str , ampacity : float , catalog : pd . DataFrame , neutral_present : bool , conductor_type : ConductorType , geometry_configuration : LineGeometryConfiguration , k_drop : float , kv_base : float , material : str = \"all\" , ) -> Line : \"\"\"Builds a line section. Args: from_node (str): From node to_node (str): To node num_phase (NumPhase): NumPhase Instance from_phase (Phase): Phase instance for from node to_phase (Phase): Phase instance for to node length (float): Length of line segment length_unit (str): Unit for line length ampacity (float): Ampacity for the conductor catalog (pd.DataFrame): DataFrame containing all the catalaogs neutral_present (bool): Indicates whether neutral is present or not conductor_type (ConductorType): ConductorType instance geometry_configuration (LineGeometryConfiguration): LineGeometryConfiguration instance k_drop (float): Expected percentage voltage drop per kva per mile kv_base (float): kV base for computing kVA material (str): Material for choosing conductor Raises: EmptyCatalog: If the material is not found in catalog Returns: Line: Line instance \"\"\" if material != \"all\" : catalog = catalog . loc [ catalog [ \"material\" ] == material ] if catalog . empty : raise EmptyCatalog ( f \"Catalog of material { material } not found!\" ) line_section = GeometryBasedLine () line_section . name = from_node + \"__\" + to_node line_section . fromnode = from_node line_section . tonode = to_node line_section . length = length line_section . length_unit = length_unit line_section . num_phase = num_phase line_section . fromnode_phase = from_phase line_section . tonode_phase = to_phase # Get the geometry object if conductor_type == ConductorType . OVERHEAD : if neutral_present : line_geometry = OverheadLinewithNeutralGeometry () # Let's find the condcutor to be used phase_cond_dict = choose_conductor ( catalog , ampacity , k_drop , geometry_configuration , num_phase . value , kv_base , ) # catalog.loc[catalog[catalog['ampacity']>ampacity]['ampacity'].idxmin()].to_dict() line_geometry . phase_wire = convert_oh_cond_info_to_wire ( phase_cond_dict ) # Assuming neutral conductor would be one third of phase conductor ampacity for multi phase else same as phase conductor neutral_cond_dict = ( phase_cond_dict if num_phase == NumPhase . SINGLE else choose_conductor ( catalog , ampacity / 3 , k_drop , geometry_configuration , num_phase . value , kv_base , ) ) line_geometry . neutral_wire = convert_oh_cond_info_to_wire ( neutral_cond_dict ) line_geometry . num_conds = num_phase . value + 1 else : line_geometry = OverheadLineGeometry () phase_cond_dict = choose_conductor ( catalog , ampacity , k_drop , geometry_configuration , num_phase . value , kv_base , ) line_geometry . phase_wire = convert_oh_cond_info_to_wire ( phase_cond_dict ) line_geometry . num_conds = num_phase . value else : line_geometry = UndergroundLineGeometry () if num_phase == NumPhase . THREE : catalog = catalog [ catalog [ \"neutral_type\" ] == \"1/3 Neutral\" ] else : catalog = catalog [ catalog [ \"neutral_type\" ] == \"Full Neutral\" ] cable_dict = choose_conductor ( catalog , ampacity , k_drop , geometry_configuration , num_phase . value , kv_base , ) line_geometry . phase_cable = convert_ug_cond_info_to_cable ( cable_dict ) line_geometry . num_conds = num_phase . value line_geometry . name = str ( uuid . uuid4 ()) + \"_linegeometry\" line_geometry . num_phase = num_phase line_geometry . configuration = geometry_configuration line_section . geometry = line_geometry return line_section","title":"primary_network_builder"},{"location":"primary_network_builder/#shift.primary_network_builder.BaseNetworkBuilder","text":"Bases: ABC Interface for building distribution network. Attributes: Name Type Description div_func Callable [[ float ], float ] Diversity factor function coefficients kv_ll float Line to line voltage in KV max_pole_to_pole_distance float Maximum pole to pole distance in meter power_factor float Power factor used to compute kva adjustment_factor float Adjustment factor for adjusting kva planned_avg_annual_growth float Planned average annual load growth rate in percentage actual_avg_annual_growth float Actual average annual load growth rate in percentage actual_years_in_operation float Actual years in operation planned_years_in_operation float Planned years in operation Source code in shift\\primary_network_builder.py 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 class BaseNetworkBuilder ( ABC ): \"\"\"Interface for building distribution network. Attributes: div_func (Callable[[float], float]): Diversity factor function coefficients kv_ll (float): Line to line voltage in KV max_pole_to_pole_distance (float): Maximum pole to pole distance in meter power_factor (float): Power factor used to compute kva adjustment_factor (float): Adjustment factor for adjusting kva planned_avg_annual_growth (float): Planned average annual load growth rate in percentage actual_avg_annual_growth (float): Actual average annual load growth rate in percentage actual_years_in_operation (float): Actual years in operation planned_years_in_operation (float): Planned years in operation \"\"\" def __init__ ( self , div_func : Callable [[ float ], float ], kv_ll : float , max_pole_to_pole_distance : float = 100 , power_factor : float = 0.9 , adjustment_factor : float = 1.2 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ) -> None : \"\"\"Constructor for `BaseNetworkBuilder` class. Args: div_func (Callable[[float], float]): Diversity factor function coefficients kv_ll (float): Line to line voltage in KV max_pole_to_pole_distance (float): Maximum pole to pole distance in meter power_factor (float): Power factor used to compute kva adjustment_factor (float): Adjustment factor for adjusting kva planned_avg_annual_growth (float): Planned average annual load growth rate in percentage actual_avg_annual_growth (float): Actual average annual load growth rate in percentage actual_years_in_operation (float): Actual years in operation planned_years_in_operation (float): Planned years in operation Raises: NegativeKVError: If `kv_ll` is negative ZeroKVError: If `kv_ll` is zero AdjustmentFactorNotInRangeError: If invalid adjustement factor is passed PowerFactorNotInRangeError: If power factor is not in valid range PoleToPoleDistanceNotInRange: If pole to pole distance passed in invalid PercentageNotInRangeError: If percentages passed are not valid OperationYearNotInRange: If operation year passed is invalid \"\"\" self . max_pole_to_pole_distance = max_pole_to_pole_distance self . div_func = div_func self . kv_ll = kv_ll self . adjustment_factor = adjustment_factor self . power_factor = power_factor self . planned_avg_annual_growth = planned_avg_annual_growth self . actual_avg_annual_growth = actual_avg_annual_growth self . actual_years_in_operation = actual_years_in_operation self . planned_years_in_operation = planned_years_in_operation if self . kv_ll < 0 : raise NegativeKVError ( self . kv_ll ) if self . kv_ll == 0 : raise ZeroKVError () if ( self . adjustment_factor < MIN_ADJUSTMENT_FACTOR or self . adjustment_factor > MAX_ADJUSTMENT_FACTOR ): raise AdjustmentFactorNotInRangeError ( self . adjustment_factor ) if ( self . power_factor < MIN_POWER_FACTOR or self . power_factor > MAX_POWER_FACTOR ): raise PowerFactorNotInRangeError ( self . power_factor ) if ( self . max_pole_to_pole_distance < MIN_POLE_TO_POLE_DISTANCE or self . max_pole_to_pole_distance > MAX_POLE_TO_POLE_DISTANCE ): raise PoleToPoleDistanceNotInRange ( self . max_pole_to_pole_distance ) if ( self . planned_avg_annual_growth < MIN_PERCENTAGE or self . planned_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . planned_avg_annual_growth ) if ( self . actual_avg_annual_growth < MIN_PERCENTAGE or self . actual_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . actual_avg_annual_growth ) if ( self . actual_years_in_operation < MIN_YEAR_OPERATION or self . actual_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . actual_years_in_operation ) if ( self . planned_years_in_operation < MIN_YEAR_OPERATION or self . planned_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . planned_years_in_operation ) def _compute_ampacity ( self , non_coincident_peak : float , num_of_customers : int ) -> float : \"\"\"Private method to compute ampacity. Args: non_coincident_peak (float): Non coincident peak consumption num_of_customers (int): Number of customers Returns: float: conductor ampacity \"\"\" # Initial step is to compute maximum diversified demand div_factor = ( self . div_func ( num_of_customers ) if num_of_customers > 1 else 1 ) max_diversified_demand = non_coincident_peak / div_factor max_diversified_kva = ( max_diversified_demand * self . adjustment_factor / self . power_factor ) max_diversified_ampacity = max_diversified_kva / ( 1.732 * self . kv_ll ) original_max_diversified_ampacity = max_diversified_ampacity / math . pow ( 1 + self . actual_avg_annual_growth / 100 , self . actual_years_in_operation , ) conductor_ampacity = original_max_diversified_ampacity * math . pow ( 1 + self . planned_avg_annual_growth / 100 , self . planned_years_in_operation , ) return conductor_ampacity @abstractmethod def update_network_with_ampacity ( self ): \"\"\"Abstract method for updating ampacity for all line sections.\"\"\" pass","title":"BaseNetworkBuilder"},{"location":"primary_network_builder/#shift.primary_network_builder.BaseNetworkBuilder.__init__","text":"Constructor for BaseNetworkBuilder class. Parameters: Name Type Description Default div_func Callable [[ float ], float ] Diversity factor function coefficients required kv_ll float Line to line voltage in KV required max_pole_to_pole_distance float Maximum pole to pole distance in meter 100 power_factor float Power factor used to compute kva 0.9 adjustment_factor float Adjustment factor for adjusting kva 1.2 planned_avg_annual_growth float Planned average annual load growth rate in percentage 2 actual_avg_annual_growth float Actual average annual load growth rate in percentage 4 actual_years_in_operation float Actual years in operation 15 planned_years_in_operation float Planned years in operation 10 Raises: Type Description NegativeKVError If kv_ll is negative ZeroKVError If kv_ll is zero AdjustmentFactorNotInRangeError If invalid adjustement factor is passed PowerFactorNotInRangeError If power factor is not in valid range PoleToPoleDistanceNotInRange If pole to pole distance passed in invalid PercentageNotInRangeError If percentages passed are not valid OperationYearNotInRange If operation year passed is invalid Source code in shift\\primary_network_builder.py 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 def __init__ ( self , div_func : Callable [[ float ], float ], kv_ll : float , max_pole_to_pole_distance : float = 100 , power_factor : float = 0.9 , adjustment_factor : float = 1.2 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ) -> None : \"\"\"Constructor for `BaseNetworkBuilder` class. Args: div_func (Callable[[float], float]): Diversity factor function coefficients kv_ll (float): Line to line voltage in KV max_pole_to_pole_distance (float): Maximum pole to pole distance in meter power_factor (float): Power factor used to compute kva adjustment_factor (float): Adjustment factor for adjusting kva planned_avg_annual_growth (float): Planned average annual load growth rate in percentage actual_avg_annual_growth (float): Actual average annual load growth rate in percentage actual_years_in_operation (float): Actual years in operation planned_years_in_operation (float): Planned years in operation Raises: NegativeKVError: If `kv_ll` is negative ZeroKVError: If `kv_ll` is zero AdjustmentFactorNotInRangeError: If invalid adjustement factor is passed PowerFactorNotInRangeError: If power factor is not in valid range PoleToPoleDistanceNotInRange: If pole to pole distance passed in invalid PercentageNotInRangeError: If percentages passed are not valid OperationYearNotInRange: If operation year passed is invalid \"\"\" self . max_pole_to_pole_distance = max_pole_to_pole_distance self . div_func = div_func self . kv_ll = kv_ll self . adjustment_factor = adjustment_factor self . power_factor = power_factor self . planned_avg_annual_growth = planned_avg_annual_growth self . actual_avg_annual_growth = actual_avg_annual_growth self . actual_years_in_operation = actual_years_in_operation self . planned_years_in_operation = planned_years_in_operation if self . kv_ll < 0 : raise NegativeKVError ( self . kv_ll ) if self . kv_ll == 0 : raise ZeroKVError () if ( self . adjustment_factor < MIN_ADJUSTMENT_FACTOR or self . adjustment_factor > MAX_ADJUSTMENT_FACTOR ): raise AdjustmentFactorNotInRangeError ( self . adjustment_factor ) if ( self . power_factor < MIN_POWER_FACTOR or self . power_factor > MAX_POWER_FACTOR ): raise PowerFactorNotInRangeError ( self . power_factor ) if ( self . max_pole_to_pole_distance < MIN_POLE_TO_POLE_DISTANCE or self . max_pole_to_pole_distance > MAX_POLE_TO_POLE_DISTANCE ): raise PoleToPoleDistanceNotInRange ( self . max_pole_to_pole_distance ) if ( self . planned_avg_annual_growth < MIN_PERCENTAGE or self . planned_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . planned_avg_annual_growth ) if ( self . actual_avg_annual_growth < MIN_PERCENTAGE or self . actual_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . actual_avg_annual_growth ) if ( self . actual_years_in_operation < MIN_YEAR_OPERATION or self . actual_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . actual_years_in_operation ) if ( self . planned_years_in_operation < MIN_YEAR_OPERATION or self . planned_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . planned_years_in_operation )","title":"__init__()"},{"location":"primary_network_builder/#shift.primary_network_builder.BaseNetworkBuilder.update_network_with_ampacity","text":"Abstract method for updating ampacity for all line sections. Source code in shift\\primary_network_builder.py 658 659 660 661 @abstractmethod def update_network_with_ampacity ( self ): \"\"\"Abstract method for updating ampacity for all line sections.\"\"\" pass","title":"update_network_with_ampacity()"},{"location":"primary_network_builder/#shift.primary_network_builder.BaseSectionsBuilder","text":"Interface for sections builder. Attributes: Name Type Description network nx . Graph Graph instance conductor_type ConductorType ConductorType instance geometry_configuration dict Line configuration data num_phase NumPhase NumPhase instance phase Phase Phase instance neutral_present bool Indicates whether neutral is present or not material str Conductor material overhead_conductor_catalog pd . DataFrame DataFrame containing catalogs for overhead conductors concentric_cable_catalog pd . DataFrame DataFrame containing catalogs for concentric cables catalog_dict dict Mapping between conductor type and conductor catalogs Source code in shift\\primary_network_builder.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 class BaseSectionsBuilder : \"\"\"Interface for sections builder. Attributes: network (nx.Graph): Graph instance conductor_type (ConductorType): ConductorType instance geometry_configuration (dict): Line configuration data num_phase (NumPhase): NumPhase instance phase (Phase): Phase instance neutral_present (bool): Indicates whether neutral is present or not material (str): Conductor material overhead_conductor_catalog (pd.DataFrame): DataFrame containing catalogs for overhead conductors concentric_cable_catalog (pd.DataFrame): DataFrame containing catalogs for concentric cables catalog_dict (dict): Mapping between conductor type and conductor catalogs \"\"\" def __init__ ( self , network : nx . Graph , conductor_type : ConductorType , configuration : dict , num_phase : NumPhase , phase : Phase , neutral_present : bool = False , material : str = \"all\" , ) -> None : \"\"\"Constructor for `BaseSectionsBuilder` class. Args: network (nx.Graph): Graph instance conductor_type (ConductorType): ConductorType instance configuration (dict): Line configuration data num_phase (NumPhase): NumPhase instance phase (Phase): Phase instance neutral_present (bool): Indicates whether neutral is present or not material (str): Conductor material \"\"\" self . network = network self . conductor_type = conductor_type self . geometry_configuration = configuration self . num_phase = num_phase self . neutral_present = neutral_present self . material = material self . phase = phase self . overhead_conductor_catalog = pd . read_excel ( OVERHEAD_CONDUCTOR_CATALOG_FILE ) df_validator ( OVERHEAD_CONDUCTOR_CATALAOG_SCHEMA , self . overhead_conductor_catalog ) self . concentric_cable_catalog = pd . read_excel ( UG_CONCENTRIC_CABLE_CATALOG_FILE ) df_validator ( UNDERGROUND_CONCENTRIC_CABLE_CATALOG_SCHEMA , self . concentric_cable_catalog , ) self . catalog_dict = { ConductorType . OVERHEAD : self . overhead_conductor_catalog , ConductorType . UNDERGROUND_CONCENTRIC : self . concentric_cable_catalog , }","title":"BaseSectionsBuilder"},{"location":"primary_network_builder/#shift.primary_network_builder.BaseSectionsBuilder.__init__","text":"Constructor for BaseSectionsBuilder class. Parameters: Name Type Description Default network nx . Graph Graph instance required conductor_type ConductorType ConductorType instance required configuration dict Line configuration data required num_phase NumPhase NumPhase instance required phase Phase Phase instance required neutral_present bool Indicates whether neutral is present or not False material str Conductor material 'all' Source code in shift\\primary_network_builder.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 def __init__ ( self , network : nx . Graph , conductor_type : ConductorType , configuration : dict , num_phase : NumPhase , phase : Phase , neutral_present : bool = False , material : str = \"all\" , ) -> None : \"\"\"Constructor for `BaseSectionsBuilder` class. Args: network (nx.Graph): Graph instance conductor_type (ConductorType): ConductorType instance configuration (dict): Line configuration data num_phase (NumPhase): NumPhase instance phase (Phase): Phase instance neutral_present (bool): Indicates whether neutral is present or not material (str): Conductor material \"\"\" self . network = network self . conductor_type = conductor_type self . geometry_configuration = configuration self . num_phase = num_phase self . neutral_present = neutral_present self . material = material self . phase = phase self . overhead_conductor_catalog = pd . read_excel ( OVERHEAD_CONDUCTOR_CATALOG_FILE ) df_validator ( OVERHEAD_CONDUCTOR_CATALAOG_SCHEMA , self . overhead_conductor_catalog ) self . concentric_cable_catalog = pd . read_excel ( UG_CONCENTRIC_CABLE_CATALOG_FILE ) df_validator ( UNDERGROUND_CONCENTRIC_CABLE_CATALOG_SCHEMA , self . concentric_cable_catalog , ) self . catalog_dict = { ConductorType . OVERHEAD : self . overhead_conductor_catalog , ConductorType . UNDERGROUND_CONCENTRIC : self . concentric_cable_catalog , }","title":"__init__()"},{"location":"primary_network_builder/#shift.primary_network_builder.PrimaryNetworkFromRoad","text":"Bases: BaseNetworkBuilder Builds primary network from OpenStreet road data. Refer to base class for base attributes. Attributes: Name Type Description road_network OpenStreetRoadNetwork OpenStreetRoadNetwork instance trans_cust_mapper dict Mapping between Transformer object and list of Load objects node_append_str Union [ str , None] Unique string to be appended to all primary nodes sliced_graph nx . Graph Sliced road network substation_node str Node representing substation substation_coords Sequence Actual substation coordinate retain_nodes List [ str ] List of primary nodes to be retained Source code in shift\\primary_network_builder.py 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 class PrimaryNetworkFromRoad ( BaseNetworkBuilder ): \"\"\"Builds primary network from OpenStreet road data. Refer to base class for base attributes. Attributes: road_network (OpenStreetRoadNetwork): OpenStreetRoadNetwork instance trans_cust_mapper (dict): Mapping between `Transformer` object and list of `Load` objects node_append_str (Union[str, None]): Unique string to be appended to all primary nodes sliced_graph (nx.Graph): Sliced road network substation_node (str): Node representing substation substation_coords (Sequence): Actual substation coordinate retain_nodes (List[str]): List of primary nodes to be retained \"\"\" def __init__ ( self , road_network : OpenStreetRoadNetwork , trans_cust_mapper : dict , substation_loc : tuple , div_func : Callable [[ float ], float ], kv_ll : float , max_pole_to_pole_distance : float = 100 , power_factor : float = 0.9 , adjustment_factor : float = 1.2 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , node_append_str : Union [ str , None ] = None , ) -> None : \"\"\"Constructor for `PrimaryNetworkFromRoad` class. Refer to base class for base class arguments. Args: road_network (OpenStreetRoadNetwork): OpenStreetRoadNetwork instance trans_cust_mapper (dict): Mapping between `Transformer` object and list of `Load` objects substation_loc (tuple): Tentative location for siting substation (longitude, latitude) pair node_append_str (Union[str, None]): Unique string to be appended to all primary nodes \"\"\" super () . __init__ ( div_func , kv_ll , max_pole_to_pole_distance , power_factor , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , ) # Get the road network from openstreet data self . node_append_str = node_append_str self . road_network = road_network self . road_network . get_network ( node_append_str ) self . trans_cust_mapper = trans_cust_mapper # Get sliced graph self . sliced_graph = slice_up_network_edges ( self . road_network . updated_network , self . max_pole_to_pole_distance ) # Get substation node self . substation_node = [ n for n in get_nearest_points_in_the_network ( self . sliced_graph , [ substation_loc ] ) ][ 0 ] self . substation_coords = self . sliced_graph . nodes [ self . substation_node ][ \"pos\" ] trans_location_to_retain = [ ( t . longitude , t . latitude ) for t in self . trans_cust_mapper ] self . retain_nodes = get_nearest_points_in_the_network ( self . sliced_graph , trans_location_to_retain + [ substation_loc ] ) def get_primary_network ( self ) -> nx . Graph : \"\"\"Algorithm to convert road network into distribution system primary network\"\"\" return ax . steinertree . steiner_tree ( self . sliced_graph , list ( self . retain_nodes . keys ()) ) def get_sliced_graph ( self ) -> nx . Graph : \"\"\"Return sliced graph\"\"\" return self . sliced_graph def get_network ( self ) -> nx . Graph : \"\"\"Returns a primary network with ampacity data. Raises: AttributeDoesNotExistError: If `update_network_with_ampacity` is not called first, absence of `network` attribute Returns: nx.Graph: primary network with ampacity data \"\"\" if hasattr ( self , \"network\" ): mapping_dict , relabel_rnodes = {}, {} for node in self . retain_nodes : node_new_name = \"_\" . join ( node . split ( \"_\" )[: 2 ]) + \"_htnode\" mapping_dict [ node ] = node_new_name relabel_rnodes [ node_new_name ] = self . retain_nodes [ node ] relable_snode = ( \"_\" . join ( self . substation_node . split ( \"_\" )[: 2 ]) + \"_ltnode\" ) mapping_dict [ self . substation_node ] = relable_snode relabel_rnodes [ relable_snode ] = self . retain_nodes [ self . substation_node ] self . network = nx . relabel_nodes ( self . network , mapping_dict ) self . retain_nodes = relabel_rnodes return self . network else : raise AttributeDoesNotExistError ( \"Please call 'update_network_with_ampacity' \\ method first before trying to access primary\" ) def get_trans_node_mapping ( self ) -> dict : \"\"\"Returns transformer to primary node mapping\"\"\" return self . retain_nodes def get_longest_length_in_kvameter ( self ) -> float : \"\"\"Returns longest length in kva meter\"\"\" return self . longest_length def update_network_with_ampacity ( self ) -> None : \"\"\"Method to update all line sections with ampacity\"\"\" # Get primary network tree self . network = self . get_primary_network () # Create a directed graph by providing source node \"\"\" dfs_tree = nx . dfs_tree ( self . network , source = self . substation_node ) # Mapping for transformer nodes \"\"\" transformer_nodes = {} for node , node_dict in self . retain_nodes . items (): for trans , cust_list in self . trans_cust_mapper . items (): if ( trans . longitude == node_dict [ \"centre\" ][ 0 ] and trans . latitude == node_dict [ \"centre\" ][ 1 ] ): transformer_nodes [ node ] = cust_list for edge in dfs_tree . edges (): # Compute distance from the source\"\"\" distance = nx . resistance_distance ( self . network , self . substation_node , edge [ 1 ] ) self . network [ edge [ 0 ]][ edge [ 1 ]][ \"distance\" ] = distance # Perform a depth first traversal to find all successor nodes\"\"\" dfs_successors = nx . dfs_successors ( dfs_tree , source = edge [ 1 ]) # Create a subgraph\"\"\" nodes_to_retain = [ edge [ 1 ]] for k , v in dfs_successors . items (): nodes_to_retain . extend ( v ) subgraph = self . network . subgraph ( nodes_to_retain ) # Let's compute maximum diversified kva demand downward of this edge\"\"\" noncoincident_kws = 0 num_of_customers = 0 for node in subgraph . nodes (): if node in transformer_nodes : num_of_customers += len ( transformer_nodes [ node ]) noncoincident_kws += sum ( [ l . kw for l in transformer_nodes [ node ]] ) self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] = self . _compute_ampacity ( noncoincident_kws , num_of_customers ) node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } bfs_tree = nx . bfs_tree ( self . network , self . substation_node ) for edge in bfs_tree . edges (): bfs_tree [ edge [ 0 ]][ edge [ 1 ]][ \"cost\" ] = ( get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ) * self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] * 1.732 * self . kv_ll ) self . longest_length = nx . dag_longest_path_length ( bfs_tree , weight = \"cost\" )","title":"PrimaryNetworkFromRoad"},{"location":"primary_network_builder/#shift.primary_network_builder.PrimaryNetworkFromRoad.__init__","text":"Constructor for PrimaryNetworkFromRoad class. Refer to base class for base class arguments. Parameters: Name Type Description Default road_network OpenStreetRoadNetwork OpenStreetRoadNetwork instance required trans_cust_mapper dict Mapping between Transformer object and list of Load objects required substation_loc tuple Tentative location for siting substation (longitude, latitude) pair required node_append_str Union [ str , None] Unique string to be appended to all primary nodes None Source code in shift\\primary_network_builder.py 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 def __init__ ( self , road_network : OpenStreetRoadNetwork , trans_cust_mapper : dict , substation_loc : tuple , div_func : Callable [[ float ], float ], kv_ll : float , max_pole_to_pole_distance : float = 100 , power_factor : float = 0.9 , adjustment_factor : float = 1.2 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , node_append_str : Union [ str , None ] = None , ) -> None : \"\"\"Constructor for `PrimaryNetworkFromRoad` class. Refer to base class for base class arguments. Args: road_network (OpenStreetRoadNetwork): OpenStreetRoadNetwork instance trans_cust_mapper (dict): Mapping between `Transformer` object and list of `Load` objects substation_loc (tuple): Tentative location for siting substation (longitude, latitude) pair node_append_str (Union[str, None]): Unique string to be appended to all primary nodes \"\"\" super () . __init__ ( div_func , kv_ll , max_pole_to_pole_distance , power_factor , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , ) # Get the road network from openstreet data self . node_append_str = node_append_str self . road_network = road_network self . road_network . get_network ( node_append_str ) self . trans_cust_mapper = trans_cust_mapper # Get sliced graph self . sliced_graph = slice_up_network_edges ( self . road_network . updated_network , self . max_pole_to_pole_distance ) # Get substation node self . substation_node = [ n for n in get_nearest_points_in_the_network ( self . sliced_graph , [ substation_loc ] ) ][ 0 ] self . substation_coords = self . sliced_graph . nodes [ self . substation_node ][ \"pos\" ] trans_location_to_retain = [ ( t . longitude , t . latitude ) for t in self . trans_cust_mapper ] self . retain_nodes = get_nearest_points_in_the_network ( self . sliced_graph , trans_location_to_retain + [ substation_loc ] )","title":"__init__()"},{"location":"primary_network_builder/#shift.primary_network_builder.PrimaryNetworkFromRoad.get_longest_length_in_kvameter","text":"Returns longest length in kva meter Source code in shift\\primary_network_builder.py 796 797 798 def get_longest_length_in_kvameter ( self ) -> float : \"\"\"Returns longest length in kva meter\"\"\" return self . longest_length","title":"get_longest_length_in_kvameter()"},{"location":"primary_network_builder/#shift.primary_network_builder.PrimaryNetworkFromRoad.get_network","text":"Returns a primary network with ampacity data. Raises: Type Description AttributeDoesNotExistError If update_network_with_ampacity is not called first, absence of network attribute Returns: Type Description nx . Graph nx.Graph: primary network with ampacity data Source code in shift\\primary_network_builder.py 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 def get_network ( self ) -> nx . Graph : \"\"\"Returns a primary network with ampacity data. Raises: AttributeDoesNotExistError: If `update_network_with_ampacity` is not called first, absence of `network` attribute Returns: nx.Graph: primary network with ampacity data \"\"\" if hasattr ( self , \"network\" ): mapping_dict , relabel_rnodes = {}, {} for node in self . retain_nodes : node_new_name = \"_\" . join ( node . split ( \"_\" )[: 2 ]) + \"_htnode\" mapping_dict [ node ] = node_new_name relabel_rnodes [ node_new_name ] = self . retain_nodes [ node ] relable_snode = ( \"_\" . join ( self . substation_node . split ( \"_\" )[: 2 ]) + \"_ltnode\" ) mapping_dict [ self . substation_node ] = relable_snode relabel_rnodes [ relable_snode ] = self . retain_nodes [ self . substation_node ] self . network = nx . relabel_nodes ( self . network , mapping_dict ) self . retain_nodes = relabel_rnodes return self . network else : raise AttributeDoesNotExistError ( \"Please call 'update_network_with_ampacity' \\ method first before trying to access primary\" )","title":"get_network()"},{"location":"primary_network_builder/#shift.primary_network_builder.PrimaryNetworkFromRoad.get_primary_network","text":"Algorithm to convert road network into distribution system primary network Source code in shift\\primary_network_builder.py 747 748 749 750 751 def get_primary_network ( self ) -> nx . Graph : \"\"\"Algorithm to convert road network into distribution system primary network\"\"\" return ax . steinertree . steiner_tree ( self . sliced_graph , list ( self . retain_nodes . keys ()) )","title":"get_primary_network()"},{"location":"primary_network_builder/#shift.primary_network_builder.PrimaryNetworkFromRoad.get_sliced_graph","text":"Return sliced graph Source code in shift\\primary_network_builder.py 753 754 755 def get_sliced_graph ( self ) -> nx . Graph : \"\"\"Return sliced graph\"\"\" return self . sliced_graph","title":"get_sliced_graph()"},{"location":"primary_network_builder/#shift.primary_network_builder.PrimaryNetworkFromRoad.get_trans_node_mapping","text":"Returns transformer to primary node mapping Source code in shift\\primary_network_builder.py 792 793 794 def get_trans_node_mapping ( self ) -> dict : \"\"\"Returns transformer to primary node mapping\"\"\" return self . retain_nodes","title":"get_trans_node_mapping()"},{"location":"primary_network_builder/#shift.primary_network_builder.PrimaryNetworkFromRoad.update_network_with_ampacity","text":"Method to update all line sections with ampacity Source code in shift\\primary_network_builder.py 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 def update_network_with_ampacity ( self ) -> None : \"\"\"Method to update all line sections with ampacity\"\"\" # Get primary network tree self . network = self . get_primary_network () # Create a directed graph by providing source node \"\"\" dfs_tree = nx . dfs_tree ( self . network , source = self . substation_node ) # Mapping for transformer nodes \"\"\" transformer_nodes = {} for node , node_dict in self . retain_nodes . items (): for trans , cust_list in self . trans_cust_mapper . items (): if ( trans . longitude == node_dict [ \"centre\" ][ 0 ] and trans . latitude == node_dict [ \"centre\" ][ 1 ] ): transformer_nodes [ node ] = cust_list for edge in dfs_tree . edges (): # Compute distance from the source\"\"\" distance = nx . resistance_distance ( self . network , self . substation_node , edge [ 1 ] ) self . network [ edge [ 0 ]][ edge [ 1 ]][ \"distance\" ] = distance # Perform a depth first traversal to find all successor nodes\"\"\" dfs_successors = nx . dfs_successors ( dfs_tree , source = edge [ 1 ]) # Create a subgraph\"\"\" nodes_to_retain = [ edge [ 1 ]] for k , v in dfs_successors . items (): nodes_to_retain . extend ( v ) subgraph = self . network . subgraph ( nodes_to_retain ) # Let's compute maximum diversified kva demand downward of this edge\"\"\" noncoincident_kws = 0 num_of_customers = 0 for node in subgraph . nodes (): if node in transformer_nodes : num_of_customers += len ( transformer_nodes [ node ]) noncoincident_kws += sum ( [ l . kw for l in transformer_nodes [ node ]] ) self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] = self . _compute_ampacity ( noncoincident_kws , num_of_customers ) node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } bfs_tree = nx . bfs_tree ( self . network , self . substation_node ) for edge in bfs_tree . edges (): bfs_tree [ edge [ 0 ]][ edge [ 1 ]][ \"cost\" ] = ( get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ) * self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] * 1.732 * self . kv_ll ) self . longest_length = nx . dag_longest_path_length ( bfs_tree , weight = \"cost\" )","title":"update_network_with_ampacity()"},{"location":"primary_network_builder/#shift.primary_network_builder.PrimarySectionsBuilder","text":"Bases: BaseSectionsBuilder Class handling generation of primary line sections. Source code in shift\\primary_network_builder.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 class PrimarySectionsBuilder ( BaseSectionsBuilder ): \"\"\"Class handling generation of primary line sections.\"\"\" def generate_primary_line_sections ( self , k_drop : float , kv_base : float ) -> List [ Line ]: \"\"\"Method for creating primary line sections. Args: k_drop (float): Expected percentage voltage drop per mile per kva kv_base (float): KV base used for computing kVA Returns: List[Line]: List of `Line` instances \"\"\" line_sections = [] node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } for edge in self . network . edges (): edge_data = self . network . get_edge_data ( * edge ) if self . num_phase not in self . geometry_configuration : raise IncompleteGeometryConfigurationDict ( self . num_phase , self . geometry_configuration ) line_section = geometry_based_line_section_builder ( edge [ 0 ], edge [ 1 ], self . num_phase , self . phase , self . phase , get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ), \"m\" , edge_data [ \"ampacity\" ], self . catalog_dict [ self . conductor_type ], self . neutral_present , self . conductor_type , self . geometry_configuration [ self . num_phase ], k_drop , kv_base , self . material , ) line_sections . append ( line_section ) return line_sections","title":"PrimarySectionsBuilder"},{"location":"primary_network_builder/#shift.primary_network_builder.PrimarySectionsBuilder.generate_primary_line_sections","text":"Method for creating primary line sections. Parameters: Name Type Description Default k_drop float Expected percentage voltage drop per mile per kva required kv_base float KV base used for computing kVA required Returns: Type Description List [ Line ] List[Line]: List of Line instances Source code in shift\\primary_network_builder.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 def generate_primary_line_sections ( self , k_drop : float , kv_base : float ) -> List [ Line ]: \"\"\"Method for creating primary line sections. Args: k_drop (float): Expected percentage voltage drop per mile per kva kv_base (float): KV base used for computing kVA Returns: List[Line]: List of `Line` instances \"\"\" line_sections = [] node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } for edge in self . network . edges (): edge_data = self . network . get_edge_data ( * edge ) if self . num_phase not in self . geometry_configuration : raise IncompleteGeometryConfigurationDict ( self . num_phase , self . geometry_configuration ) line_section = geometry_based_line_section_builder ( edge [ 0 ], edge [ 1 ], self . num_phase , self . phase , self . phase , get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ), \"m\" , edge_data [ \"ampacity\" ], self . catalog_dict [ self . conductor_type ], self . neutral_present , self . conductor_type , self . geometry_configuration [ self . num_phase ], k_drop , kv_base , self . material , ) line_sections . append ( line_section ) return line_sections","title":"generate_primary_line_sections()"},{"location":"primary_network_builder/#shift.primary_network_builder.choose_conductor","text":"Handles selection of conductor from the catalog. Parameters: Name Type Description Default catalog pd . DataFrame Dataframe containing all the catalogs required ampacity float Minimum ampacity required required k_drop float Percentage drop per kva per miles expected required geometry_configuration LineGeometryConfiguration LineGeometryConfiguration instance required num_of_phase NumPhase NumPhase Instance required kv_base float Line to line kv base to be used to compute kva required pf float Power factor to be used to compute kva 0.9 Raises: Type Description CatalogNotFoundError If the catalog record is not found for given ampacity Returns: Name Type Description dict dict Catalog record in dict format Source code in shift\\primary_network_builder.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def choose_conductor ( catalog : pd . DataFrame , ampacity : float , k_drop : float , geometry_configuration : LineGeometryConfiguration , num_of_phase : NumPhase , kv_base : float , pf : float = 0.9 , ) -> dict : \"\"\"Handles selection of conductor from the catalog. Args: catalog (pd.DataFrame): Dataframe containing all the catalogs ampacity (float): Minimum ampacity required k_drop (float): Percentage drop per kva per miles expected geometry_configuration (LineGeometryConfiguration): LineGeometryConfiguration instance num_of_phase (NumPhase): NumPhase Instance kv_base (float): Line to line kv base to be used to compute kva pf (float): Power factor to be used to compute kva Raises: CatalogNotFoundError: If the catalog record is not found for given ampacity Returns: dict: Catalog record in dict format \"\"\" # First thing is to find catalog for higher amps than required conductors_above_ampacity = catalog [ catalog [ \"ampacity\" ] > ampacity ] if conductors_above_ampacity . empty : raise CatalogNotFoundError ( f \"No conductor exists for ampacity { ampacity } A in the filtered set!\" ) conductors_above_ampacity = conductors_above_ampacity . sort_values ( by = [ \"ampacity\" ] ) for record in conductors_above_ampacity . to_dict ( orient = \"records\" ): # Get configuration array for conductors x_array = geometry_configuration . get_x_array ()[: num_of_phase ] # Compute the equivalent distance deq = ( np . power ( np . prod ( [ abs ( el [ 0 ] - el [ 1 ]) for el in itertools . combinations ( x_array , 2 ) ] ), 1 / len ( x_array ), ) if len ( x_array ) != 1 else record [ \"gmrac\" ] ) # Get the unit for deq deq_unit = ( geometry_configuration . unit if len ( x_array ) != 1 else record [ \"gmrunit\" ] ) # Convert deq to ft deq_ft = deq * LENGTH_CONVERTER_TO_CM [ deq_unit ] * 0.0328084 # Convert gmr to ft gmr_ft = ( record [ \"gmrac\" ] * LENGTH_CONVERTER_TO_CM [ record [ \"gmrunit\" ]] * 0.0328084 ) # Convert rac to ohm/mile r_mile = ( record [ \"rac\" ] * LENGTH_CONVERTER_TO_CM [ record [ \"runit\" ]] / 160934 ) # Compute positive sequence impedance ohm/mile zpos = complex ( r_mile , 0.12134 * np . log ( deq_ft / gmr_ft )) # Current current = complex ( ampacity * pf , - ampacity * np . power ( 1 - pf * pf , 1 / 2 ) ) # voltage drop vdrop_pct = ( ( zpos * current ) . real * 100 * math . sqrt ( 3 ) / ( kv_base * 1000 ) ) # Compute kdrop if ampacity == 0 : ampacity = 1 k_drop_computed = vdrop_pct / ( ampacity * kv_base * math . sqrt ( 3 )) # print('k_drop : ', k_drop, k_drop_computed, record['name'], record['ampacity']) if k_drop_computed <= k_drop : return record # print(k_drop_computed, k_drop, ampacity, record) # raise ConductorNotFoundForKdrop(k_drop) return record","title":"choose_conductor()"},{"location":"primary_network_builder/#shift.primary_network_builder.convert_oh_cond_info_to_wire","text":"Converts catalog record into wire object. Parameters: Name Type Description Default data dict Catalog record required Returns: Name Type Description Wire Wire Wire object instance Source code in shift\\primary_network_builder.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def convert_oh_cond_info_to_wire ( data : dict ) -> Wire : \"\"\"Converts catalog record into wire object. Args: data (dict): Catalog record Returns: Wire: Wire object instance \"\"\" data = copy . deepcopy ( data ) wire = Wire () wire . name = data [ \"name\" ] wire . diam = data [ \"diameter\" ] wire . gmrac = data [ \"gmrac\" ] wire . gmrunits = data [ \"gmrunit\" ] wire . normamps = data [ \"ampacity\" ] wire . rac = data [ \"rac\" ] wire . runits = data [ \"runit\" ] wire . radunits = data [ \"diameterunit\" ] return wire","title":"convert_oh_cond_info_to_wire()"},{"location":"primary_network_builder/#shift.primary_network_builder.convert_ug_cond_info_to_cable","text":"Converts catalog record into cable object. Parameters: Name Type Description Default data dict Catalog record required Returns: Name Type Description Cable Cable Cable object instance Source code in shift\\primary_network_builder.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def convert_ug_cond_info_to_cable ( data : dict ) -> Cable : \"\"\"Converts catalog record into cable object. Args: data (dict): Catalog record Returns: Cable: Cable object instance \"\"\" data = copy . deepcopy ( data ) cable = Cable () cable . name = data [ \"name\" ] cable . diam = data [ \"diam\" ] cable . gmrac = data [ \"gmrac\" ] cable . gmrunits = data [ \"gmrunit\" ] cable . normamps = data [ \"ampacity\" ] cable . rac = data [ \"rac\" ] cable . runits = data [ \"runit\" ] cable . radunits = data [ \"radunits\" ] cable . inslayer = data [ \"inslayer\" ] cable . diains = data [ \"diains\" ] cable . diacable = data [ \"diacable\" ] cable . rstrand = data [ \"rstrand\" ] cable . gmrstrand = data [ \"gmrstrand\" ] cable . diastrand = data [ \"diastrand\" ] cable . k = data [ \"k\" ] return cable","title":"convert_ug_cond_info_to_cable()"},{"location":"primary_network_builder/#shift.primary_network_builder.geometry_based_line_section_builder","text":"Builds a line section. Parameters: Name Type Description Default from_node str From node required to_node str To node required num_phase NumPhase NumPhase Instance required from_phase Phase Phase instance for from node required to_phase Phase Phase instance for to node required length float Length of line segment required length_unit str Unit for line length required ampacity float Ampacity for the conductor required catalog pd . DataFrame DataFrame containing all the catalaogs required neutral_present bool Indicates whether neutral is present or not required conductor_type ConductorType ConductorType instance required geometry_configuration LineGeometryConfiguration LineGeometryConfiguration instance required k_drop float Expected percentage voltage drop per kva per mile required kv_base float kV base for computing kVA required material str Material for choosing conductor 'all' Raises: Type Description EmptyCatalog If the material is not found in catalog Returns: Name Type Description Line Line Line instance Source code in shift\\primary_network_builder.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def geometry_based_line_section_builder ( from_node : str , to_node : str , num_phase : NumPhase , from_phase : Phase , to_phase : Phase , length : float , length_unit : str , ampacity : float , catalog : pd . DataFrame , neutral_present : bool , conductor_type : ConductorType , geometry_configuration : LineGeometryConfiguration , k_drop : float , kv_base : float , material : str = \"all\" , ) -> Line : \"\"\"Builds a line section. Args: from_node (str): From node to_node (str): To node num_phase (NumPhase): NumPhase Instance from_phase (Phase): Phase instance for from node to_phase (Phase): Phase instance for to node length (float): Length of line segment length_unit (str): Unit for line length ampacity (float): Ampacity for the conductor catalog (pd.DataFrame): DataFrame containing all the catalaogs neutral_present (bool): Indicates whether neutral is present or not conductor_type (ConductorType): ConductorType instance geometry_configuration (LineGeometryConfiguration): LineGeometryConfiguration instance k_drop (float): Expected percentage voltage drop per kva per mile kv_base (float): kV base for computing kVA material (str): Material for choosing conductor Raises: EmptyCatalog: If the material is not found in catalog Returns: Line: Line instance \"\"\" if material != \"all\" : catalog = catalog . loc [ catalog [ \"material\" ] == material ] if catalog . empty : raise EmptyCatalog ( f \"Catalog of material { material } not found!\" ) line_section = GeometryBasedLine () line_section . name = from_node + \"__\" + to_node line_section . fromnode = from_node line_section . tonode = to_node line_section . length = length line_section . length_unit = length_unit line_section . num_phase = num_phase line_section . fromnode_phase = from_phase line_section . tonode_phase = to_phase # Get the geometry object if conductor_type == ConductorType . OVERHEAD : if neutral_present : line_geometry = OverheadLinewithNeutralGeometry () # Let's find the condcutor to be used phase_cond_dict = choose_conductor ( catalog , ampacity , k_drop , geometry_configuration , num_phase . value , kv_base , ) # catalog.loc[catalog[catalog['ampacity']>ampacity]['ampacity'].idxmin()].to_dict() line_geometry . phase_wire = convert_oh_cond_info_to_wire ( phase_cond_dict ) # Assuming neutral conductor would be one third of phase conductor ampacity for multi phase else same as phase conductor neutral_cond_dict = ( phase_cond_dict if num_phase == NumPhase . SINGLE else choose_conductor ( catalog , ampacity / 3 , k_drop , geometry_configuration , num_phase . value , kv_base , ) ) line_geometry . neutral_wire = convert_oh_cond_info_to_wire ( neutral_cond_dict ) line_geometry . num_conds = num_phase . value + 1 else : line_geometry = OverheadLineGeometry () phase_cond_dict = choose_conductor ( catalog , ampacity , k_drop , geometry_configuration , num_phase . value , kv_base , ) line_geometry . phase_wire = convert_oh_cond_info_to_wire ( phase_cond_dict ) line_geometry . num_conds = num_phase . value else : line_geometry = UndergroundLineGeometry () if num_phase == NumPhase . THREE : catalog = catalog [ catalog [ \"neutral_type\" ] == \"1/3 Neutral\" ] else : catalog = catalog [ catalog [ \"neutral_type\" ] == \"Full Neutral\" ] cable_dict = choose_conductor ( catalog , ampacity , k_drop , geometry_configuration , num_phase . value , kv_base , ) line_geometry . phase_cable = convert_ug_cond_info_to_cable ( cable_dict ) line_geometry . num_conds = num_phase . value line_geometry . name = str ( uuid . uuid4 ()) + \"_linegeometry\" line_geometry . num_phase = num_phase line_geometry . configuration = geometry_configuration line_section . geometry = line_geometry return line_section","title":"geometry_based_line_section_builder()"},{"location":"secondary_network_builder/","text":"This module contains classes for managing creation of secondary network sections. SecondaryNetworkBuilder Bases: BaseNetworkBuilder Builds secondary network. Refer to base class for base attributes. Attributes: Name Type Description transformer Transformer Transformer instance load_to_node_mapping dict Mapping between load object and secondary node customer_to_node_mapping dict Mapping between load name and secondary node network nx . Graph Seondary network points dict Mapping between load and coordinates source_node str Source node for the secondary network tr_lt_node str LT node of the transformer Source code in shift\\secondary_network_builder.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 class SecondaryNetworkBuilder ( BaseNetworkBuilder ): \"\"\"Builds secondary network. Refer to base class for base attributes. Attributes: transformer (Transformer): `Transformer` instance load_to_node_mapping (dict): Mapping between load object and secondary node customer_to_node_mapping (dict): Mapping between load name and secondary node network (nx.Graph): Seondary network points (dict): Mapping between load and coordinates source_node (str): Source node for the secondary network tr_lt_node (str): LT node of the transformer \"\"\" def __init__ ( self , load_list : List [ Load ], transformer : Transformer , div_func : Callable [[ float ], float ], kv_ll : float , node_append_str : str , forbidden_areas : Union [ str , None ] = None , max_pole_to_pole_distance : float = 100 , power_factor : float = 0.9 , adjustment_factor : float = 1.2 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ): \"\"\"Constructor for SecondaryNetworkBuilder class. Args: load_list (List[Load]): List of `Load` instances transformer (Transformer): `Transformer` instance node_append_str (str): Unique string to be appended to all primary nodes forbidden_areas (Union[str, None]): Path to .shp file containing forbidden polygons Raises: NotImplementedError: If transformer has 0 loads \"\"\" super () . __init__ ( div_func , kv_ll , max_pole_to_pole_distance , power_factor , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , ) self . transformer = transformer self . load_to_node_mapping = {} load_locations = [[ l . longitude , l . latitude ] for l in load_list ] if len ( load_locations ) > 0 : if len ( load_locations ) == 1 : self . network = nx . Graph () self . network . add_node ( f \" { load_locations [ 0 ][ 0 ] } _ { load_locations [ 0 ][ 1 ] } _ { node_append_str } _node\" , pos = ( load_locations [ 0 ][ 0 ], load_locations [ 0 ][ 1 ]), ) self . customer_to_node_mapping = { load_list [ 0 ] . name : f \" { load_locations [ 0 ][ 0 ] } _ { load_locations [ 0 ][ 1 ] } _ { node_append_str } _node\" } self . points = { key : val [ \"pos\" ] for key , val in dict ( self . network . nodes ( data = True )) . items () } else : # We use meshed approach to come up with network graph ( self . network , self . points , self . customer_to_node_mapping , ) = triangulate_using_mesh ( load_locations , forbidden_areas = forbidden_areas , node_append_str = node_append_str , ) # Unfreeze the network if already frozen if nx . is_frozen ( self . network ): self . network = nx . Graph ( self . network ) self . source_node = [ n for n in get_nearest_points_in_the_network ( self . network , [( self . transformer . longitude , self . transformer . latitude )], ) ][ 0 ] # Connect the customers as well for load in load_list : to_node = self . customer_to_node_mapping [ f \" { load . longitude } _ { load . latitude } _customer\" ] self . network . add_node ( load . name , pos = ( load . longitude , load . latitude ), object = load , load = True , ) self . network . add_edge ( load . name , to_node , load_present = True ) self . load_to_node_mapping [ load . name ] = to_node self . tr_lt_node = f \" { self . transformer . longitude } _ { self . transformer . latitude } _ltnode\" self . network . add_node ( self . tr_lt_node , pos = ( self . transformer . longitude , self . transformer . latitude ), ) self . network . add_edge ( self . tr_lt_node , self . source_node ) self . network = set_node_edge_type ( self . network ) else : raise NotImplementedError ( f \"Transformers can not have 0 loads\" ) def get_load_to_node_mapping ( self ) -> dict : \"\"\"Returns load to node mapping.\"\"\" return self . load_to_node_mapping def get_network ( self ) -> nx . Graph : \"\"\"Returns secondary network.\"\"\" return self . network def get_longest_length_in_kvameter ( self ): \"\"\"Returns longest length in kva meter\"\"\" return self . longest_length def update_network_with_ampacity ( self ): \"\"\"Method to update all line sections with ampacity\"\"\" # Create a directed graph by providing source node dfs_tree = nx . dfs_tree ( self . network , source = self . source_node ) # Perform a depth first traversal to find all successor nodes\"\"\" x , y = [], [] for edge in dfs_tree . edges (): # Compute distance from the source\"\"\" distance = nx . resistance_distance ( self . network , self . source_node , edge [ 1 ] ) self . network [ edge [ 0 ]][ edge [ 1 ]][ \"distance\" ] = distance # Perform a depth first traversal to find all successor nodes\"\"\" dfs_successors = nx . dfs_successors ( dfs_tree , source = edge [ 1 ]) # Create a subgraph\"\"\" nodes_to_retain = [ edge [ 1 ]] for k , v in dfs_successors . items (): nodes_to_retain . extend ( v ) subgraph = self . network . subgraph ( nodes_to_retain ) # Let's compute maximum diversified kva demand downward of this edge\"\"\" noncoincident_kws = 0 num_of_customers = 0 for node in subgraph . nodes (): if \"load\" in subgraph . nodes [ node ]: num_of_customers += 1 noncoincident_kws += subgraph . nodes [ node ][ \"object\" ] . kw self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] = self . compute_ampacity ( noncoincident_kws , num_of_customers ) x . append ( distance ) y . append ( self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ]) node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } bfs_tree = nx . bfs_tree ( self . network , self . source_node ) for edge in bfs_tree . edges (): try : bfs_tree [ edge [ 0 ]][ edge [ 1 ]][ \"cost\" ] = ( get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ) * self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] * 1.732 * self . kv_ll ) except Exception as e : print ( e ) print ( \"help\" ) self . longest_length = nx . dag_longest_path_length ( bfs_tree , weight = \"cost\" ) __init__ ( load_list , transformer , div_func , kv_ll , node_append_str , forbidden_areas = None , max_pole_to_pole_distance = 100 , power_factor = 0.9 , adjustment_factor = 1.2 , planned_avg_annual_growth = 2 , actual_avg_annual_growth = 4 , actual_years_in_operation = 15 , planned_years_in_operation = 10 ) Constructor for SecondaryNetworkBuilder class. Parameters: Name Type Description Default load_list List [ Load ] List of Load instances required transformer Transformer Transformer instance required node_append_str str Unique string to be appended to all primary nodes required forbidden_areas Union [ str , None] Path to .shp file containing forbidden polygons None Raises: Type Description NotImplementedError If transformer has 0 loads Source code in shift\\secondary_network_builder.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def __init__ ( self , load_list : List [ Load ], transformer : Transformer , div_func : Callable [[ float ], float ], kv_ll : float , node_append_str : str , forbidden_areas : Union [ str , None ] = None , max_pole_to_pole_distance : float = 100 , power_factor : float = 0.9 , adjustment_factor : float = 1.2 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ): \"\"\"Constructor for SecondaryNetworkBuilder class. Args: load_list (List[Load]): List of `Load` instances transformer (Transformer): `Transformer` instance node_append_str (str): Unique string to be appended to all primary nodes forbidden_areas (Union[str, None]): Path to .shp file containing forbidden polygons Raises: NotImplementedError: If transformer has 0 loads \"\"\" super () . __init__ ( div_func , kv_ll , max_pole_to_pole_distance , power_factor , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , ) self . transformer = transformer self . load_to_node_mapping = {} load_locations = [[ l . longitude , l . latitude ] for l in load_list ] if len ( load_locations ) > 0 : if len ( load_locations ) == 1 : self . network = nx . Graph () self . network . add_node ( f \" { load_locations [ 0 ][ 0 ] } _ { load_locations [ 0 ][ 1 ] } _ { node_append_str } _node\" , pos = ( load_locations [ 0 ][ 0 ], load_locations [ 0 ][ 1 ]), ) self . customer_to_node_mapping = { load_list [ 0 ] . name : f \" { load_locations [ 0 ][ 0 ] } _ { load_locations [ 0 ][ 1 ] } _ { node_append_str } _node\" } self . points = { key : val [ \"pos\" ] for key , val in dict ( self . network . nodes ( data = True )) . items () } else : # We use meshed approach to come up with network graph ( self . network , self . points , self . customer_to_node_mapping , ) = triangulate_using_mesh ( load_locations , forbidden_areas = forbidden_areas , node_append_str = node_append_str , ) # Unfreeze the network if already frozen if nx . is_frozen ( self . network ): self . network = nx . Graph ( self . network ) self . source_node = [ n for n in get_nearest_points_in_the_network ( self . network , [( self . transformer . longitude , self . transformer . latitude )], ) ][ 0 ] # Connect the customers as well for load in load_list : to_node = self . customer_to_node_mapping [ f \" { load . longitude } _ { load . latitude } _customer\" ] self . network . add_node ( load . name , pos = ( load . longitude , load . latitude ), object = load , load = True , ) self . network . add_edge ( load . name , to_node , load_present = True ) self . load_to_node_mapping [ load . name ] = to_node self . tr_lt_node = f \" { self . transformer . longitude } _ { self . transformer . latitude } _ltnode\" self . network . add_node ( self . tr_lt_node , pos = ( self . transformer . longitude , self . transformer . latitude ), ) self . network . add_edge ( self . tr_lt_node , self . source_node ) self . network = set_node_edge_type ( self . network ) else : raise NotImplementedError ( f \"Transformers can not have 0 loads\" ) get_load_to_node_mapping () Returns load to node mapping. Source code in shift\\secondary_network_builder.py 329 330 331 def get_load_to_node_mapping ( self ) -> dict : \"\"\"Returns load to node mapping.\"\"\" return self . load_to_node_mapping get_longest_length_in_kvameter () Returns longest length in kva meter Source code in shift\\secondary_network_builder.py 337 338 339 def get_longest_length_in_kvameter ( self ): \"\"\"Returns longest length in kva meter\"\"\" return self . longest_length get_network () Returns secondary network. Source code in shift\\secondary_network_builder.py 333 334 335 def get_network ( self ) -> nx . Graph : \"\"\"Returns secondary network.\"\"\" return self . network update_network_with_ampacity () Method to update all line sections with ampacity Source code in shift\\secondary_network_builder.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 def update_network_with_ampacity ( self ): \"\"\"Method to update all line sections with ampacity\"\"\" # Create a directed graph by providing source node dfs_tree = nx . dfs_tree ( self . network , source = self . source_node ) # Perform a depth first traversal to find all successor nodes\"\"\" x , y = [], [] for edge in dfs_tree . edges (): # Compute distance from the source\"\"\" distance = nx . resistance_distance ( self . network , self . source_node , edge [ 1 ] ) self . network [ edge [ 0 ]][ edge [ 1 ]][ \"distance\" ] = distance # Perform a depth first traversal to find all successor nodes\"\"\" dfs_successors = nx . dfs_successors ( dfs_tree , source = edge [ 1 ]) # Create a subgraph\"\"\" nodes_to_retain = [ edge [ 1 ]] for k , v in dfs_successors . items (): nodes_to_retain . extend ( v ) subgraph = self . network . subgraph ( nodes_to_retain ) # Let's compute maximum diversified kva demand downward of this edge\"\"\" noncoincident_kws = 0 num_of_customers = 0 for node in subgraph . nodes (): if \"load\" in subgraph . nodes [ node ]: num_of_customers += 1 noncoincident_kws += subgraph . nodes [ node ][ \"object\" ] . kw self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] = self . compute_ampacity ( noncoincident_kws , num_of_customers ) x . append ( distance ) y . append ( self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ]) node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } bfs_tree = nx . bfs_tree ( self . network , self . source_node ) for edge in bfs_tree . edges (): try : bfs_tree [ edge [ 0 ]][ edge [ 1 ]][ \"cost\" ] = ( get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ) * self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] * 1.732 * self . kv_ll ) except Exception as e : print ( e ) print ( \"help\" ) self . longest_length = nx . dag_longest_path_length ( bfs_tree , weight = \"cost\" ) SecondarySectionsBuilder Bases: BaseSectionsBuilder Class handling generation of secondary line sections. Refer to base class for attributes present in base class Attributes: Name Type Description lateral_configuration dict Drop line configuration data lateral_material str Conductor material for drop line Source code in shift\\secondary_network_builder.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 class SecondarySectionsBuilder ( BaseSectionsBuilder ): \"\"\"Class handling generation of secondary line sections. Refer to base class for attributes present in base class Attributes: lateral_configuration (dict): Drop line configuration data lateral_material (str): Conductor material for drop line \"\"\" def __init__ ( self , secondary_network : nx . Graph , conductor_type : ConductorType , configuration : dict , lateral_configuration : dict , num_phase : NumPhase , phase : Phase , neutral_present : True , material : str = \"all\" , lateral_material : str = \"all\" , ) -> None : \"\"\"Constructor for SecondarySectionsBuilder class. Refer to base class arguments. Args: lateral_configuration (dict): Drop line configuration data lateral_material (str): Conductor material for drop line \"\"\" super () . __init__ ( secondary_network , conductor_type , configuration , num_phase , phase , neutral_present , material , ) self . lateral_material = lateral_material self . lateral_configuration = lateral_configuration def generate_secondary_line_sections ( self , k_drop : float , kv_base : float ) -> List [ Line ]: \"\"\"Method for creating secondary line sections. Args: k_drop (float): Expected percentage voltage drop per mile per kva kv_base (float): KV base used for computing kVA Returns: List[Line]: List of `Line` instances \"\"\" line_sections = [] node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } for edge in self . network . edges (): edge_data = self . network . get_edge_data ( * edge ) # Find edge that connects load and this should be cable if ( \"load\" in self . network . nodes [ edge [ 0 ]] or \"load\" in self . network . nodes [ edge [ 1 ]] ): load_node = 0 if \"load\" in self . network . nodes [ edge [ 0 ]] else 1 load_obj = self . network . nodes [ edge [ load_node ]][ \"object\" ] # fromnode_phase = load_obj.phase if load_node == 0 else self.phase # tonode_phase = load_obj.phase if load_node == 1 else self.phase if load_obj . num_phase . value > self . num_phase . value : raise CustomerInvalidPhase ( load_obj . num_phase , self . num_phase ) # Let's check for phase mismatch if any if self . num_phase . value == load_obj . num_phase . value : if self . phase != load_obj . phase : raise PhaseMismatchError ( load_obj . phase , self . phase ) if load_obj . num_phase not in self . lateral_configuration : raise IncompleteGeometryConfigurationDict ( load_obj . num_phase , self . lateral_configuration ) line_section = geometry_based_line_section_builder ( edge [ 0 ], edge [ 1 ], load_obj . num_phase , load_obj . phase , load_obj . phase , get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ), \"m\" , edge_data [ \"ampacity\" ], self . catalog_dict [ ConductorType . UNDERGROUND_CONCENTRIC ], self . neutral_present , ConductorType . UNDERGROUND_CONCENTRIC , self . lateral_configuration [ load_obj . num_phase ], k_drop , kv_base , self . lateral_material , ) else : if self . num_phase not in self . geometry_configuration : raise IncompleteGeometryConfigurationDict ( self . num_phase , self . geometry_configuration ) line_section = geometry_based_line_section_builder ( edge [ 0 ], edge [ 1 ], self . num_phase , self . phase , self . phase , get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ), \"m\" , edge_data [ \"ampacity\" ], self . catalog_dict [ self . conductor_type ], self . neutral_present , self . conductor_type , self . geometry_configuration [ self . num_phase ], k_drop , kv_base , self . material , ) line_sections . append ( line_section ) return line_sections __init__ ( secondary_network , conductor_type , configuration , lateral_configuration , num_phase , phase , neutral_present , material = 'all' , lateral_material = 'all' ) Constructor for SecondarySectionsBuilder class. Refer to base class arguments. Parameters: Name Type Description Default lateral_configuration dict Drop line configuration data required lateral_material str Conductor material for drop line 'all' Source code in shift\\secondary_network_builder.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def __init__ ( self , secondary_network : nx . Graph , conductor_type : ConductorType , configuration : dict , lateral_configuration : dict , num_phase : NumPhase , phase : Phase , neutral_present : True , material : str = \"all\" , lateral_material : str = \"all\" , ) -> None : \"\"\"Constructor for SecondarySectionsBuilder class. Refer to base class arguments. Args: lateral_configuration (dict): Drop line configuration data lateral_material (str): Conductor material for drop line \"\"\" super () . __init__ ( secondary_network , conductor_type , configuration , num_phase , phase , neutral_present , material , ) self . lateral_material = lateral_material self . lateral_configuration = lateral_configuration generate_secondary_line_sections ( k_drop , kv_base ) Method for creating secondary line sections. Parameters: Name Type Description Default k_drop float Expected percentage voltage drop per mile per kva required kv_base float KV base used for computing kVA required Returns: Type Description List [ Line ] List[Line]: List of Line instances Source code in shift\\secondary_network_builder.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def generate_secondary_line_sections ( self , k_drop : float , kv_base : float ) -> List [ Line ]: \"\"\"Method for creating secondary line sections. Args: k_drop (float): Expected percentage voltage drop per mile per kva kv_base (float): KV base used for computing kVA Returns: List[Line]: List of `Line` instances \"\"\" line_sections = [] node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } for edge in self . network . edges (): edge_data = self . network . get_edge_data ( * edge ) # Find edge that connects load and this should be cable if ( \"load\" in self . network . nodes [ edge [ 0 ]] or \"load\" in self . network . nodes [ edge [ 1 ]] ): load_node = 0 if \"load\" in self . network . nodes [ edge [ 0 ]] else 1 load_obj = self . network . nodes [ edge [ load_node ]][ \"object\" ] # fromnode_phase = load_obj.phase if load_node == 0 else self.phase # tonode_phase = load_obj.phase if load_node == 1 else self.phase if load_obj . num_phase . value > self . num_phase . value : raise CustomerInvalidPhase ( load_obj . num_phase , self . num_phase ) # Let's check for phase mismatch if any if self . num_phase . value == load_obj . num_phase . value : if self . phase != load_obj . phase : raise PhaseMismatchError ( load_obj . phase , self . phase ) if load_obj . num_phase not in self . lateral_configuration : raise IncompleteGeometryConfigurationDict ( load_obj . num_phase , self . lateral_configuration ) line_section = geometry_based_line_section_builder ( edge [ 0 ], edge [ 1 ], load_obj . num_phase , load_obj . phase , load_obj . phase , get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ), \"m\" , edge_data [ \"ampacity\" ], self . catalog_dict [ ConductorType . UNDERGROUND_CONCENTRIC ], self . neutral_present , ConductorType . UNDERGROUND_CONCENTRIC , self . lateral_configuration [ load_obj . num_phase ], k_drop , kv_base , self . lateral_material , ) else : if self . num_phase not in self . geometry_configuration : raise IncompleteGeometryConfigurationDict ( self . num_phase , self . geometry_configuration ) line_section = geometry_based_line_section_builder ( edge [ 0 ], edge [ 1 ], self . num_phase , self . phase , self . phase , get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ), \"m\" , edge_data [ \"ampacity\" ], self . catalog_dict [ self . conductor_type ], self . neutral_present , self . conductor_type , self . geometry_configuration [ self . num_phase ], k_drop , kv_base , self . material , ) line_sections . append ( line_section ) return line_sections","title":"secondary_network_builder"},{"location":"secondary_network_builder/#shift.secondary_network_builder.SecondaryNetworkBuilder","text":"Bases: BaseNetworkBuilder Builds secondary network. Refer to base class for base attributes. Attributes: Name Type Description transformer Transformer Transformer instance load_to_node_mapping dict Mapping between load object and secondary node customer_to_node_mapping dict Mapping between load name and secondary node network nx . Graph Seondary network points dict Mapping between load and coordinates source_node str Source node for the secondary network tr_lt_node str LT node of the transformer Source code in shift\\secondary_network_builder.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 class SecondaryNetworkBuilder ( BaseNetworkBuilder ): \"\"\"Builds secondary network. Refer to base class for base attributes. Attributes: transformer (Transformer): `Transformer` instance load_to_node_mapping (dict): Mapping between load object and secondary node customer_to_node_mapping (dict): Mapping between load name and secondary node network (nx.Graph): Seondary network points (dict): Mapping between load and coordinates source_node (str): Source node for the secondary network tr_lt_node (str): LT node of the transformer \"\"\" def __init__ ( self , load_list : List [ Load ], transformer : Transformer , div_func : Callable [[ float ], float ], kv_ll : float , node_append_str : str , forbidden_areas : Union [ str , None ] = None , max_pole_to_pole_distance : float = 100 , power_factor : float = 0.9 , adjustment_factor : float = 1.2 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ): \"\"\"Constructor for SecondaryNetworkBuilder class. Args: load_list (List[Load]): List of `Load` instances transformer (Transformer): `Transformer` instance node_append_str (str): Unique string to be appended to all primary nodes forbidden_areas (Union[str, None]): Path to .shp file containing forbidden polygons Raises: NotImplementedError: If transformer has 0 loads \"\"\" super () . __init__ ( div_func , kv_ll , max_pole_to_pole_distance , power_factor , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , ) self . transformer = transformer self . load_to_node_mapping = {} load_locations = [[ l . longitude , l . latitude ] for l in load_list ] if len ( load_locations ) > 0 : if len ( load_locations ) == 1 : self . network = nx . Graph () self . network . add_node ( f \" { load_locations [ 0 ][ 0 ] } _ { load_locations [ 0 ][ 1 ] } _ { node_append_str } _node\" , pos = ( load_locations [ 0 ][ 0 ], load_locations [ 0 ][ 1 ]), ) self . customer_to_node_mapping = { load_list [ 0 ] . name : f \" { load_locations [ 0 ][ 0 ] } _ { load_locations [ 0 ][ 1 ] } _ { node_append_str } _node\" } self . points = { key : val [ \"pos\" ] for key , val in dict ( self . network . nodes ( data = True )) . items () } else : # We use meshed approach to come up with network graph ( self . network , self . points , self . customer_to_node_mapping , ) = triangulate_using_mesh ( load_locations , forbidden_areas = forbidden_areas , node_append_str = node_append_str , ) # Unfreeze the network if already frozen if nx . is_frozen ( self . network ): self . network = nx . Graph ( self . network ) self . source_node = [ n for n in get_nearest_points_in_the_network ( self . network , [( self . transformer . longitude , self . transformer . latitude )], ) ][ 0 ] # Connect the customers as well for load in load_list : to_node = self . customer_to_node_mapping [ f \" { load . longitude } _ { load . latitude } _customer\" ] self . network . add_node ( load . name , pos = ( load . longitude , load . latitude ), object = load , load = True , ) self . network . add_edge ( load . name , to_node , load_present = True ) self . load_to_node_mapping [ load . name ] = to_node self . tr_lt_node = f \" { self . transformer . longitude } _ { self . transformer . latitude } _ltnode\" self . network . add_node ( self . tr_lt_node , pos = ( self . transformer . longitude , self . transformer . latitude ), ) self . network . add_edge ( self . tr_lt_node , self . source_node ) self . network = set_node_edge_type ( self . network ) else : raise NotImplementedError ( f \"Transformers can not have 0 loads\" ) def get_load_to_node_mapping ( self ) -> dict : \"\"\"Returns load to node mapping.\"\"\" return self . load_to_node_mapping def get_network ( self ) -> nx . Graph : \"\"\"Returns secondary network.\"\"\" return self . network def get_longest_length_in_kvameter ( self ): \"\"\"Returns longest length in kva meter\"\"\" return self . longest_length def update_network_with_ampacity ( self ): \"\"\"Method to update all line sections with ampacity\"\"\" # Create a directed graph by providing source node dfs_tree = nx . dfs_tree ( self . network , source = self . source_node ) # Perform a depth first traversal to find all successor nodes\"\"\" x , y = [], [] for edge in dfs_tree . edges (): # Compute distance from the source\"\"\" distance = nx . resistance_distance ( self . network , self . source_node , edge [ 1 ] ) self . network [ edge [ 0 ]][ edge [ 1 ]][ \"distance\" ] = distance # Perform a depth first traversal to find all successor nodes\"\"\" dfs_successors = nx . dfs_successors ( dfs_tree , source = edge [ 1 ]) # Create a subgraph\"\"\" nodes_to_retain = [ edge [ 1 ]] for k , v in dfs_successors . items (): nodes_to_retain . extend ( v ) subgraph = self . network . subgraph ( nodes_to_retain ) # Let's compute maximum diversified kva demand downward of this edge\"\"\" noncoincident_kws = 0 num_of_customers = 0 for node in subgraph . nodes (): if \"load\" in subgraph . nodes [ node ]: num_of_customers += 1 noncoincident_kws += subgraph . nodes [ node ][ \"object\" ] . kw self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] = self . compute_ampacity ( noncoincident_kws , num_of_customers ) x . append ( distance ) y . append ( self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ]) node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } bfs_tree = nx . bfs_tree ( self . network , self . source_node ) for edge in bfs_tree . edges (): try : bfs_tree [ edge [ 0 ]][ edge [ 1 ]][ \"cost\" ] = ( get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ) * self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] * 1.732 * self . kv_ll ) except Exception as e : print ( e ) print ( \"help\" ) self . longest_length = nx . dag_longest_path_length ( bfs_tree , weight = \"cost\" )","title":"SecondaryNetworkBuilder"},{"location":"secondary_network_builder/#shift.secondary_network_builder.SecondaryNetworkBuilder.__init__","text":"Constructor for SecondaryNetworkBuilder class. Parameters: Name Type Description Default load_list List [ Load ] List of Load instances required transformer Transformer Transformer instance required node_append_str str Unique string to be appended to all primary nodes required forbidden_areas Union [ str , None] Path to .shp file containing forbidden polygons None Raises: Type Description NotImplementedError If transformer has 0 loads Source code in shift\\secondary_network_builder.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def __init__ ( self , load_list : List [ Load ], transformer : Transformer , div_func : Callable [[ float ], float ], kv_ll : float , node_append_str : str , forbidden_areas : Union [ str , None ] = None , max_pole_to_pole_distance : float = 100 , power_factor : float = 0.9 , adjustment_factor : float = 1.2 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ): \"\"\"Constructor for SecondaryNetworkBuilder class. Args: load_list (List[Load]): List of `Load` instances transformer (Transformer): `Transformer` instance node_append_str (str): Unique string to be appended to all primary nodes forbidden_areas (Union[str, None]): Path to .shp file containing forbidden polygons Raises: NotImplementedError: If transformer has 0 loads \"\"\" super () . __init__ ( div_func , kv_ll , max_pole_to_pole_distance , power_factor , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , ) self . transformer = transformer self . load_to_node_mapping = {} load_locations = [[ l . longitude , l . latitude ] for l in load_list ] if len ( load_locations ) > 0 : if len ( load_locations ) == 1 : self . network = nx . Graph () self . network . add_node ( f \" { load_locations [ 0 ][ 0 ] } _ { load_locations [ 0 ][ 1 ] } _ { node_append_str } _node\" , pos = ( load_locations [ 0 ][ 0 ], load_locations [ 0 ][ 1 ]), ) self . customer_to_node_mapping = { load_list [ 0 ] . name : f \" { load_locations [ 0 ][ 0 ] } _ { load_locations [ 0 ][ 1 ] } _ { node_append_str } _node\" } self . points = { key : val [ \"pos\" ] for key , val in dict ( self . network . nodes ( data = True )) . items () } else : # We use meshed approach to come up with network graph ( self . network , self . points , self . customer_to_node_mapping , ) = triangulate_using_mesh ( load_locations , forbidden_areas = forbidden_areas , node_append_str = node_append_str , ) # Unfreeze the network if already frozen if nx . is_frozen ( self . network ): self . network = nx . Graph ( self . network ) self . source_node = [ n for n in get_nearest_points_in_the_network ( self . network , [( self . transformer . longitude , self . transformer . latitude )], ) ][ 0 ] # Connect the customers as well for load in load_list : to_node = self . customer_to_node_mapping [ f \" { load . longitude } _ { load . latitude } _customer\" ] self . network . add_node ( load . name , pos = ( load . longitude , load . latitude ), object = load , load = True , ) self . network . add_edge ( load . name , to_node , load_present = True ) self . load_to_node_mapping [ load . name ] = to_node self . tr_lt_node = f \" { self . transformer . longitude } _ { self . transformer . latitude } _ltnode\" self . network . add_node ( self . tr_lt_node , pos = ( self . transformer . longitude , self . transformer . latitude ), ) self . network . add_edge ( self . tr_lt_node , self . source_node ) self . network = set_node_edge_type ( self . network ) else : raise NotImplementedError ( f \"Transformers can not have 0 loads\" )","title":"__init__()"},{"location":"secondary_network_builder/#shift.secondary_network_builder.SecondaryNetworkBuilder.get_load_to_node_mapping","text":"Returns load to node mapping. Source code in shift\\secondary_network_builder.py 329 330 331 def get_load_to_node_mapping ( self ) -> dict : \"\"\"Returns load to node mapping.\"\"\" return self . load_to_node_mapping","title":"get_load_to_node_mapping()"},{"location":"secondary_network_builder/#shift.secondary_network_builder.SecondaryNetworkBuilder.get_longest_length_in_kvameter","text":"Returns longest length in kva meter Source code in shift\\secondary_network_builder.py 337 338 339 def get_longest_length_in_kvameter ( self ): \"\"\"Returns longest length in kva meter\"\"\" return self . longest_length","title":"get_longest_length_in_kvameter()"},{"location":"secondary_network_builder/#shift.secondary_network_builder.SecondaryNetworkBuilder.get_network","text":"Returns secondary network. Source code in shift\\secondary_network_builder.py 333 334 335 def get_network ( self ) -> nx . Graph : \"\"\"Returns secondary network.\"\"\" return self . network","title":"get_network()"},{"location":"secondary_network_builder/#shift.secondary_network_builder.SecondaryNetworkBuilder.update_network_with_ampacity","text":"Method to update all line sections with ampacity Source code in shift\\secondary_network_builder.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 def update_network_with_ampacity ( self ): \"\"\"Method to update all line sections with ampacity\"\"\" # Create a directed graph by providing source node dfs_tree = nx . dfs_tree ( self . network , source = self . source_node ) # Perform a depth first traversal to find all successor nodes\"\"\" x , y = [], [] for edge in dfs_tree . edges (): # Compute distance from the source\"\"\" distance = nx . resistance_distance ( self . network , self . source_node , edge [ 1 ] ) self . network [ edge [ 0 ]][ edge [ 1 ]][ \"distance\" ] = distance # Perform a depth first traversal to find all successor nodes\"\"\" dfs_successors = nx . dfs_successors ( dfs_tree , source = edge [ 1 ]) # Create a subgraph\"\"\" nodes_to_retain = [ edge [ 1 ]] for k , v in dfs_successors . items (): nodes_to_retain . extend ( v ) subgraph = self . network . subgraph ( nodes_to_retain ) # Let's compute maximum diversified kva demand downward of this edge\"\"\" noncoincident_kws = 0 num_of_customers = 0 for node in subgraph . nodes (): if \"load\" in subgraph . nodes [ node ]: num_of_customers += 1 noncoincident_kws += subgraph . nodes [ node ][ \"object\" ] . kw self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] = self . compute_ampacity ( noncoincident_kws , num_of_customers ) x . append ( distance ) y . append ( self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ]) node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } bfs_tree = nx . bfs_tree ( self . network , self . source_node ) for edge in bfs_tree . edges (): try : bfs_tree [ edge [ 0 ]][ edge [ 1 ]][ \"cost\" ] = ( get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ) * self . network [ edge [ 0 ]][ edge [ 1 ]][ \"ampacity\" ] * 1.732 * self . kv_ll ) except Exception as e : print ( e ) print ( \"help\" ) self . longest_length = nx . dag_longest_path_length ( bfs_tree , weight = \"cost\" )","title":"update_network_with_ampacity()"},{"location":"secondary_network_builder/#shift.secondary_network_builder.SecondarySectionsBuilder","text":"Bases: BaseSectionsBuilder Class handling generation of secondary line sections. Refer to base class for attributes present in base class Attributes: Name Type Description lateral_configuration dict Drop line configuration data lateral_material str Conductor material for drop line Source code in shift\\secondary_network_builder.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 class SecondarySectionsBuilder ( BaseSectionsBuilder ): \"\"\"Class handling generation of secondary line sections. Refer to base class for attributes present in base class Attributes: lateral_configuration (dict): Drop line configuration data lateral_material (str): Conductor material for drop line \"\"\" def __init__ ( self , secondary_network : nx . Graph , conductor_type : ConductorType , configuration : dict , lateral_configuration : dict , num_phase : NumPhase , phase : Phase , neutral_present : True , material : str = \"all\" , lateral_material : str = \"all\" , ) -> None : \"\"\"Constructor for SecondarySectionsBuilder class. Refer to base class arguments. Args: lateral_configuration (dict): Drop line configuration data lateral_material (str): Conductor material for drop line \"\"\" super () . __init__ ( secondary_network , conductor_type , configuration , num_phase , phase , neutral_present , material , ) self . lateral_material = lateral_material self . lateral_configuration = lateral_configuration def generate_secondary_line_sections ( self , k_drop : float , kv_base : float ) -> List [ Line ]: \"\"\"Method for creating secondary line sections. Args: k_drop (float): Expected percentage voltage drop per mile per kva kv_base (float): KV base used for computing kVA Returns: List[Line]: List of `Line` instances \"\"\" line_sections = [] node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } for edge in self . network . edges (): edge_data = self . network . get_edge_data ( * edge ) # Find edge that connects load and this should be cable if ( \"load\" in self . network . nodes [ edge [ 0 ]] or \"load\" in self . network . nodes [ edge [ 1 ]] ): load_node = 0 if \"load\" in self . network . nodes [ edge [ 0 ]] else 1 load_obj = self . network . nodes [ edge [ load_node ]][ \"object\" ] # fromnode_phase = load_obj.phase if load_node == 0 else self.phase # tonode_phase = load_obj.phase if load_node == 1 else self.phase if load_obj . num_phase . value > self . num_phase . value : raise CustomerInvalidPhase ( load_obj . num_phase , self . num_phase ) # Let's check for phase mismatch if any if self . num_phase . value == load_obj . num_phase . value : if self . phase != load_obj . phase : raise PhaseMismatchError ( load_obj . phase , self . phase ) if load_obj . num_phase not in self . lateral_configuration : raise IncompleteGeometryConfigurationDict ( load_obj . num_phase , self . lateral_configuration ) line_section = geometry_based_line_section_builder ( edge [ 0 ], edge [ 1 ], load_obj . num_phase , load_obj . phase , load_obj . phase , get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ), \"m\" , edge_data [ \"ampacity\" ], self . catalog_dict [ ConductorType . UNDERGROUND_CONCENTRIC ], self . neutral_present , ConductorType . UNDERGROUND_CONCENTRIC , self . lateral_configuration [ load_obj . num_phase ], k_drop , kv_base , self . lateral_material , ) else : if self . num_phase not in self . geometry_configuration : raise IncompleteGeometryConfigurationDict ( self . num_phase , self . geometry_configuration ) line_section = geometry_based_line_section_builder ( edge [ 0 ], edge [ 1 ], self . num_phase , self . phase , self . phase , get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ), \"m\" , edge_data [ \"ampacity\" ], self . catalog_dict [ self . conductor_type ], self . neutral_present , self . conductor_type , self . geometry_configuration [ self . num_phase ], k_drop , kv_base , self . material , ) line_sections . append ( line_section ) return line_sections","title":"SecondarySectionsBuilder"},{"location":"secondary_network_builder/#shift.secondary_network_builder.SecondarySectionsBuilder.__init__","text":"Constructor for SecondarySectionsBuilder class. Refer to base class arguments. Parameters: Name Type Description Default lateral_configuration dict Drop line configuration data required lateral_material str Conductor material for drop line 'all' Source code in shift\\secondary_network_builder.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def __init__ ( self , secondary_network : nx . Graph , conductor_type : ConductorType , configuration : dict , lateral_configuration : dict , num_phase : NumPhase , phase : Phase , neutral_present : True , material : str = \"all\" , lateral_material : str = \"all\" , ) -> None : \"\"\"Constructor for SecondarySectionsBuilder class. Refer to base class arguments. Args: lateral_configuration (dict): Drop line configuration data lateral_material (str): Conductor material for drop line \"\"\" super () . __init__ ( secondary_network , conductor_type , configuration , num_phase , phase , neutral_present , material , ) self . lateral_material = lateral_material self . lateral_configuration = lateral_configuration","title":"__init__()"},{"location":"secondary_network_builder/#shift.secondary_network_builder.SecondarySectionsBuilder.generate_secondary_line_sections","text":"Method for creating secondary line sections. Parameters: Name Type Description Default k_drop float Expected percentage voltage drop per mile per kva required kv_base float KV base used for computing kVA required Returns: Type Description List [ Line ] List[Line]: List of Line instances Source code in shift\\secondary_network_builder.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def generate_secondary_line_sections ( self , k_drop : float , kv_base : float ) -> List [ Line ]: \"\"\"Method for creating secondary line sections. Args: k_drop (float): Expected percentage voltage drop per mile per kva kv_base (float): KV base used for computing kVA Returns: List[Line]: List of `Line` instances \"\"\" line_sections = [] node_data_dict = { node [ 0 ]: node [ 1 ] for node in self . network . nodes . data () } for edge in self . network . edges (): edge_data = self . network . get_edge_data ( * edge ) # Find edge that connects load and this should be cable if ( \"load\" in self . network . nodes [ edge [ 0 ]] or \"load\" in self . network . nodes [ edge [ 1 ]] ): load_node = 0 if \"load\" in self . network . nodes [ edge [ 0 ]] else 1 load_obj = self . network . nodes [ edge [ load_node ]][ \"object\" ] # fromnode_phase = load_obj.phase if load_node == 0 else self.phase # tonode_phase = load_obj.phase if load_node == 1 else self.phase if load_obj . num_phase . value > self . num_phase . value : raise CustomerInvalidPhase ( load_obj . num_phase , self . num_phase ) # Let's check for phase mismatch if any if self . num_phase . value == load_obj . num_phase . value : if self . phase != load_obj . phase : raise PhaseMismatchError ( load_obj . phase , self . phase ) if load_obj . num_phase not in self . lateral_configuration : raise IncompleteGeometryConfigurationDict ( load_obj . num_phase , self . lateral_configuration ) line_section = geometry_based_line_section_builder ( edge [ 0 ], edge [ 1 ], load_obj . num_phase , load_obj . phase , load_obj . phase , get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ), \"m\" , edge_data [ \"ampacity\" ], self . catalog_dict [ ConductorType . UNDERGROUND_CONCENTRIC ], self . neutral_present , ConductorType . UNDERGROUND_CONCENTRIC , self . lateral_configuration [ load_obj . num_phase ], k_drop , kv_base , self . lateral_material , ) else : if self . num_phase not in self . geometry_configuration : raise IncompleteGeometryConfigurationDict ( self . num_phase , self . geometry_configuration ) line_section = geometry_based_line_section_builder ( edge [ 0 ], edge [ 1 ], self . num_phase , self . phase , self . phase , get_distance ( node_data_dict [ edge [ 0 ]][ \"pos\" ], node_data_dict [ edge [ 1 ]][ \"pos\" ], ), \"m\" , edge_data [ \"ampacity\" ], self . catalog_dict [ self . conductor_type ], self . neutral_present , self . conductor_type , self . geometry_configuration [ self . num_phase ], k_drop , kv_base , self . material , ) line_sections . append ( line_section ) return line_sections","title":"generate_secondary_line_sections()"},{"location":"transformer/","text":"This module contains classes for representing transformer. Transformer Bases: ABC Interface for base transformer representation Source code in shift\\transformer.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 class Transformer ( ABC ): \"\"\"Interface for base transformer representation\"\"\" @property def name ( self ) -> str : \"\"\"Name of the transformer\"\"\" return self . _name @name . setter def name ( self , name : str ) -> None : self . _name = name @property def latitude ( self ) -> float : \"\"\"Latitude property where transformer is located\"\"\" return self . _latitude @latitude . setter def latitude ( self , latitude : float ) -> None : \"\"\"Latitude setter method for the transformer\"\"\" if latitude < MIN_LATITUDE or latitude > MAX_LATITUDE : raise LatitudeNotInRangeError ( latitude ) self . _latitude = latitude @property def longitude ( self ) -> float : \"\"\"Longitude property where transformer is located\"\"\" return self . _longitude @longitude . setter def longitude ( self , longitude : float ) -> None : \"\"\"Longitude setter method for the transformer\"\"\" if longitude < MIN_LONGITUDE or longitude > MAX_LONGITUDE : raise LongitudeNotInRangeError ( longitude ) self . _longitude = longitude @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property for the transformer\"\"\" return self . _num_phase @num_phase . setter def num_phase ( self , num_phase : NumPhase ) -> None : \"\"\"Number of phase setter method for the transformer\"\"\" self . _num_phase = num_phase @property def xhl ( self ) -> float : \"\"\"Percentage reactance property for the transformer\"\"\" return self . _xhl @xhl . setter def xhl ( self , xhl : float ) -> None : \"\"\"Percentage reactance setter method for the transformer\"\"\" if xhl < MIN_PERCENTAGE or xhl > MAX_PERCENTAGE : raise PercentageNotInRangeError ( xhl ) self . _xhl = xhl @property def pct_r ( self ) -> float : \"\"\"Percentage resistance property for the transformer\"\"\" return self . _pct_r @pct_r . setter def pct_r ( self , r : float ) -> None : \"\"\"Percentage resistance setter method for the transformer\"\"\" if r < MIN_PERCENTAGE or r > MAX_PERCENTAGE : raise PercentageNotInRangeError ( r ) self . _pct_r = r @property def pct_noloadloss ( self ) -> float : \"\"\"Percentage no load loss property for the transformer\"\"\" return self . _pct_noloadloss @pct_noloadloss . setter def pct_noloadloss ( self , pct_nl_loss : float ) -> None : \"\"\"Percentage no load loss setter for the transformer\"\"\" if pct_nl_loss < MIN_PERCENTAGE or pct_nl_loss > MAX_PERCENTAGE : raise PercentageNotInRangeError ( pct_nl_loss ) self . _pct_noloadloss = pct_nl_loss @property def kva ( self ) -> float : \"\"\"Transformer kVA property\"\"\" return self . _kva @kva . setter def kva ( self , kva : float ) -> None : \"\"\"kVA setter method for transformer\"\"\" if kva < 0 : raise NegativekVAError ( kva ) self . _kva = kva @property def primary_kv ( self ) -> float : \"\"\"Primary kV of the transformer\"\"\" return self . _primary_kv @primary_kv . setter def primary_kv ( self , kv : float ) -> None : \"\"\"Primary kv setter for transformer\"\"\" if kv < 0 : raise NegativeKVError ( kv ) if kv == 0 : raise ZeroKVError self . _primary_kv = kv @property def secondary_kv ( self ) -> float : \"\"\"Secondary kV of the transformer\"\"\" return self . _secondary_kv @secondary_kv . setter def secondary_kv ( self , kv : float ) -> None : \"\"\"Secondary kv setter for transformer\"\"\" if kv < 0 : raise NegativeKVError ( kv ) if kv == 0 : raise ZeroKVError self . _secondary_kv = kv @property def primary_con ( self ) -> TransformerConnection : \"\"\"Primary connection type of the transformer\"\"\" return self . _primary_con @primary_con . setter def primary_con ( self , conn : TransformerConnection ) -> None : \"\"\"Primary connection setter for transformer\"\"\" self . _primary_con = conn @property def secondary_con ( self ) -> TransformerConnection : \"\"\"Secondary connection type of the transformer\"\"\" return self . _secondary_con @secondary_con . setter def secondary_con ( self , conn : TransformerConnection ) -> None : \"\"\"Primary connection setter for transformer\"\"\" self . _secondary_con = conn @property def primary_phase ( self ) -> Phase : \"\"\"Primary phase of the transformer\"\"\" return self . _primary_phase @primary_phase . setter def primary_phase ( self , phase : Phase ) -> None : \"\"\"Primary phase setter for transformer\"\"\" self . _primary_phase = phase @property def secondary_phase ( self ) -> Phase : \"\"\"Secondary phase of the transformer\"\"\" return self . _secondary_phase @secondary_phase . setter def secondary_phase ( self , phase : Phase ) -> None : \"\"\"Secondary phase setter for transformer\"\"\" self . _secondary_phase = phase def __repr__ ( self ): return ( f \" { self . __class__ . __name__ } (Name = { self . _name } , Latitude = { self . _latitude } , Longitude = { self . _longitude } , \" + f \"NumPhase = { self . _num_phase } , XHL = { self . _xhl } , %R = { self . _pct_r } , %no_load_loss = { self . _pct_noloadloss } , \" + f \"Primary Phase = { self . _primary_phase } , Secondary Phase = { self . _secondary_phase } \" + f \"kVA = { self . _kva } , Primary kV = { self . _primary_kv } , Secondary kV = { self . _secondary_kv } , Primary Conn = { self . _primary_con } , Secondary Conn = { self . _secondary_con } \" ) kva () property writable Transformer kVA property Source code in shift\\transformer.py 137 138 139 140 @property def kva ( self ) -> float : \"\"\"Transformer kVA property\"\"\" return self . _kva latitude () property writable Latitude property where transformer is located Source code in shift\\transformer.py 67 68 69 70 @property def latitude ( self ) -> float : \"\"\"Latitude property where transformer is located\"\"\" return self . _latitude longitude () property writable Longitude property where transformer is located Source code in shift\\transformer.py 79 80 81 82 @property def longitude ( self ) -> float : \"\"\"Longitude property where transformer is located\"\"\" return self . _longitude name () property writable Name of the transformer Source code in shift\\transformer.py 58 59 60 61 @property def name ( self ) -> str : \"\"\"Name of the transformer\"\"\" return self . _name num_phase () property writable Number of phase property for the transformer Source code in shift\\transformer.py 91 92 93 94 @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property for the transformer\"\"\" return self . _num_phase pct_noloadloss () property writable Percentage no load loss property for the transformer Source code in shift\\transformer.py 125 126 127 128 @property def pct_noloadloss ( self ) -> float : \"\"\"Percentage no load loss property for the transformer\"\"\" return self . _pct_noloadloss pct_r () property writable Percentage resistance property for the transformer Source code in shift\\transformer.py 113 114 115 116 @property def pct_r ( self ) -> float : \"\"\"Percentage resistance property for the transformer\"\"\" return self . _pct_r primary_con () property writable Primary connection type of the transformer Source code in shift\\transformer.py 177 178 179 180 @property def primary_con ( self ) -> TransformerConnection : \"\"\"Primary connection type of the transformer\"\"\" return self . _primary_con primary_kv () property writable Primary kV of the transformer Source code in shift\\transformer.py 149 150 151 152 @property def primary_kv ( self ) -> float : \"\"\"Primary kV of the transformer\"\"\" return self . _primary_kv primary_phase () property writable Primary phase of the transformer Source code in shift\\transformer.py 197 198 199 200 @property def primary_phase ( self ) -> Phase : \"\"\"Primary phase of the transformer\"\"\" return self . _primary_phase secondary_con () property writable Secondary connection type of the transformer Source code in shift\\transformer.py 187 188 189 190 @property def secondary_con ( self ) -> TransformerConnection : \"\"\"Secondary connection type of the transformer\"\"\" return self . _secondary_con secondary_kv () property writable Secondary kV of the transformer Source code in shift\\transformer.py 163 164 165 166 @property def secondary_kv ( self ) -> float : \"\"\"Secondary kV of the transformer\"\"\" return self . _secondary_kv secondary_phase () property writable Secondary phase of the transformer Source code in shift\\transformer.py 207 208 209 210 @property def secondary_phase ( self ) -> Phase : \"\"\"Secondary phase of the transformer\"\"\" return self . _secondary_phase xhl () property writable Percentage reactance property for the transformer Source code in shift\\transformer.py 101 102 103 104 @property def xhl ( self ) -> float : \"\"\"Percentage reactance property for the transformer\"\"\" return self . _xhl","title":"transformer"},{"location":"transformer/#shift.transformer.Transformer","text":"Bases: ABC Interface for base transformer representation Source code in shift\\transformer.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 class Transformer ( ABC ): \"\"\"Interface for base transformer representation\"\"\" @property def name ( self ) -> str : \"\"\"Name of the transformer\"\"\" return self . _name @name . setter def name ( self , name : str ) -> None : self . _name = name @property def latitude ( self ) -> float : \"\"\"Latitude property where transformer is located\"\"\" return self . _latitude @latitude . setter def latitude ( self , latitude : float ) -> None : \"\"\"Latitude setter method for the transformer\"\"\" if latitude < MIN_LATITUDE or latitude > MAX_LATITUDE : raise LatitudeNotInRangeError ( latitude ) self . _latitude = latitude @property def longitude ( self ) -> float : \"\"\"Longitude property where transformer is located\"\"\" return self . _longitude @longitude . setter def longitude ( self , longitude : float ) -> None : \"\"\"Longitude setter method for the transformer\"\"\" if longitude < MIN_LONGITUDE or longitude > MAX_LONGITUDE : raise LongitudeNotInRangeError ( longitude ) self . _longitude = longitude @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property for the transformer\"\"\" return self . _num_phase @num_phase . setter def num_phase ( self , num_phase : NumPhase ) -> None : \"\"\"Number of phase setter method for the transformer\"\"\" self . _num_phase = num_phase @property def xhl ( self ) -> float : \"\"\"Percentage reactance property for the transformer\"\"\" return self . _xhl @xhl . setter def xhl ( self , xhl : float ) -> None : \"\"\"Percentage reactance setter method for the transformer\"\"\" if xhl < MIN_PERCENTAGE or xhl > MAX_PERCENTAGE : raise PercentageNotInRangeError ( xhl ) self . _xhl = xhl @property def pct_r ( self ) -> float : \"\"\"Percentage resistance property for the transformer\"\"\" return self . _pct_r @pct_r . setter def pct_r ( self , r : float ) -> None : \"\"\"Percentage resistance setter method for the transformer\"\"\" if r < MIN_PERCENTAGE or r > MAX_PERCENTAGE : raise PercentageNotInRangeError ( r ) self . _pct_r = r @property def pct_noloadloss ( self ) -> float : \"\"\"Percentage no load loss property for the transformer\"\"\" return self . _pct_noloadloss @pct_noloadloss . setter def pct_noloadloss ( self , pct_nl_loss : float ) -> None : \"\"\"Percentage no load loss setter for the transformer\"\"\" if pct_nl_loss < MIN_PERCENTAGE or pct_nl_loss > MAX_PERCENTAGE : raise PercentageNotInRangeError ( pct_nl_loss ) self . _pct_noloadloss = pct_nl_loss @property def kva ( self ) -> float : \"\"\"Transformer kVA property\"\"\" return self . _kva @kva . setter def kva ( self , kva : float ) -> None : \"\"\"kVA setter method for transformer\"\"\" if kva < 0 : raise NegativekVAError ( kva ) self . _kva = kva @property def primary_kv ( self ) -> float : \"\"\"Primary kV of the transformer\"\"\" return self . _primary_kv @primary_kv . setter def primary_kv ( self , kv : float ) -> None : \"\"\"Primary kv setter for transformer\"\"\" if kv < 0 : raise NegativeKVError ( kv ) if kv == 0 : raise ZeroKVError self . _primary_kv = kv @property def secondary_kv ( self ) -> float : \"\"\"Secondary kV of the transformer\"\"\" return self . _secondary_kv @secondary_kv . setter def secondary_kv ( self , kv : float ) -> None : \"\"\"Secondary kv setter for transformer\"\"\" if kv < 0 : raise NegativeKVError ( kv ) if kv == 0 : raise ZeroKVError self . _secondary_kv = kv @property def primary_con ( self ) -> TransformerConnection : \"\"\"Primary connection type of the transformer\"\"\" return self . _primary_con @primary_con . setter def primary_con ( self , conn : TransformerConnection ) -> None : \"\"\"Primary connection setter for transformer\"\"\" self . _primary_con = conn @property def secondary_con ( self ) -> TransformerConnection : \"\"\"Secondary connection type of the transformer\"\"\" return self . _secondary_con @secondary_con . setter def secondary_con ( self , conn : TransformerConnection ) -> None : \"\"\"Primary connection setter for transformer\"\"\" self . _secondary_con = conn @property def primary_phase ( self ) -> Phase : \"\"\"Primary phase of the transformer\"\"\" return self . _primary_phase @primary_phase . setter def primary_phase ( self , phase : Phase ) -> None : \"\"\"Primary phase setter for transformer\"\"\" self . _primary_phase = phase @property def secondary_phase ( self ) -> Phase : \"\"\"Secondary phase of the transformer\"\"\" return self . _secondary_phase @secondary_phase . setter def secondary_phase ( self , phase : Phase ) -> None : \"\"\"Secondary phase setter for transformer\"\"\" self . _secondary_phase = phase def __repr__ ( self ): return ( f \" { self . __class__ . __name__ } (Name = { self . _name } , Latitude = { self . _latitude } , Longitude = { self . _longitude } , \" + f \"NumPhase = { self . _num_phase } , XHL = { self . _xhl } , %R = { self . _pct_r } , %no_load_loss = { self . _pct_noloadloss } , \" + f \"Primary Phase = { self . _primary_phase } , Secondary Phase = { self . _secondary_phase } \" + f \"kVA = { self . _kva } , Primary kV = { self . _primary_kv } , Secondary kV = { self . _secondary_kv } , Primary Conn = { self . _primary_con } , Secondary Conn = { self . _secondary_con } \" )","title":"Transformer"},{"location":"transformer/#shift.transformer.Transformer.kva","text":"Transformer kVA property Source code in shift\\transformer.py 137 138 139 140 @property def kva ( self ) -> float : \"\"\"Transformer kVA property\"\"\" return self . _kva","title":"kva()"},{"location":"transformer/#shift.transformer.Transformer.latitude","text":"Latitude property where transformer is located Source code in shift\\transformer.py 67 68 69 70 @property def latitude ( self ) -> float : \"\"\"Latitude property where transformer is located\"\"\" return self . _latitude","title":"latitude()"},{"location":"transformer/#shift.transformer.Transformer.longitude","text":"Longitude property where transformer is located Source code in shift\\transformer.py 79 80 81 82 @property def longitude ( self ) -> float : \"\"\"Longitude property where transformer is located\"\"\" return self . _longitude","title":"longitude()"},{"location":"transformer/#shift.transformer.Transformer.name","text":"Name of the transformer Source code in shift\\transformer.py 58 59 60 61 @property def name ( self ) -> str : \"\"\"Name of the transformer\"\"\" return self . _name","title":"name()"},{"location":"transformer/#shift.transformer.Transformer.num_phase","text":"Number of phase property for the transformer Source code in shift\\transformer.py 91 92 93 94 @property def num_phase ( self ) -> NumPhase : \"\"\"Number of phase property for the transformer\"\"\" return self . _num_phase","title":"num_phase()"},{"location":"transformer/#shift.transformer.Transformer.pct_noloadloss","text":"Percentage no load loss property for the transformer Source code in shift\\transformer.py 125 126 127 128 @property def pct_noloadloss ( self ) -> float : \"\"\"Percentage no load loss property for the transformer\"\"\" return self . _pct_noloadloss","title":"pct_noloadloss()"},{"location":"transformer/#shift.transformer.Transformer.pct_r","text":"Percentage resistance property for the transformer Source code in shift\\transformer.py 113 114 115 116 @property def pct_r ( self ) -> float : \"\"\"Percentage resistance property for the transformer\"\"\" return self . _pct_r","title":"pct_r()"},{"location":"transformer/#shift.transformer.Transformer.primary_con","text":"Primary connection type of the transformer Source code in shift\\transformer.py 177 178 179 180 @property def primary_con ( self ) -> TransformerConnection : \"\"\"Primary connection type of the transformer\"\"\" return self . _primary_con","title":"primary_con()"},{"location":"transformer/#shift.transformer.Transformer.primary_kv","text":"Primary kV of the transformer Source code in shift\\transformer.py 149 150 151 152 @property def primary_kv ( self ) -> float : \"\"\"Primary kV of the transformer\"\"\" return self . _primary_kv","title":"primary_kv()"},{"location":"transformer/#shift.transformer.Transformer.primary_phase","text":"Primary phase of the transformer Source code in shift\\transformer.py 197 198 199 200 @property def primary_phase ( self ) -> Phase : \"\"\"Primary phase of the transformer\"\"\" return self . _primary_phase","title":"primary_phase()"},{"location":"transformer/#shift.transformer.Transformer.secondary_con","text":"Secondary connection type of the transformer Source code in shift\\transformer.py 187 188 189 190 @property def secondary_con ( self ) -> TransformerConnection : \"\"\"Secondary connection type of the transformer\"\"\" return self . _secondary_con","title":"secondary_con()"},{"location":"transformer/#shift.transformer.Transformer.secondary_kv","text":"Secondary kV of the transformer Source code in shift\\transformer.py 163 164 165 166 @property def secondary_kv ( self ) -> float : \"\"\"Secondary kV of the transformer\"\"\" return self . _secondary_kv","title":"secondary_kv()"},{"location":"transformer/#shift.transformer.Transformer.secondary_phase","text":"Secondary phase of the transformer Source code in shift\\transformer.py 207 208 209 210 @property def secondary_phase ( self ) -> Phase : \"\"\"Secondary phase of the transformer\"\"\" return self . _secondary_phase","title":"secondary_phase()"},{"location":"transformer/#shift.transformer.Transformer.xhl","text":"Percentage reactance property for the transformer Source code in shift\\transformer.py 101 102 103 104 @property def xhl ( self ) -> float : \"\"\"Percentage reactance property for the transformer\"\"\" return self . _xhl","title":"xhl()"},{"location":"transformer_builder/","text":"This module contains classes for building transformers. ClusteringBasedTransformerLoadMapper Bases: TransformerLoadMapper Uses clustering algorithms to figure out transformer location. Refer to base class for attributes passed to base class. Attributes: Name Type Description ht_kv float High tension side kV lt_kv float Low tension side kV num_phase NumPhase NumPhase instance ht_conn TransformerConnection TransformerConnection instance for high tension side lt_conn TransformerConnection TransformerConnection instance for low tension side ht_phase Phase Phase instance for high tension side lt_phase Phase Phase instance for low tension side clustering_object Clustering Clustering instance Source code in shift\\transformer_builder.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 class ClusteringBasedTransformerLoadMapper ( TransformerLoadMapper ): \"\"\"Uses clustering algorithms to figure out transformer location. Refer to base class for attributes passed to base class. Attributes: ht_kv (float): High tension side kV lt_kv (float): Low tension side kV num_phase (NumPhase): NumPhase instance ht_conn (TransformerConnection): TransformerConnection instance for high tension side lt_conn (TransformerConnection): TransformerConnection instance for low tension side ht_phase (Phase): Phase instance for high tension side lt_phase (Phase): Phase instance for low tension side clustering_object (Clustering): Clustering instance \"\"\" def __init__ ( self , loads : List [ Load ], clustering_object : Clustering , diversity_factor_func : Callable [[ float ], float ], ht_kv : float , lt_kv : float , ht_conn : TransformerConnection , lt_conn : TransformerConnection , ht_phase : Phase , lt_phase : Phase , num_phase : NumPhase , catalog_type = \"all\" , power_factor : float = 1.0 , adjustment_factor : float = 1.25 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ): \"\"\"Constructor for `ClusteringBasedTransformerLoadMapper` class. Args: ht_kv (float): High tension side kV lt_kv (float): Low tension side kV num_phase (NumPhase): NumPhase instance ht_conn (TransformerConnection): TransformerConnection instance for high tension side lt_conn (TransformerConnection): TransformerConnection instance for low tension side ht_phase (Phase): Phase instance for high tension side lt_phase (Phase): Phase instance for low tension side clustering_object (Clustering): Clustering instance Raises: ZeroKVError: If kv specified is zero NegativeKVError: If kv specified is negative HTkVlowerthanLTkVError: If high tension kv used is less than low tension kv \"\"\" super () . __init__ ( loads , diversity_factor_func , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , power_factor , catalog_type , ) self . clustering_object = clustering_object self . ht_kv = ht_kv self . lt_kv = lt_kv self . num_phase = num_phase self . ht_conn = ht_conn self . lt_conn = lt_conn self . ht_phase = ht_phase self . lt_phase = lt_phase for kv in [ self . ht_kv , self . lt_kv ]: if kv == 0 : raise ZeroKVError if kv < 0 : raise NegativeKVError if self . ht_kv < self . lt_kv : raise HTkVlowerthanLTkVError ( self . ht_kv , self . lt_kv ) def get_transformer_load_mapping ( self ) -> dict : \"\"\"Refer to base class for more details.\"\"\" # Prepare the data for clustering x_array = np . array ( [[ load . longitude , load . latitude ] for load in self . loads ] ) # Perform clustering operation based on x_data clusters = self . clustering_object . get_clusters ( x_array ) # Mapping cluster centre to loads \"\"\" cluster_to_customers = { tuple ( c ): [] for c in clusters [ \"centre\" ]} for label , load in zip ( clusters [ \"labels\" ], self . loads ): centre = tuple ( clusters [ \"centre\" ][ label ]) cluster_to_customers [ centre ] . append ( load ) # Container to store all the transformers with all the mapping self . transformers = {} for xfmr , t_loads in cluster_to_customers . items (): # Now let's initialize the transformer with it's proper values catalog_used = self . get_catalog_object ( t_loads , self . ht_kv , self . lt_kv ) trans = Transformer () trans . latitude = xfmr [ 1 ] trans . longitude = xfmr [ 0 ] trans . name = f \" { xfmr [ 0 ] } _ { xfmr [ 1 ] } _transformer\" trans . primary_kv = self . ht_kv trans . secondary_kv = self . lt_kv trans . pct_r = catalog_used [ \"percentage_resistance\" ] trans . xhl = catalog_used [ \"percentage_reactance\" ] trans . pct_noloadloss = catalog_used [ \"percentage_no_load_loss\" ] trans . num_phase = self . num_phase trans . primary_con = self . ht_conn trans . kva = catalog_used [ \"kva\" ] trans . secondary_con = self . lt_conn trans . primary_phase = self . ht_phase trans . secondary_phase = self . lt_phase self . transformers [ trans ] = t_loads return self . transformers __init__ ( loads , clustering_object , diversity_factor_func , ht_kv , lt_kv , ht_conn , lt_conn , ht_phase , lt_phase , num_phase , catalog_type = 'all' , power_factor = 1.0 , adjustment_factor = 1.25 , planned_avg_annual_growth = 2 , actual_avg_annual_growth = 4 , actual_years_in_operation = 15 , planned_years_in_operation = 10 ) Constructor for ClusteringBasedTransformerLoadMapper class. Parameters: Name Type Description Default ht_kv float High tension side kV required lt_kv float Low tension side kV required num_phase NumPhase NumPhase instance required ht_conn TransformerConnection TransformerConnection instance for high tension side required lt_conn TransformerConnection TransformerConnection instance for low tension side required ht_phase Phase Phase instance for high tension side required lt_phase Phase Phase instance for low tension side required clustering_object Clustering Clustering instance required Raises: Type Description ZeroKVError If kv specified is zero NegativeKVError If kv specified is negative HTkVlowerthanLTkVError If high tension kv used is less than low tension kv Source code in shift\\transformer_builder.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 def __init__ ( self , loads : List [ Load ], clustering_object : Clustering , diversity_factor_func : Callable [[ float ], float ], ht_kv : float , lt_kv : float , ht_conn : TransformerConnection , lt_conn : TransformerConnection , ht_phase : Phase , lt_phase : Phase , num_phase : NumPhase , catalog_type = \"all\" , power_factor : float = 1.0 , adjustment_factor : float = 1.25 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ): \"\"\"Constructor for `ClusteringBasedTransformerLoadMapper` class. Args: ht_kv (float): High tension side kV lt_kv (float): Low tension side kV num_phase (NumPhase): NumPhase instance ht_conn (TransformerConnection): TransformerConnection instance for high tension side lt_conn (TransformerConnection): TransformerConnection instance for low tension side ht_phase (Phase): Phase instance for high tension side lt_phase (Phase): Phase instance for low tension side clustering_object (Clustering): Clustering instance Raises: ZeroKVError: If kv specified is zero NegativeKVError: If kv specified is negative HTkVlowerthanLTkVError: If high tension kv used is less than low tension kv \"\"\" super () . __init__ ( loads , diversity_factor_func , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , power_factor , catalog_type , ) self . clustering_object = clustering_object self . ht_kv = ht_kv self . lt_kv = lt_kv self . num_phase = num_phase self . ht_conn = ht_conn self . lt_conn = lt_conn self . ht_phase = ht_phase self . lt_phase = lt_phase for kv in [ self . ht_kv , self . lt_kv ]: if kv == 0 : raise ZeroKVError if kv < 0 : raise NegativeKVError if self . ht_kv < self . lt_kv : raise HTkVlowerthanLTkVError ( self . ht_kv , self . lt_kv ) get_transformer_load_mapping () Refer to base class for more details. Source code in shift\\transformer_builder.py 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 def get_transformer_load_mapping ( self ) -> dict : \"\"\"Refer to base class for more details.\"\"\" # Prepare the data for clustering x_array = np . array ( [[ load . longitude , load . latitude ] for load in self . loads ] ) # Perform clustering operation based on x_data clusters = self . clustering_object . get_clusters ( x_array ) # Mapping cluster centre to loads \"\"\" cluster_to_customers = { tuple ( c ): [] for c in clusters [ \"centre\" ]} for label , load in zip ( clusters [ \"labels\" ], self . loads ): centre = tuple ( clusters [ \"centre\" ][ label ]) cluster_to_customers [ centre ] . append ( load ) # Container to store all the transformers with all the mapping self . transformers = {} for xfmr , t_loads in cluster_to_customers . items (): # Now let's initialize the transformer with it's proper values catalog_used = self . get_catalog_object ( t_loads , self . ht_kv , self . lt_kv ) trans = Transformer () trans . latitude = xfmr [ 1 ] trans . longitude = xfmr [ 0 ] trans . name = f \" { xfmr [ 0 ] } _ { xfmr [ 1 ] } _transformer\" trans . primary_kv = self . ht_kv trans . secondary_kv = self . lt_kv trans . pct_r = catalog_used [ \"percentage_resistance\" ] trans . xhl = catalog_used [ \"percentage_reactance\" ] trans . pct_noloadloss = catalog_used [ \"percentage_no_load_loss\" ] trans . num_phase = self . num_phase trans . primary_con = self . ht_conn trans . kva = catalog_used [ \"kva\" ] trans . secondary_con = self . lt_conn trans . primary_phase = self . ht_phase trans . secondary_phase = self . lt_phase self . transformers [ trans ] = t_loads return self . transformers SingleTransformerBuilder Bases: TransformerLoadMapper Class for managing building of single transformer used to build substation transformer. Refer to base class for attributes passed to base class. Attributes: Name Type Description ht_kv float High tension side kV lt_kv float Low tension side kV num_phase NumPhase NumPhase instance ht_conn TransformerConnection TransformerConnection instance for high tension side lt_conn TransformerConnection TransformerConnection instance for low tension side ht_phase Phase Phase instance for high tension side lt_phase Phase Phase instance for low tension side longitude float Longitude property of transformer latitude float Latitude property of transformer Source code in shift\\transformer_builder.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 class SingleTransformerBuilder ( TransformerLoadMapper ): \"\"\"Class for managing building of single transformer used to build substation transformer. Refer to base class for attributes passed to base class. Attributes: ht_kv (float): High tension side kV lt_kv (float): Low tension side kV num_phase (NumPhase): NumPhase instance ht_conn (TransformerConnection): TransformerConnection instance for high tension side lt_conn (TransformerConnection): TransformerConnection instance for low tension side ht_phase (Phase): Phase instance for high tension side lt_phase (Phase): Phase instance for low tension side longitude (float): Longitude property of transformer latitude (float): Latitude property of transformer \"\"\" def __init__ ( self , loads : List [ Load ], longitude : float , latitude : float , diversity_factor_func : Callable [[ float ], float ], ht_kv : float , lt_kv : float , ht_conn : TransformerConnection , lt_conn : TransformerConnection , ht_phase : Phase , lt_phase : Phase , num_phase : NumPhase , catalog_type = \"all\" , power_factor : float = 1.0 , adjustment_factor : float = 1.25 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ) -> None : \"\"\"Constructor for `SingleTransformerBuilder` class. Args: ht_kv (float): High tension side kV lt_kv (float): Low tension side kV num_phase (NumPhase): NumPhase instance ht_conn (TransformerConnection): TransformerConnection instance for high tension side lt_conn (TransformerConnection): TransformerConnection instance for low tension side ht_phase (Phase): Phase instance for high tension side lt_phase (Phase): Phase instance for low tension side longitude (float): Longitude property of transformer latitude (float): Latitude property of transformer Raises: ZeroKVError: If kv specified is zero NegativeKVError: If kv specified is negative HTkVlowerthanLTkVError: If high tension kv used is less than low tension kv \"\"\" super () . __init__ ( loads , diversity_factor_func , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , power_factor , catalog_type , ) self . ht_kv = ht_kv self . lt_kv = lt_kv self . num_phase = num_phase self . ht_conn = ht_conn self . lt_conn = lt_conn self . ht_phase = ht_phase self . lt_phase = lt_phase self . longitude = longitude self . latitude = latitude for kv in [ self . ht_kv , self . lt_kv ]: if kv == 0 : raise ZeroKVError if kv < 0 : raise NegativeKVError if self . ht_kv < self . lt_kv : raise HTkVlowerthanLTkVError ( self . ht_kv , self . lt_kv ) def get_transformer_load_mapping ( self ) -> dict : \"\"\"Refer to base class for more details.\"\"\" self . transformers = {} catalog_used = self . get_catalog_object ( self . loads , self . ht_kv , self . lt_kv ) trans = Transformer () trans . latitude = self . latitude trans . longitude = self . longitude trans . name = f \" { self . longitude } _ { self . latitude } _transformer\" trans . primary_kv = self . ht_kv trans . secondary_kv = self . lt_kv trans . pct_r = catalog_used [ \"percentage_resistance\" ] trans . xhl = catalog_used [ \"percentage_reactance\" ] trans . pct_noloadloss = catalog_used [ \"percentage_no_load_loss\" ] trans . num_phase = self . num_phase trans . primary_con = self . ht_conn trans . kva = catalog_used [ \"kva\" ] trans . secondary_con = self . lt_conn trans . primary_phase = self . ht_phase trans . secondary_phase = self . lt_phase self . transformers [ trans ] = self . loads return self . transformers __init__ ( loads , longitude , latitude , diversity_factor_func , ht_kv , lt_kv , ht_conn , lt_conn , ht_phase , lt_phase , num_phase , catalog_type = 'all' , power_factor = 1.0 , adjustment_factor = 1.25 , planned_avg_annual_growth = 2 , actual_avg_annual_growth = 4 , actual_years_in_operation = 15 , planned_years_in_operation = 10 ) Constructor for SingleTransformerBuilder class. Parameters: Name Type Description Default ht_kv float High tension side kV required lt_kv float Low tension side kV required num_phase NumPhase NumPhase instance required ht_conn TransformerConnection TransformerConnection instance for high tension side required lt_conn TransformerConnection TransformerConnection instance for low tension side required ht_phase Phase Phase instance for high tension side required lt_phase Phase Phase instance for low tension side required longitude float Longitude property of transformer required latitude float Latitude property of transformer required Raises: Type Description ZeroKVError If kv specified is zero NegativeKVError If kv specified is negative HTkVlowerthanLTkVError If high tension kv used is less than low tension kv Source code in shift\\transformer_builder.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def __init__ ( self , loads : List [ Load ], longitude : float , latitude : float , diversity_factor_func : Callable [[ float ], float ], ht_kv : float , lt_kv : float , ht_conn : TransformerConnection , lt_conn : TransformerConnection , ht_phase : Phase , lt_phase : Phase , num_phase : NumPhase , catalog_type = \"all\" , power_factor : float = 1.0 , adjustment_factor : float = 1.25 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ) -> None : \"\"\"Constructor for `SingleTransformerBuilder` class. Args: ht_kv (float): High tension side kV lt_kv (float): Low tension side kV num_phase (NumPhase): NumPhase instance ht_conn (TransformerConnection): TransformerConnection instance for high tension side lt_conn (TransformerConnection): TransformerConnection instance for low tension side ht_phase (Phase): Phase instance for high tension side lt_phase (Phase): Phase instance for low tension side longitude (float): Longitude property of transformer latitude (float): Latitude property of transformer Raises: ZeroKVError: If kv specified is zero NegativeKVError: If kv specified is negative HTkVlowerthanLTkVError: If high tension kv used is less than low tension kv \"\"\" super () . __init__ ( loads , diversity_factor_func , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , power_factor , catalog_type , ) self . ht_kv = ht_kv self . lt_kv = lt_kv self . num_phase = num_phase self . ht_conn = ht_conn self . lt_conn = lt_conn self . ht_phase = ht_phase self . lt_phase = lt_phase self . longitude = longitude self . latitude = latitude for kv in [ self . ht_kv , self . lt_kv ]: if kv == 0 : raise ZeroKVError if kv < 0 : raise NegativeKVError if self . ht_kv < self . lt_kv : raise HTkVlowerthanLTkVError ( self . ht_kv , self . lt_kv ) get_transformer_load_mapping () Refer to base class for more details. Source code in shift\\transformer_builder.py 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 def get_transformer_load_mapping ( self ) -> dict : \"\"\"Refer to base class for more details.\"\"\" self . transformers = {} catalog_used = self . get_catalog_object ( self . loads , self . ht_kv , self . lt_kv ) trans = Transformer () trans . latitude = self . latitude trans . longitude = self . longitude trans . name = f \" { self . longitude } _ { self . latitude } _transformer\" trans . primary_kv = self . ht_kv trans . secondary_kv = self . lt_kv trans . pct_r = catalog_used [ \"percentage_resistance\" ] trans . xhl = catalog_used [ \"percentage_reactance\" ] trans . pct_noloadloss = catalog_used [ \"percentage_no_load_loss\" ] trans . num_phase = self . num_phase trans . primary_con = self . ht_conn trans . kva = catalog_used [ \"kva\" ] trans . secondary_con = self . lt_conn trans . primary_phase = self . ht_phase trans . secondary_phase = self . lt_phase self . transformers [ trans ] = self . loads return self . transformers TransformerLoadMapper Bases: ABC Interface for getting transformer load mapping. Attributes: Name Type Description loads List [ Load ] List of loads diversity_factor_func Callable Callable to compute diversity factor adjustment_factor float Adjustment factor for adjusting kva planned_avg_annual_growth float Planned average annual load growth rate in percentage actual_avg_annual_growth float Actual average annual load growth rate in percentage actual_years_in_operation float Actual years in operation planned_years_in_operation float Planned years in operation power_factor float Power factor used to compute kva catalog_type str Catalog type used for choosing transformer trans_catalog pd . DataFrame Dataframe containing transformer catalogs Source code in shift\\transformer_builder.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 class TransformerLoadMapper ( ABC ): \"\"\"Interface for getting transformer load mapping. Attributes: loads (List[Load]): List of loads diversity_factor_func (Callable): Callable to compute diversity factor adjustment_factor (float): Adjustment factor for adjusting kva planned_avg_annual_growth (float): Planned average annual load growth rate in percentage actual_avg_annual_growth (float): Actual average annual load growth rate in percentage actual_years_in_operation (float): Actual years in operation planned_years_in_operation (float): Planned years in operation power_factor (float): Power factor used to compute kva catalog_type (str): Catalog type used for choosing transformer trans_catalog (pd.DataFrame): Dataframe containing transformer catalogs \"\"\" def __init__ ( self , loads : List [ Load ], diversity_factor_func : Callable [[ float ], float ], adjustment_factor : float = 1.25 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , power_factor : float = 0.9 , catalog_type : str = \"all\" , ) -> None : \"\"\"Constructor for `TransformerLoadMapper` class. Args: loads (List[Load]): List of loads diversity_factor_func (Callable[[float], float]): Callable to compute diversity factor adjustment_factor (float): Adjustment factor for adjusting kva planned_avg_annual_growth (float): Planned average annual load growth rate in percentage actual_avg_annual_growth (float): Actual average annual load growth rate in percentage actual_years_in_operation (float): Actual years in operation planned_years_in_operation (float): Planned years in operation power_factor (float): Power factor used to compute kva catalog_type (str): Catalog type used for choosing transformer Raises: PercentageNotInRangeError: If invalid percentage is used OperationYearNotInRange: If invalid operation year is used AdjustmentFactorNotInRangeError: If invalid adjustment factor is used PowerFactorNotInRangeError: If invalid power factor is used EmptyCatalog: If catalog is empty for given type \"\"\" self . loads = loads self . diversity_factor_func = diversity_factor_func self . planned_avg_annual_growth = planned_avg_annual_growth self . actual_avg_annual_growth = actual_avg_annual_growth self . actual_years_in_operation = actual_years_in_operation self . planned_years_in_operation = planned_years_in_operation self . power_factor = power_factor if ( self . planned_avg_annual_growth < MIN_PERCENTAGE or self . planned_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . planned_avg_annual_growth ) if ( self . actual_avg_annual_growth < MIN_PERCENTAGE or self . actual_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . actual_avg_annual_growth ) if ( self . actual_years_in_operation < MIN_YEAR_OPERATION or self . actual_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . actual_years_in_operation ) if ( self . planned_years_in_operation < MIN_YEAR_OPERATION or self . planned_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . planned_years_in_operation ) self . adjustment_factor = adjustment_factor if ( self . adjustment_factor < MIN_ADJUSTMENT_FACTOR or self . adjustment_factor > MAX_ADJUSTMENT_FACTOR ): raise AdjustmentFactorNotInRangeError ( self . adjustment_factor ) if ( self . power_factor < MIN_POWER_FACTOR or self . power_factor > MAX_POWER_FACTOR ): raise PowerFactorNotInRangeError ( self . power_factor ) self . trans_catalog = pd . read_excel ( TRANSFORMER_CATALOG_FILE ) df_validator ( TRANSFORMER_CATALAOG_SCHEMA , self . trans_catalog ) if catalog_type != \"all\" : self . trans_catalog = self . trans_catalog . loc [ self . trans_catalog [ \"type\" ] == type ] if self . trans_catalog . empty : raise EmptyCatalog ( f \"Catalog of type { type } not found in transformer.xlsx file\" ) def compute_transformer_kva_capacity ( self , non_coincident_peak : float , num_of_customers : int ) -> float : \"\"\"Method for computing transformer capacity. Args: non_coincident_peak (float): Non coincident peak num_of_customers (int): Number of customers Returns: float: Transformer size \"\"\" # Initial step is to compute maximum diversified demand div_factor = ( self . diversity_factor_func ( num_of_customers ) if num_of_customers > 1 else 1 ) max_diversified_demand = non_coincident_peak / div_factor max_diversified_kva = ( max_diversified_demand * self . adjustment_factor / self . power_factor ) original_max_diversified_kva = max_diversified_kva / math . pow ( 1 + self . actual_avg_annual_growth / 100 , self . actual_years_in_operation , ) trafo_size = original_max_diversified_kva * math . pow ( 1 + self . planned_avg_annual_growth / 100 , self . planned_years_in_operation , ) return trafo_size @abstractmethod def get_transformer_load_mapping ( self ) -> dict : \"\"\"Abstract method for returning transformer to loads mapping.\"\"\" pass def get_catalog_object ( self , t_loads : List [ Load ], ht_kv : float , lt_kv : float ) -> dict : \"\"\"Method for getting transformet catalog. Args: t_loads (List[Load]): List of `Load` instances ht_kv (float): High tension kV lt_kv (float): Low tension kv Raises: EmptyCatalog: If transformer catalog is not found Returns: dict: Transformer record \"\"\" # Get maximum diversified demand (kW) and adjusted kW sum_of_noncoincident_peaks = sum ([ l . kw for l in t_loads ]) kva = self . compute_transformer_kva_capacity ( sum_of_noncoincident_peaks , len ( t_loads ) ) # Filter by capacity above kva capacity catalog = self . trans_catalog [ self . trans_catalog [ \"kva\" ] >= kva ] if not catalog . empty : # Filter by high voltage catalog = catalog [ catalog [ \"ht_kv\" ] >= ht_kv ] if not catalog . empty : # Filter by low voltage catalog = catalog [ catalog [ \"lt_kv\" ] >= lt_kv ] if not catalog . empty : catalog_used = catalog . loc [ catalog [ \"kva\" ] . idxmin () ] . to_dict () else : raise EmptyCatalog ( f \"Catalog does not exist for transformer of capacity above or equal to \\ { kva } kVA with high tension voltage above or equal to { ht_kv } and \\ above or equal to low tension voltage { lt_kv } \" ) else : raise EmptyCatalog ( f \"Catalog does not exist for transformer of capacity greater than \\ { kva } kVA with high tension voltage greater than or equal to { ht_kv } \" ) else : raise EmptyCatalog ( \"Catalog does not exist for transformer of capacity above or equal to {kva} kVA\" ) return catalog_used __init__ ( loads , diversity_factor_func , adjustment_factor = 1.25 , planned_avg_annual_growth = 2 , actual_avg_annual_growth = 4 , actual_years_in_operation = 15 , planned_years_in_operation = 10 , power_factor = 0.9 , catalog_type = 'all' ) Constructor for TransformerLoadMapper class. Parameters: Name Type Description Default loads List [ Load ] List of loads required diversity_factor_func Callable [[ float ], float ] Callable to compute diversity factor required adjustment_factor float Adjustment factor for adjusting kva 1.25 planned_avg_annual_growth float Planned average annual load growth rate in percentage 2 actual_avg_annual_growth float Actual average annual load growth rate in percentage 4 actual_years_in_operation float Actual years in operation 15 planned_years_in_operation float Planned years in operation 10 power_factor float Power factor used to compute kva 0.9 catalog_type str Catalog type used for choosing transformer 'all' Raises: Type Description PercentageNotInRangeError If invalid percentage is used OperationYearNotInRange If invalid operation year is used AdjustmentFactorNotInRangeError If invalid adjustment factor is used PowerFactorNotInRangeError If invalid power factor is used EmptyCatalog If catalog is empty for given type Source code in shift\\transformer_builder.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def __init__ ( self , loads : List [ Load ], diversity_factor_func : Callable [[ float ], float ], adjustment_factor : float = 1.25 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , power_factor : float = 0.9 , catalog_type : str = \"all\" , ) -> None : \"\"\"Constructor for `TransformerLoadMapper` class. Args: loads (List[Load]): List of loads diversity_factor_func (Callable[[float], float]): Callable to compute diversity factor adjustment_factor (float): Adjustment factor for adjusting kva planned_avg_annual_growth (float): Planned average annual load growth rate in percentage actual_avg_annual_growth (float): Actual average annual load growth rate in percentage actual_years_in_operation (float): Actual years in operation planned_years_in_operation (float): Planned years in operation power_factor (float): Power factor used to compute kva catalog_type (str): Catalog type used for choosing transformer Raises: PercentageNotInRangeError: If invalid percentage is used OperationYearNotInRange: If invalid operation year is used AdjustmentFactorNotInRangeError: If invalid adjustment factor is used PowerFactorNotInRangeError: If invalid power factor is used EmptyCatalog: If catalog is empty for given type \"\"\" self . loads = loads self . diversity_factor_func = diversity_factor_func self . planned_avg_annual_growth = planned_avg_annual_growth self . actual_avg_annual_growth = actual_avg_annual_growth self . actual_years_in_operation = actual_years_in_operation self . planned_years_in_operation = planned_years_in_operation self . power_factor = power_factor if ( self . planned_avg_annual_growth < MIN_PERCENTAGE or self . planned_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . planned_avg_annual_growth ) if ( self . actual_avg_annual_growth < MIN_PERCENTAGE or self . actual_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . actual_avg_annual_growth ) if ( self . actual_years_in_operation < MIN_YEAR_OPERATION or self . actual_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . actual_years_in_operation ) if ( self . planned_years_in_operation < MIN_YEAR_OPERATION or self . planned_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . planned_years_in_operation ) self . adjustment_factor = adjustment_factor if ( self . adjustment_factor < MIN_ADJUSTMENT_FACTOR or self . adjustment_factor > MAX_ADJUSTMENT_FACTOR ): raise AdjustmentFactorNotInRangeError ( self . adjustment_factor ) if ( self . power_factor < MIN_POWER_FACTOR or self . power_factor > MAX_POWER_FACTOR ): raise PowerFactorNotInRangeError ( self . power_factor ) self . trans_catalog = pd . read_excel ( TRANSFORMER_CATALOG_FILE ) df_validator ( TRANSFORMER_CATALAOG_SCHEMA , self . trans_catalog ) if catalog_type != \"all\" : self . trans_catalog = self . trans_catalog . loc [ self . trans_catalog [ \"type\" ] == type ] if self . trans_catalog . empty : raise EmptyCatalog ( f \"Catalog of type { type } not found in transformer.xlsx file\" ) compute_transformer_kva_capacity ( non_coincident_peak , num_of_customers ) Method for computing transformer capacity. Parameters: Name Type Description Default non_coincident_peak float Non coincident peak required num_of_customers int Number of customers required Returns: Name Type Description float float Transformer size Source code in shift\\transformer_builder.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def compute_transformer_kva_capacity ( self , non_coincident_peak : float , num_of_customers : int ) -> float : \"\"\"Method for computing transformer capacity. Args: non_coincident_peak (float): Non coincident peak num_of_customers (int): Number of customers Returns: float: Transformer size \"\"\" # Initial step is to compute maximum diversified demand div_factor = ( self . diversity_factor_func ( num_of_customers ) if num_of_customers > 1 else 1 ) max_diversified_demand = non_coincident_peak / div_factor max_diversified_kva = ( max_diversified_demand * self . adjustment_factor / self . power_factor ) original_max_diversified_kva = max_diversified_kva / math . pow ( 1 + self . actual_avg_annual_growth / 100 , self . actual_years_in_operation , ) trafo_size = original_max_diversified_kva * math . pow ( 1 + self . planned_avg_annual_growth / 100 , self . planned_years_in_operation , ) return trafo_size get_catalog_object ( t_loads , ht_kv , lt_kv ) Method for getting transformet catalog. Parameters: Name Type Description Default t_loads List [ Load ] List of Load instances required ht_kv float High tension kV required lt_kv float Low tension kv required Raises: Type Description EmptyCatalog If transformer catalog is not found Returns: Name Type Description dict dict Transformer record Source code in shift\\transformer_builder.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def get_catalog_object ( self , t_loads : List [ Load ], ht_kv : float , lt_kv : float ) -> dict : \"\"\"Method for getting transformet catalog. Args: t_loads (List[Load]): List of `Load` instances ht_kv (float): High tension kV lt_kv (float): Low tension kv Raises: EmptyCatalog: If transformer catalog is not found Returns: dict: Transformer record \"\"\" # Get maximum diversified demand (kW) and adjusted kW sum_of_noncoincident_peaks = sum ([ l . kw for l in t_loads ]) kva = self . compute_transformer_kva_capacity ( sum_of_noncoincident_peaks , len ( t_loads ) ) # Filter by capacity above kva capacity catalog = self . trans_catalog [ self . trans_catalog [ \"kva\" ] >= kva ] if not catalog . empty : # Filter by high voltage catalog = catalog [ catalog [ \"ht_kv\" ] >= ht_kv ] if not catalog . empty : # Filter by low voltage catalog = catalog [ catalog [ \"lt_kv\" ] >= lt_kv ] if not catalog . empty : catalog_used = catalog . loc [ catalog [ \"kva\" ] . idxmin () ] . to_dict () else : raise EmptyCatalog ( f \"Catalog does not exist for transformer of capacity above or equal to \\ { kva } kVA with high tension voltage above or equal to { ht_kv } and \\ above or equal to low tension voltage { lt_kv } \" ) else : raise EmptyCatalog ( f \"Catalog does not exist for transformer of capacity greater than \\ { kva } kVA with high tension voltage greater than or equal to { ht_kv } \" ) else : raise EmptyCatalog ( \"Catalog does not exist for transformer of capacity above or equal to {kva} kVA\" ) return catalog_used get_transformer_load_mapping () abstractmethod Abstract method for returning transformer to loads mapping. Source code in shift\\transformer_builder.py 210 211 212 213 @abstractmethod def get_transformer_load_mapping ( self ) -> dict : \"\"\"Abstract method for returning transformer to loads mapping.\"\"\" pass","title":"transformer_builder"},{"location":"transformer_builder/#shift.transformer_builder.ClusteringBasedTransformerLoadMapper","text":"Bases: TransformerLoadMapper Uses clustering algorithms to figure out transformer location. Refer to base class for attributes passed to base class. Attributes: Name Type Description ht_kv float High tension side kV lt_kv float Low tension side kV num_phase NumPhase NumPhase instance ht_conn TransformerConnection TransformerConnection instance for high tension side lt_conn TransformerConnection TransformerConnection instance for low tension side ht_phase Phase Phase instance for high tension side lt_phase Phase Phase instance for low tension side clustering_object Clustering Clustering instance Source code in shift\\transformer_builder.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 class ClusteringBasedTransformerLoadMapper ( TransformerLoadMapper ): \"\"\"Uses clustering algorithms to figure out transformer location. Refer to base class for attributes passed to base class. Attributes: ht_kv (float): High tension side kV lt_kv (float): Low tension side kV num_phase (NumPhase): NumPhase instance ht_conn (TransformerConnection): TransformerConnection instance for high tension side lt_conn (TransformerConnection): TransformerConnection instance for low tension side ht_phase (Phase): Phase instance for high tension side lt_phase (Phase): Phase instance for low tension side clustering_object (Clustering): Clustering instance \"\"\" def __init__ ( self , loads : List [ Load ], clustering_object : Clustering , diversity_factor_func : Callable [[ float ], float ], ht_kv : float , lt_kv : float , ht_conn : TransformerConnection , lt_conn : TransformerConnection , ht_phase : Phase , lt_phase : Phase , num_phase : NumPhase , catalog_type = \"all\" , power_factor : float = 1.0 , adjustment_factor : float = 1.25 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ): \"\"\"Constructor for `ClusteringBasedTransformerLoadMapper` class. Args: ht_kv (float): High tension side kV lt_kv (float): Low tension side kV num_phase (NumPhase): NumPhase instance ht_conn (TransformerConnection): TransformerConnection instance for high tension side lt_conn (TransformerConnection): TransformerConnection instance for low tension side ht_phase (Phase): Phase instance for high tension side lt_phase (Phase): Phase instance for low tension side clustering_object (Clustering): Clustering instance Raises: ZeroKVError: If kv specified is zero NegativeKVError: If kv specified is negative HTkVlowerthanLTkVError: If high tension kv used is less than low tension kv \"\"\" super () . __init__ ( loads , diversity_factor_func , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , power_factor , catalog_type , ) self . clustering_object = clustering_object self . ht_kv = ht_kv self . lt_kv = lt_kv self . num_phase = num_phase self . ht_conn = ht_conn self . lt_conn = lt_conn self . ht_phase = ht_phase self . lt_phase = lt_phase for kv in [ self . ht_kv , self . lt_kv ]: if kv == 0 : raise ZeroKVError if kv < 0 : raise NegativeKVError if self . ht_kv < self . lt_kv : raise HTkVlowerthanLTkVError ( self . ht_kv , self . lt_kv ) def get_transformer_load_mapping ( self ) -> dict : \"\"\"Refer to base class for more details.\"\"\" # Prepare the data for clustering x_array = np . array ( [[ load . longitude , load . latitude ] for load in self . loads ] ) # Perform clustering operation based on x_data clusters = self . clustering_object . get_clusters ( x_array ) # Mapping cluster centre to loads \"\"\" cluster_to_customers = { tuple ( c ): [] for c in clusters [ \"centre\" ]} for label , load in zip ( clusters [ \"labels\" ], self . loads ): centre = tuple ( clusters [ \"centre\" ][ label ]) cluster_to_customers [ centre ] . append ( load ) # Container to store all the transformers with all the mapping self . transformers = {} for xfmr , t_loads in cluster_to_customers . items (): # Now let's initialize the transformer with it's proper values catalog_used = self . get_catalog_object ( t_loads , self . ht_kv , self . lt_kv ) trans = Transformer () trans . latitude = xfmr [ 1 ] trans . longitude = xfmr [ 0 ] trans . name = f \" { xfmr [ 0 ] } _ { xfmr [ 1 ] } _transformer\" trans . primary_kv = self . ht_kv trans . secondary_kv = self . lt_kv trans . pct_r = catalog_used [ \"percentage_resistance\" ] trans . xhl = catalog_used [ \"percentage_reactance\" ] trans . pct_noloadloss = catalog_used [ \"percentage_no_load_loss\" ] trans . num_phase = self . num_phase trans . primary_con = self . ht_conn trans . kva = catalog_used [ \"kva\" ] trans . secondary_con = self . lt_conn trans . primary_phase = self . ht_phase trans . secondary_phase = self . lt_phase self . transformers [ trans ] = t_loads return self . transformers","title":"ClusteringBasedTransformerLoadMapper"},{"location":"transformer_builder/#shift.transformer_builder.ClusteringBasedTransformerLoadMapper.__init__","text":"Constructor for ClusteringBasedTransformerLoadMapper class. Parameters: Name Type Description Default ht_kv float High tension side kV required lt_kv float Low tension side kV required num_phase NumPhase NumPhase instance required ht_conn TransformerConnection TransformerConnection instance for high tension side required lt_conn TransformerConnection TransformerConnection instance for low tension side required ht_phase Phase Phase instance for high tension side required lt_phase Phase Phase instance for low tension side required clustering_object Clustering Clustering instance required Raises: Type Description ZeroKVError If kv specified is zero NegativeKVError If kv specified is negative HTkVlowerthanLTkVError If high tension kv used is less than low tension kv Source code in shift\\transformer_builder.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 def __init__ ( self , loads : List [ Load ], clustering_object : Clustering , diversity_factor_func : Callable [[ float ], float ], ht_kv : float , lt_kv : float , ht_conn : TransformerConnection , lt_conn : TransformerConnection , ht_phase : Phase , lt_phase : Phase , num_phase : NumPhase , catalog_type = \"all\" , power_factor : float = 1.0 , adjustment_factor : float = 1.25 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ): \"\"\"Constructor for `ClusteringBasedTransformerLoadMapper` class. Args: ht_kv (float): High tension side kV lt_kv (float): Low tension side kV num_phase (NumPhase): NumPhase instance ht_conn (TransformerConnection): TransformerConnection instance for high tension side lt_conn (TransformerConnection): TransformerConnection instance for low tension side ht_phase (Phase): Phase instance for high tension side lt_phase (Phase): Phase instance for low tension side clustering_object (Clustering): Clustering instance Raises: ZeroKVError: If kv specified is zero NegativeKVError: If kv specified is negative HTkVlowerthanLTkVError: If high tension kv used is less than low tension kv \"\"\" super () . __init__ ( loads , diversity_factor_func , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , power_factor , catalog_type , ) self . clustering_object = clustering_object self . ht_kv = ht_kv self . lt_kv = lt_kv self . num_phase = num_phase self . ht_conn = ht_conn self . lt_conn = lt_conn self . ht_phase = ht_phase self . lt_phase = lt_phase for kv in [ self . ht_kv , self . lt_kv ]: if kv == 0 : raise ZeroKVError if kv < 0 : raise NegativeKVError if self . ht_kv < self . lt_kv : raise HTkVlowerthanLTkVError ( self . ht_kv , self . lt_kv )","title":"__init__()"},{"location":"transformer_builder/#shift.transformer_builder.ClusteringBasedTransformerLoadMapper.get_transformer_load_mapping","text":"Refer to base class for more details. Source code in shift\\transformer_builder.py 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 def get_transformer_load_mapping ( self ) -> dict : \"\"\"Refer to base class for more details.\"\"\" # Prepare the data for clustering x_array = np . array ( [[ load . longitude , load . latitude ] for load in self . loads ] ) # Perform clustering operation based on x_data clusters = self . clustering_object . get_clusters ( x_array ) # Mapping cluster centre to loads \"\"\" cluster_to_customers = { tuple ( c ): [] for c in clusters [ \"centre\" ]} for label , load in zip ( clusters [ \"labels\" ], self . loads ): centre = tuple ( clusters [ \"centre\" ][ label ]) cluster_to_customers [ centre ] . append ( load ) # Container to store all the transformers with all the mapping self . transformers = {} for xfmr , t_loads in cluster_to_customers . items (): # Now let's initialize the transformer with it's proper values catalog_used = self . get_catalog_object ( t_loads , self . ht_kv , self . lt_kv ) trans = Transformer () trans . latitude = xfmr [ 1 ] trans . longitude = xfmr [ 0 ] trans . name = f \" { xfmr [ 0 ] } _ { xfmr [ 1 ] } _transformer\" trans . primary_kv = self . ht_kv trans . secondary_kv = self . lt_kv trans . pct_r = catalog_used [ \"percentage_resistance\" ] trans . xhl = catalog_used [ \"percentage_reactance\" ] trans . pct_noloadloss = catalog_used [ \"percentage_no_load_loss\" ] trans . num_phase = self . num_phase trans . primary_con = self . ht_conn trans . kva = catalog_used [ \"kva\" ] trans . secondary_con = self . lt_conn trans . primary_phase = self . ht_phase trans . secondary_phase = self . lt_phase self . transformers [ trans ] = t_loads return self . transformers","title":"get_transformer_load_mapping()"},{"location":"transformer_builder/#shift.transformer_builder.SingleTransformerBuilder","text":"Bases: TransformerLoadMapper Class for managing building of single transformer used to build substation transformer. Refer to base class for attributes passed to base class. Attributes: Name Type Description ht_kv float High tension side kV lt_kv float Low tension side kV num_phase NumPhase NumPhase instance ht_conn TransformerConnection TransformerConnection instance for high tension side lt_conn TransformerConnection TransformerConnection instance for low tension side ht_phase Phase Phase instance for high tension side lt_phase Phase Phase instance for low tension side longitude float Longitude property of transformer latitude float Latitude property of transformer Source code in shift\\transformer_builder.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 class SingleTransformerBuilder ( TransformerLoadMapper ): \"\"\"Class for managing building of single transformer used to build substation transformer. Refer to base class for attributes passed to base class. Attributes: ht_kv (float): High tension side kV lt_kv (float): Low tension side kV num_phase (NumPhase): NumPhase instance ht_conn (TransformerConnection): TransformerConnection instance for high tension side lt_conn (TransformerConnection): TransformerConnection instance for low tension side ht_phase (Phase): Phase instance for high tension side lt_phase (Phase): Phase instance for low tension side longitude (float): Longitude property of transformer latitude (float): Latitude property of transformer \"\"\" def __init__ ( self , loads : List [ Load ], longitude : float , latitude : float , diversity_factor_func : Callable [[ float ], float ], ht_kv : float , lt_kv : float , ht_conn : TransformerConnection , lt_conn : TransformerConnection , ht_phase : Phase , lt_phase : Phase , num_phase : NumPhase , catalog_type = \"all\" , power_factor : float = 1.0 , adjustment_factor : float = 1.25 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ) -> None : \"\"\"Constructor for `SingleTransformerBuilder` class. Args: ht_kv (float): High tension side kV lt_kv (float): Low tension side kV num_phase (NumPhase): NumPhase instance ht_conn (TransformerConnection): TransformerConnection instance for high tension side lt_conn (TransformerConnection): TransformerConnection instance for low tension side ht_phase (Phase): Phase instance for high tension side lt_phase (Phase): Phase instance for low tension side longitude (float): Longitude property of transformer latitude (float): Latitude property of transformer Raises: ZeroKVError: If kv specified is zero NegativeKVError: If kv specified is negative HTkVlowerthanLTkVError: If high tension kv used is less than low tension kv \"\"\" super () . __init__ ( loads , diversity_factor_func , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , power_factor , catalog_type , ) self . ht_kv = ht_kv self . lt_kv = lt_kv self . num_phase = num_phase self . ht_conn = ht_conn self . lt_conn = lt_conn self . ht_phase = ht_phase self . lt_phase = lt_phase self . longitude = longitude self . latitude = latitude for kv in [ self . ht_kv , self . lt_kv ]: if kv == 0 : raise ZeroKVError if kv < 0 : raise NegativeKVError if self . ht_kv < self . lt_kv : raise HTkVlowerthanLTkVError ( self . ht_kv , self . lt_kv ) def get_transformer_load_mapping ( self ) -> dict : \"\"\"Refer to base class for more details.\"\"\" self . transformers = {} catalog_used = self . get_catalog_object ( self . loads , self . ht_kv , self . lt_kv ) trans = Transformer () trans . latitude = self . latitude trans . longitude = self . longitude trans . name = f \" { self . longitude } _ { self . latitude } _transformer\" trans . primary_kv = self . ht_kv trans . secondary_kv = self . lt_kv trans . pct_r = catalog_used [ \"percentage_resistance\" ] trans . xhl = catalog_used [ \"percentage_reactance\" ] trans . pct_noloadloss = catalog_used [ \"percentage_no_load_loss\" ] trans . num_phase = self . num_phase trans . primary_con = self . ht_conn trans . kva = catalog_used [ \"kva\" ] trans . secondary_con = self . lt_conn trans . primary_phase = self . ht_phase trans . secondary_phase = self . lt_phase self . transformers [ trans ] = self . loads return self . transformers","title":"SingleTransformerBuilder"},{"location":"transformer_builder/#shift.transformer_builder.SingleTransformerBuilder.__init__","text":"Constructor for SingleTransformerBuilder class. Parameters: Name Type Description Default ht_kv float High tension side kV required lt_kv float Low tension side kV required num_phase NumPhase NumPhase instance required ht_conn TransformerConnection TransformerConnection instance for high tension side required lt_conn TransformerConnection TransformerConnection instance for low tension side required ht_phase Phase Phase instance for high tension side required lt_phase Phase Phase instance for low tension side required longitude float Longitude property of transformer required latitude float Latitude property of transformer required Raises: Type Description ZeroKVError If kv specified is zero NegativeKVError If kv specified is negative HTkVlowerthanLTkVError If high tension kv used is less than low tension kv Source code in shift\\transformer_builder.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def __init__ ( self , loads : List [ Load ], longitude : float , latitude : float , diversity_factor_func : Callable [[ float ], float ], ht_kv : float , lt_kv : float , ht_conn : TransformerConnection , lt_conn : TransformerConnection , ht_phase : Phase , lt_phase : Phase , num_phase : NumPhase , catalog_type = \"all\" , power_factor : float = 1.0 , adjustment_factor : float = 1.25 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , ) -> None : \"\"\"Constructor for `SingleTransformerBuilder` class. Args: ht_kv (float): High tension side kV lt_kv (float): Low tension side kV num_phase (NumPhase): NumPhase instance ht_conn (TransformerConnection): TransformerConnection instance for high tension side lt_conn (TransformerConnection): TransformerConnection instance for low tension side ht_phase (Phase): Phase instance for high tension side lt_phase (Phase): Phase instance for low tension side longitude (float): Longitude property of transformer latitude (float): Latitude property of transformer Raises: ZeroKVError: If kv specified is zero NegativeKVError: If kv specified is negative HTkVlowerthanLTkVError: If high tension kv used is less than low tension kv \"\"\" super () . __init__ ( loads , diversity_factor_func , adjustment_factor , planned_avg_annual_growth , actual_avg_annual_growth , actual_years_in_operation , planned_years_in_operation , power_factor , catalog_type , ) self . ht_kv = ht_kv self . lt_kv = lt_kv self . num_phase = num_phase self . ht_conn = ht_conn self . lt_conn = lt_conn self . ht_phase = ht_phase self . lt_phase = lt_phase self . longitude = longitude self . latitude = latitude for kv in [ self . ht_kv , self . lt_kv ]: if kv == 0 : raise ZeroKVError if kv < 0 : raise NegativeKVError if self . ht_kv < self . lt_kv : raise HTkVlowerthanLTkVError ( self . ht_kv , self . lt_kv )","title":"__init__()"},{"location":"transformer_builder/#shift.transformer_builder.SingleTransformerBuilder.get_transformer_load_mapping","text":"Refer to base class for more details. Source code in shift\\transformer_builder.py 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 def get_transformer_load_mapping ( self ) -> dict : \"\"\"Refer to base class for more details.\"\"\" self . transformers = {} catalog_used = self . get_catalog_object ( self . loads , self . ht_kv , self . lt_kv ) trans = Transformer () trans . latitude = self . latitude trans . longitude = self . longitude trans . name = f \" { self . longitude } _ { self . latitude } _transformer\" trans . primary_kv = self . ht_kv trans . secondary_kv = self . lt_kv trans . pct_r = catalog_used [ \"percentage_resistance\" ] trans . xhl = catalog_used [ \"percentage_reactance\" ] trans . pct_noloadloss = catalog_used [ \"percentage_no_load_loss\" ] trans . num_phase = self . num_phase trans . primary_con = self . ht_conn trans . kva = catalog_used [ \"kva\" ] trans . secondary_con = self . lt_conn trans . primary_phase = self . ht_phase trans . secondary_phase = self . lt_phase self . transformers [ trans ] = self . loads return self . transformers","title":"get_transformer_load_mapping()"},{"location":"transformer_builder/#shift.transformer_builder.TransformerLoadMapper","text":"Bases: ABC Interface for getting transformer load mapping. Attributes: Name Type Description loads List [ Load ] List of loads diversity_factor_func Callable Callable to compute diversity factor adjustment_factor float Adjustment factor for adjusting kva planned_avg_annual_growth float Planned average annual load growth rate in percentage actual_avg_annual_growth float Actual average annual load growth rate in percentage actual_years_in_operation float Actual years in operation planned_years_in_operation float Planned years in operation power_factor float Power factor used to compute kva catalog_type str Catalog type used for choosing transformer trans_catalog pd . DataFrame Dataframe containing transformer catalogs Source code in shift\\transformer_builder.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 class TransformerLoadMapper ( ABC ): \"\"\"Interface for getting transformer load mapping. Attributes: loads (List[Load]): List of loads diversity_factor_func (Callable): Callable to compute diversity factor adjustment_factor (float): Adjustment factor for adjusting kva planned_avg_annual_growth (float): Planned average annual load growth rate in percentage actual_avg_annual_growth (float): Actual average annual load growth rate in percentage actual_years_in_operation (float): Actual years in operation planned_years_in_operation (float): Planned years in operation power_factor (float): Power factor used to compute kva catalog_type (str): Catalog type used for choosing transformer trans_catalog (pd.DataFrame): Dataframe containing transformer catalogs \"\"\" def __init__ ( self , loads : List [ Load ], diversity_factor_func : Callable [[ float ], float ], adjustment_factor : float = 1.25 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , power_factor : float = 0.9 , catalog_type : str = \"all\" , ) -> None : \"\"\"Constructor for `TransformerLoadMapper` class. Args: loads (List[Load]): List of loads diversity_factor_func (Callable[[float], float]): Callable to compute diversity factor adjustment_factor (float): Adjustment factor for adjusting kva planned_avg_annual_growth (float): Planned average annual load growth rate in percentage actual_avg_annual_growth (float): Actual average annual load growth rate in percentage actual_years_in_operation (float): Actual years in operation planned_years_in_operation (float): Planned years in operation power_factor (float): Power factor used to compute kva catalog_type (str): Catalog type used for choosing transformer Raises: PercentageNotInRangeError: If invalid percentage is used OperationYearNotInRange: If invalid operation year is used AdjustmentFactorNotInRangeError: If invalid adjustment factor is used PowerFactorNotInRangeError: If invalid power factor is used EmptyCatalog: If catalog is empty for given type \"\"\" self . loads = loads self . diversity_factor_func = diversity_factor_func self . planned_avg_annual_growth = planned_avg_annual_growth self . actual_avg_annual_growth = actual_avg_annual_growth self . actual_years_in_operation = actual_years_in_operation self . planned_years_in_operation = planned_years_in_operation self . power_factor = power_factor if ( self . planned_avg_annual_growth < MIN_PERCENTAGE or self . planned_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . planned_avg_annual_growth ) if ( self . actual_avg_annual_growth < MIN_PERCENTAGE or self . actual_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . actual_avg_annual_growth ) if ( self . actual_years_in_operation < MIN_YEAR_OPERATION or self . actual_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . actual_years_in_operation ) if ( self . planned_years_in_operation < MIN_YEAR_OPERATION or self . planned_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . planned_years_in_operation ) self . adjustment_factor = adjustment_factor if ( self . adjustment_factor < MIN_ADJUSTMENT_FACTOR or self . adjustment_factor > MAX_ADJUSTMENT_FACTOR ): raise AdjustmentFactorNotInRangeError ( self . adjustment_factor ) if ( self . power_factor < MIN_POWER_FACTOR or self . power_factor > MAX_POWER_FACTOR ): raise PowerFactorNotInRangeError ( self . power_factor ) self . trans_catalog = pd . read_excel ( TRANSFORMER_CATALOG_FILE ) df_validator ( TRANSFORMER_CATALAOG_SCHEMA , self . trans_catalog ) if catalog_type != \"all\" : self . trans_catalog = self . trans_catalog . loc [ self . trans_catalog [ \"type\" ] == type ] if self . trans_catalog . empty : raise EmptyCatalog ( f \"Catalog of type { type } not found in transformer.xlsx file\" ) def compute_transformer_kva_capacity ( self , non_coincident_peak : float , num_of_customers : int ) -> float : \"\"\"Method for computing transformer capacity. Args: non_coincident_peak (float): Non coincident peak num_of_customers (int): Number of customers Returns: float: Transformer size \"\"\" # Initial step is to compute maximum diversified demand div_factor = ( self . diversity_factor_func ( num_of_customers ) if num_of_customers > 1 else 1 ) max_diversified_demand = non_coincident_peak / div_factor max_diversified_kva = ( max_diversified_demand * self . adjustment_factor / self . power_factor ) original_max_diversified_kva = max_diversified_kva / math . pow ( 1 + self . actual_avg_annual_growth / 100 , self . actual_years_in_operation , ) trafo_size = original_max_diversified_kva * math . pow ( 1 + self . planned_avg_annual_growth / 100 , self . planned_years_in_operation , ) return trafo_size @abstractmethod def get_transformer_load_mapping ( self ) -> dict : \"\"\"Abstract method for returning transformer to loads mapping.\"\"\" pass def get_catalog_object ( self , t_loads : List [ Load ], ht_kv : float , lt_kv : float ) -> dict : \"\"\"Method for getting transformet catalog. Args: t_loads (List[Load]): List of `Load` instances ht_kv (float): High tension kV lt_kv (float): Low tension kv Raises: EmptyCatalog: If transformer catalog is not found Returns: dict: Transformer record \"\"\" # Get maximum diversified demand (kW) and adjusted kW sum_of_noncoincident_peaks = sum ([ l . kw for l in t_loads ]) kva = self . compute_transformer_kva_capacity ( sum_of_noncoincident_peaks , len ( t_loads ) ) # Filter by capacity above kva capacity catalog = self . trans_catalog [ self . trans_catalog [ \"kva\" ] >= kva ] if not catalog . empty : # Filter by high voltage catalog = catalog [ catalog [ \"ht_kv\" ] >= ht_kv ] if not catalog . empty : # Filter by low voltage catalog = catalog [ catalog [ \"lt_kv\" ] >= lt_kv ] if not catalog . empty : catalog_used = catalog . loc [ catalog [ \"kva\" ] . idxmin () ] . to_dict () else : raise EmptyCatalog ( f \"Catalog does not exist for transformer of capacity above or equal to \\ { kva } kVA with high tension voltage above or equal to { ht_kv } and \\ above or equal to low tension voltage { lt_kv } \" ) else : raise EmptyCatalog ( f \"Catalog does not exist for transformer of capacity greater than \\ { kva } kVA with high tension voltage greater than or equal to { ht_kv } \" ) else : raise EmptyCatalog ( \"Catalog does not exist for transformer of capacity above or equal to {kva} kVA\" ) return catalog_used","title":"TransformerLoadMapper"},{"location":"transformer_builder/#shift.transformer_builder.TransformerLoadMapper.__init__","text":"Constructor for TransformerLoadMapper class. Parameters: Name Type Description Default loads List [ Load ] List of loads required diversity_factor_func Callable [[ float ], float ] Callable to compute diversity factor required adjustment_factor float Adjustment factor for adjusting kva 1.25 planned_avg_annual_growth float Planned average annual load growth rate in percentage 2 actual_avg_annual_growth float Actual average annual load growth rate in percentage 4 actual_years_in_operation float Actual years in operation 15 planned_years_in_operation float Planned years in operation 10 power_factor float Power factor used to compute kva 0.9 catalog_type str Catalog type used for choosing transformer 'all' Raises: Type Description PercentageNotInRangeError If invalid percentage is used OperationYearNotInRange If invalid operation year is used AdjustmentFactorNotInRangeError If invalid adjustment factor is used PowerFactorNotInRangeError If invalid power factor is used EmptyCatalog If catalog is empty for given type Source code in shift\\transformer_builder.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def __init__ ( self , loads : List [ Load ], diversity_factor_func : Callable [[ float ], float ], adjustment_factor : float = 1.25 , planned_avg_annual_growth : float = 2 , actual_avg_annual_growth : float = 4 , actual_years_in_operation : float = 15 , planned_years_in_operation : float = 10 , power_factor : float = 0.9 , catalog_type : str = \"all\" , ) -> None : \"\"\"Constructor for `TransformerLoadMapper` class. Args: loads (List[Load]): List of loads diversity_factor_func (Callable[[float], float]): Callable to compute diversity factor adjustment_factor (float): Adjustment factor for adjusting kva planned_avg_annual_growth (float): Planned average annual load growth rate in percentage actual_avg_annual_growth (float): Actual average annual load growth rate in percentage actual_years_in_operation (float): Actual years in operation planned_years_in_operation (float): Planned years in operation power_factor (float): Power factor used to compute kva catalog_type (str): Catalog type used for choosing transformer Raises: PercentageNotInRangeError: If invalid percentage is used OperationYearNotInRange: If invalid operation year is used AdjustmentFactorNotInRangeError: If invalid adjustment factor is used PowerFactorNotInRangeError: If invalid power factor is used EmptyCatalog: If catalog is empty for given type \"\"\" self . loads = loads self . diversity_factor_func = diversity_factor_func self . planned_avg_annual_growth = planned_avg_annual_growth self . actual_avg_annual_growth = actual_avg_annual_growth self . actual_years_in_operation = actual_years_in_operation self . planned_years_in_operation = planned_years_in_operation self . power_factor = power_factor if ( self . planned_avg_annual_growth < MIN_PERCENTAGE or self . planned_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . planned_avg_annual_growth ) if ( self . actual_avg_annual_growth < MIN_PERCENTAGE or self . actual_avg_annual_growth > MAX_PERCENTAGE ): raise PercentageNotInRangeError ( self . actual_avg_annual_growth ) if ( self . actual_years_in_operation < MIN_YEAR_OPERATION or self . actual_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . actual_years_in_operation ) if ( self . planned_years_in_operation < MIN_YEAR_OPERATION or self . planned_years_in_operation > MAX_YEAR_OPERATION ): raise OperationYearNotInRange ( self . planned_years_in_operation ) self . adjustment_factor = adjustment_factor if ( self . adjustment_factor < MIN_ADJUSTMENT_FACTOR or self . adjustment_factor > MAX_ADJUSTMENT_FACTOR ): raise AdjustmentFactorNotInRangeError ( self . adjustment_factor ) if ( self . power_factor < MIN_POWER_FACTOR or self . power_factor > MAX_POWER_FACTOR ): raise PowerFactorNotInRangeError ( self . power_factor ) self . trans_catalog = pd . read_excel ( TRANSFORMER_CATALOG_FILE ) df_validator ( TRANSFORMER_CATALAOG_SCHEMA , self . trans_catalog ) if catalog_type != \"all\" : self . trans_catalog = self . trans_catalog . loc [ self . trans_catalog [ \"type\" ] == type ] if self . trans_catalog . empty : raise EmptyCatalog ( f \"Catalog of type { type } not found in transformer.xlsx file\" )","title":"__init__()"},{"location":"transformer_builder/#shift.transformer_builder.TransformerLoadMapper.compute_transformer_kva_capacity","text":"Method for computing transformer capacity. Parameters: Name Type Description Default non_coincident_peak float Non coincident peak required num_of_customers int Number of customers required Returns: Name Type Description float float Transformer size Source code in shift\\transformer_builder.py 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def compute_transformer_kva_capacity ( self , non_coincident_peak : float , num_of_customers : int ) -> float : \"\"\"Method for computing transformer capacity. Args: non_coincident_peak (float): Non coincident peak num_of_customers (int): Number of customers Returns: float: Transformer size \"\"\" # Initial step is to compute maximum diversified demand div_factor = ( self . diversity_factor_func ( num_of_customers ) if num_of_customers > 1 else 1 ) max_diversified_demand = non_coincident_peak / div_factor max_diversified_kva = ( max_diversified_demand * self . adjustment_factor / self . power_factor ) original_max_diversified_kva = max_diversified_kva / math . pow ( 1 + self . actual_avg_annual_growth / 100 , self . actual_years_in_operation , ) trafo_size = original_max_diversified_kva * math . pow ( 1 + self . planned_avg_annual_growth / 100 , self . planned_years_in_operation , ) return trafo_size","title":"compute_transformer_kva_capacity()"},{"location":"transformer_builder/#shift.transformer_builder.TransformerLoadMapper.get_catalog_object","text":"Method for getting transformet catalog. Parameters: Name Type Description Default t_loads List [ Load ] List of Load instances required ht_kv float High tension kV required lt_kv float Low tension kv required Raises: Type Description EmptyCatalog If transformer catalog is not found Returns: Name Type Description dict dict Transformer record Source code in shift\\transformer_builder.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def get_catalog_object ( self , t_loads : List [ Load ], ht_kv : float , lt_kv : float ) -> dict : \"\"\"Method for getting transformet catalog. Args: t_loads (List[Load]): List of `Load` instances ht_kv (float): High tension kV lt_kv (float): Low tension kv Raises: EmptyCatalog: If transformer catalog is not found Returns: dict: Transformer record \"\"\" # Get maximum diversified demand (kW) and adjusted kW sum_of_noncoincident_peaks = sum ([ l . kw for l in t_loads ]) kva = self . compute_transformer_kva_capacity ( sum_of_noncoincident_peaks , len ( t_loads ) ) # Filter by capacity above kva capacity catalog = self . trans_catalog [ self . trans_catalog [ \"kva\" ] >= kva ] if not catalog . empty : # Filter by high voltage catalog = catalog [ catalog [ \"ht_kv\" ] >= ht_kv ] if not catalog . empty : # Filter by low voltage catalog = catalog [ catalog [ \"lt_kv\" ] >= lt_kv ] if not catalog . empty : catalog_used = catalog . loc [ catalog [ \"kva\" ] . idxmin () ] . to_dict () else : raise EmptyCatalog ( f \"Catalog does not exist for transformer of capacity above or equal to \\ { kva } kVA with high tension voltage above or equal to { ht_kv } and \\ above or equal to low tension voltage { lt_kv } \" ) else : raise EmptyCatalog ( f \"Catalog does not exist for transformer of capacity greater than \\ { kva } kVA with high tension voltage greater than or equal to { ht_kv } \" ) else : raise EmptyCatalog ( \"Catalog does not exist for transformer of capacity above or equal to {kva} kVA\" ) return catalog_used","title":"get_catalog_object()"},{"location":"transformer_builder/#shift.transformer_builder.TransformerLoadMapper.get_transformer_load_mapping","text":"Abstract method for returning transformer to loads mapping. Source code in shift\\transformer_builder.py 210 211 212 213 @abstractmethod def get_transformer_load_mapping ( self ) -> dict : \"\"\"Abstract method for returning transformer to loads mapping.\"\"\" pass","title":"get_transformer_load_mapping()"},{"location":"tutorials/","text":"","title":"Tutorials"},{"location":"utils/","text":"This module contains utility functions used through out the package. create_rectangular_mesh_network ( lower_left , upper_right , vertical_space_meter = 32 , horizontal_space_meter = 32 , forbidden_areas = None , node_append_str = None ) Creates a rectangular mesh network from a given set of points. Parameters: Name Type Description Default lower_left tuple (longitude, latitude) representing lower left point required upper_right tuple (longitude, latitude) representing upper right point required vertical_space_meter float Vertical spacing in meter 32 horizontal_space_meter float Horizontal spacing in meter 32 forbidden_areas Union [ str , None] Shp file representing forbidden polygons None node_append_str Union [ str , None] String to be appended at the end of node name None Returns: Type Description Sequence [ nx . Graph , dict ] Sequence[nx.Graph, dict]: Graph and mapping between nodes and coordinates Source code in shift\\utils.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def create_rectangular_mesh_network ( lower_left : tuple , upper_right : tuple , vertical_space_meter : float = 32 , horizontal_space_meter : float = 32 , forbidden_areas : Union [ str , None ] = None , node_append_str : Union [ str , None ] = None , ) -> Sequence [ nx . Graph , dict ]: \"\"\"Creates a rectangular mesh network from a given set of points. Args: lower_left (tuple): (longitude, latitude) representing lower left point upper_right (tuple): (longitude, latitude) representing upper right point vertical_space_meter (float): Vertical spacing in meter horizontal_space_meter (float): Horizontal spacing in meter forbidden_areas (Union[str, None]): Shp file representing forbidden polygons node_append_str (Union[str, None]): String to be appended at the end of node name Returns: Sequence[nx.Graph, dict]: Graph and mapping between nodes and coordinates \"\"\" # Assuming tuples first element is longitude and second element is latitude # 50m is a common distance between low tension pole # First initialize the network graph = nx . Graph () # Find coordinates for four corners north_west = ( lower_left [ 0 ], upper_right [ 1 ]) north_east = upper_right south_west = lower_left south_east = ( upper_right [ 0 ], lower_left [ 1 ]) # Print some lengths horizontal_distance = get_distance ( south_west , south_east ) vertical_distance = get_distance ( south_west , north_west ) print ( f \"Vertical distance { vertical_distance } m, Horizontal distance { horizontal_distance } m\" ) # Compute number of sections required in horizontal (wet-east) and vertical (north-south) direction horizontal_sections = max ( int ( horizontal_distance / horizontal_space_meter ), 1 ) vertical_sections = max ( int ( vertical_distance / vertical_space_meter ), 1 ) print ( f \"Vertical sections: { vertical_sections } , horizontal sections: { horizontal_sections } \" ) # Let's create node and edges for the rectangular mesh vertical_edges , horizontal_edges = [], [] for lon in get_slices ( lower_left [ 0 ], upper_right [ 0 ], horizontal_sections ): vertical_node_list = [] for lat in get_slices ( lower_left [ 1 ], upper_right [ 1 ], vertical_sections ): node_name = f \" { lon } _ { lat } _ { node_append_str } _node\" graph . add_node ( node_name , pos = ( lon , lat )) vertical_node_list . append ( node_name ) vertical_edges . append ( vertical_node_list ) for lat in get_slices ( lower_left [ 1 ], upper_right [ 1 ], vertical_sections ): horizontal_node_list = [] for lon in get_slices ( lower_left [ 0 ], upper_right [ 0 ], horizontal_sections ): node_name = f \" { lon } _ { lat } _ { node_append_str } _node\" horizontal_node_list . append ( node_name ) horizontal_edges . append ( horizontal_node_list ) # Let's create edges for vertical_points in vertical_edges : for i in range ( len ( vertical_points ) - 1 ): graph . add_edge ( vertical_points [ i ], vertical_points [ i + 1 ]) for horizontal_points in horizontal_edges : for i in range ( len ( horizontal_points ) - 1 ): graph . add_edge ( horizontal_points [ i ], horizontal_points [ i + 1 ]) # Let's plot the mesh points = { key : val [ \"pos\" ] for key , val in dict ( graph . nodes ( data = True )) . items () } # Let's see if the road_network exists try : road_ = RoadNetworkFromPolygon ( [ north_west , north_east , south_east , south_west , north_west ] ) road_ . get_network ( node_append_str ) # Let's try to remove nodes that are near to the road network d_threshold = min ( horizontal_space_meter , vertical_space_meter ) # First we need to slice the road_edges to be no larger than d_threshold sliced_road = slice_up_network_edges ( road_ . updated_network , d_threshold ) sliced_road = nx . relabel_nodes ( sliced_road , { n : n + node_append_str for n in sliced_road . nodes ()} ) # Let's loop through sliced road nodes and remove closer nodes sliced_road_nodes = { key : val [ \"pos\" ] for key , val in dict ( sliced_road . nodes ( data = True )) . items () } for road_node , road_node_coords in sliced_road_nodes . items (): for node , node_coords in points . items (): if get_distance ( node_coords , road_node_coords ) < d_threshold : try : graph . remove_node ( node ) # print(f\"{node} node removed\") except nx . NetworkXError as e : # print(e) pass # Now let's connect the sliced road netowork to truncated mesh network # First step is to find the nearest node for each of the sliced road nodes to truncated mesh network # updated the node_coords points = { key : val [ \"pos\" ] for key , val in dict ( graph . nodes ( data = True )) . items () } nearest_nodes_meshed_network = {} for node , coords in sliced_road_nodes . items (): min_distance , nearest_node = None , None for mesh_node , mesh_node_coords in points . items (): distance = get_distance ( coords , mesh_node_coords ) if min_distance is None : min_distance = distance nearest_node = mesh_node else : if distance < min_distance : min_distance = distance nearest_node = mesh_node if min_distance < ( 1.5 * d_threshold ): nearest_nodes_meshed_network [ node ] = nearest_node # Second step is to add the sliced road edges to truncted mesh network for node , coords in sliced_road_nodes . items (): graph . add_node ( node , pos = coords ) for edge in sliced_road . edges (): graph . add_edge ( edge [ 0 ], edge [ 1 ]) # Add edges to connect the road to mesh network for node1 , node2 in nearest_nodes_meshed_network . items (): graph . add_edge ( node1 , node2 ) # updated the node_coords points = { key : val [ \"pos\" ] for key , val in dict ( graph . nodes ( data = True )) . items () } except ( nx . NetworkXPointlessConcept , ValueError ) as e : print ( e ) # Now let's try to fetch lakes and rives and try to a if forbidden_areas != None : # get all forbidden polygons forbidden_polygons = get_forbidden_polygons ( forbidden_areas ) # Let's create a polygon customer_polygon = shapely . geometry . Polygon ( [ north_west , north_east , south_east , south_west , north_west ] ) forbidden_polygon_subset = [] for polygon in forbidden_polygons : if polygon . intersects ( customer_polygon ): forbidden_polygon_subset . append ( polygon ) if forbidden_polygon_subset : for polygon in forbidden_polygon_subset : for node , coords in points . items (): node_point = shapely . geometry . Point ( coords ) if node_point . within ( polygon ): try : graph . remove_node ( node ) except nx . NetworkXError as e : # print(e) pass if not nx . is_connected ( graph ): largest_component = max ( nx . connected_components ( graph ), key = len ) graph = graph . subgraph ( largest_component ) points = { key : val [ \"pos\" ] for key , val in dict ( graph . nodes ( data = True )) . items () } return graph , points df_validator ( schema , df ) Validates the content of pandas dataframe. Uses cerberus for validation. So refer to cerberus documentation for scheme. Parameters: Name Type Description Default schema dict Schema for validating the content of pandas dataframe required df pd . DataFrame Pandas dataframe to be validated required Raises: Type Description ValidationError If error is found Returns bool: True if validation passes. Source code in shift\\utils.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def df_validator ( schema : dict , df : pd . DataFrame ) -> bool : \"\"\"Validates the content of pandas dataframe. Uses cerberus for validation. So refer to cerberus documentation for scheme. Args: schema (dict): Schema for validating the content of pandas dataframe df (pd.DataFrame): Pandas dataframe to be validated Raises: ValidationError: If error is found Returns bool: True if validation passes. \"\"\" errors = [] csv_validator = Validator () csv_validator . schema = schema csv_validator . require_all = True for idx , record in enumerate ( df . to_dict ( orient = \"records\" )): if not csv_validator . validate ( record ): errors . append ( f \"Item { idx } : { csv_validator . errors } , Record: { record } \" ) if errors : raise ValidationError ( errors ) return True get_distance ( point1 , point2 , latlon = False ) Returns distance between two geopoints in meter assuming eliposoidal earth model. Parameters: Name Type Description Default point1 List [ float ] location coordinate for point 1 required point2 List [ float ] location coordinate for point 2 required latlon bool Specfies that latitude is first and longitude is second if true False Returns: Name Type Description float float distance in meter Source code in shift\\utils.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def get_distance ( point1 : List [ float ], point2 : List [ float ], latlon = False ) -> float : \"\"\"Returns distance between two geopoints in meter assuming eliposoidal earth model. Args: point1 (List[float]): location coordinate for point 1 point2 (List[float]): location coordinate for point 2 latlon (bool): Specfies that latitude is first and longitude is second if true Returns: float: distance in meter \"\"\" # Assuming point1 and point2 are tuples with first element representing longitude and # second element representing latitude # Geopy however requires (lat, lon) pair if not latlon : return ( geopy . distance . distance ( ( point1 [ 1 ], point1 [ 0 ]), ( point2 [ 1 ], point2 [ 0 ]) ) . km * 1000 ) else : return geopy . distance . distance ( point1 , point2 ) . km * 1000 get_forbidden_polygons ( shp_file ) Get all the polygons from a shape file. Parameters: Name Type Description Default shp_file str Path to .shp file required Returns: Type Description List [ shapely . geometry . Polygon ] List[shapely.geometry.Polygon]: List of shapely polygons Source code in shift\\utils.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def get_forbidden_polygons ( shp_file : str ) -> List [ shapely . geometry . Polygon ]: \"\"\"Get all the polygons from a shape file. Args: shp_file (str): Path to .shp file Returns: List[shapely.geometry.Polygon]: List of shapely polygons \"\"\" shape = shapefile . Reader ( shp_file ) forbidden_polygons = [] for feature in shape . shapeRecords (): feature_object = feature . shape . __geo_interface__ if feature_object [ \"type\" ] == \"Polygon\" : forbidden_polygons . append ( shapely . geometry . Polygon ( feature_object [ \"coordinates\" ][ 0 ]) ) return forbidden_polygons get_nearest_points_in_the_network ( graph , points ) Retrieve nearest node from the graph for given points Parameters: Name Type Description Default graph nx . Graph Networkx graph instance required points List [ List [ float ]] List of points for which nearest nodes are to be found required Todo Fix the issue if returned nodes are same for two points. Returns: Name Type Description dict dict mapping between nearest node and point Source code in shift\\utils.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def get_nearest_points_in_the_network ( graph : nx . Graph , points : List [ List [ float ]] ) -> dict : \"\"\"Retrieve nearest node from the graph for given points Args: graph (nx.Graph): Networkx graph instance points (List[List[float]]): List of points for which nearest nodes are to be found Todo: * Fix the issue if returned nodes are same for two points. Returns: dict: mapping between nearest node and point \"\"\" nearest_points = {} graph_node_data = { key : val [ \"pos\" ] for key , val in dict ( graph . nodes ( data = True )) . items () } for point in points : min_distance , nearest_node = None , None for node , coords in graph_node_data . items (): distance = get_distance ( point , coords ) if min_distance is None : min_distance = distance nearest_node = node else : if distance < min_distance : min_distance = distance nearest_node = node nearest_points [ nearest_node ] = { \"centre\" : point , \"longitude\" : graph_node_data [ nearest_node ][ 0 ], \"latitude\" : graph_node_data [ nearest_node ][ 1 ], } return nearest_points get_point_from_curve ( curve , x ) Returns a y coordinate for a given x coordinate by following piecewise linear function. Parameters: Name Type Description Default curve List [ List [ float ]] List of list containing two floats required x float x coordinate required Returns: Name Type Description float float y coordinate Source code in shift\\utils.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def get_point_from_curve ( curve : List [ List [ float ]], x : float ) -> float : \"\"\"Returns a y coordinate for a given x coordinate by following piecewise linear function. Args: curve (List[List[float]]): List of list containing two floats x (float): x coordinate Returns: float: y coordinate \"\"\" x_ = np . array ([ el [ 0 ] for el in curve ]) y_ = np . array ([ el [ 1 ] for el in curve ]) index = sum ( x_ <= x ) if index == len ( x_ ): y = ( y_ [ index - 1 ] - y_ [ index - 2 ]) * ( x - x_ [ index - 2 ]) / ( x_ [ index - 1 ] - x_ [ index - 2 ] ) + y_ [ index - 2 ] elif index == 0 : y = ( y_ [ index + 1 ] - y_ [ index ]) * ( x - x_ [ index ]) / ( x_ [ index + 1 ] - x_ [ index ] ) + y_ [ index ] else : y = ( y_ [ index ] - y_ [ index - 1 ]) * ( x - x_ [ index - 1 ]) / ( x_ [ index ] - x_ [ index - 1 ] ) + y_ [ index - 1 ] return y get_slices ( start , end , num_steps ) Get slices between two numbers Source code in shift\\utils.py 257 258 259 260 261 def get_slices ( start : float , end : float , num_steps : int ) -> List [ float ]: \"\"\"Get slices between two numbers\"\"\" return [ start + i * ( end - start ) / ( num_steps ) for i in range ( num_steps + 1 ) ] mesh_pruning ( mesh_graph , customers ) Prunes the mesh graph by keeping the nodes specified. Parameters: Name Type Description Default mesh_graph nx . Graph Graph to be pruned required customers List [ List [ float ]] List[List[float]]: List of points to be used for pruning required Returns: Type Description Sequence [ nx . Graph , dict ] Sequence[nx.Graph, dict]: Pruned network and mapping between customer and node Source code in shift\\utils.py 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 def mesh_pruning ( mesh_graph : nx . Graph , customers : List [ List [ float ]] ) -> Sequence [ nx . Graph , dict ]: \"\"\"Prunes the mesh graph by keeping the nodes specified. Args: mesh_graph (nx.Graph): Graph to be pruned customers: List[List[float]]: List of points to be used for pruning Returns: Sequence[nx.Graph, dict]: Pruned network and mapping between customer and node \"\"\" # Let's find the nodes we absolutey need to keep points = { key : val [ \"pos\" ] for key , val in dict ( mesh_graph . nodes ( data = True )) . items () } nodes_to_keep = [] customer_to_node_mapper = {} for customer in customers : min_distance , nearest_node = None , None for point , coords in points . items (): distance = get_distance ( customer , coords ) if min_distance is None : min_distance = distance nearest_node = point else : if distance < min_distance : min_distance = distance nearest_node = point if nearest_node not in nodes_to_keep : nodes_to_keep . append ( nearest_node ) customer_to_node_mapper [ f \" { customer [ 0 ] } _ { customer [ 1 ] } _customer\" ] = nearest_node # Let's start pruning the network graph_mst = ax . steinertree . steiner_tree ( mesh_graph , nodes_to_keep ) return graph_mst , customer_to_node_mapper set_node_edge_type ( network ) Sets the type to node and edge. Parameters: Name Type Description Default network nx . Graph Networkx graph instance required Returns: Type Description nx . Graph nx.Graph: Updated graph Source code in shift\\utils.py 539 540 541 542 543 544 545 546 547 548 549 550 551 def set_node_edge_type ( network : nx . Graph ) -> nx . Graph : \"\"\"Sets the type to node and edge. Args: network (nx.Graph): Networkx graph instance Returns: nx.Graph: Updated graph \"\"\" nx . set_node_attributes ( network , \"node\" , name = \"type\" ) nx . set_node_attributes ( network , { \"type\" : \"node\" }, name = \"data\" ) nx . set_edge_attributes ( network , \"edge\" , name = \"type\" ) return network slice_up_network_edges ( graph , slice_in_meter ) Creates a new graph with edges sliced by given distance in meter. Parameters: Name Type Description Default graph nx . Graph Networkx graph instance required slice_in_meter float Maximum length of edge in meter for use in slicing required Returns: Type Description nx . Graph nx.Graph: Sliced network Source code in shift\\utils.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def slice_up_network_edges ( graph : nx . Graph , slice_in_meter : float ) -> nx . Graph : \"\"\"Creates a new graph with edges sliced by given distance in meter. Args: graph (nx.Graph): Networkx graph instance slice_in_meter (float): Maximum length of edge in meter for use in slicing Returns: nx.Graph: Sliced network \"\"\" sliced_graph = nx . Graph () graph_nodes = { x [ 0 ]: x [ 1 ][ \"pos\" ] if \"pos\" in x [ 1 ] else [ x [ 1 ][ \"x\" ], x [ 1 ][ \"y\" ]] for x in graph . nodes . data () } for edge in graph . edges (): edge_length = get_distance ( ( graph_nodes [ edge [ 0 ]][ 0 ], graph_nodes [ edge [ 0 ]][ 1 ]), ( graph_nodes [ edge [ 1 ]][ 0 ], graph_nodes [ edge [ 1 ]][ 1 ]), ) edge_slices = [ x / edge_length for x in np . arange ( 0 , edge_length , slice_in_meter ) ] + [ 1 ] x1 , y1 = ( graph_nodes [ edge [ 0 ]][ 0 ], graph_nodes [ edge [ 0 ]][ 1 ]) x2 , y2 = ( graph_nodes [ edge [ 1 ]][ 0 ], graph_nodes [ edge [ 1 ]][ 1 ]) sliced_nodes = [] for slice in edge_slices : new_x , new_y = x1 + ( x2 - x1 ) * slice , y1 + ( y2 - y1 ) * slice sliced_graph . add_node ( f \" { new_x } _ { new_y } _node\" , pos = ( new_x , new_y ), type = \"node\" , data = {}, ) sliced_nodes . append ( f \" { new_x } _ { new_y } _node\" ) for i in range ( len ( sliced_nodes ) - 1 ): sliced_graph . add_edge ( sliced_nodes [ i ], sliced_nodes [ i + 1 ], type = \"edge\" ) return sliced_graph triangulate_using_mesh ( customers , forbidden_areas = None , node_append_str = None ) Creates a minimum spanning graph connecting customers by avoiding forbidden region. Parameters: Name Type Description Default customers List [ List [ float ]] List of points to be used to create graph required forbidden_areas Union [ str , None] Path to .shp file None node_append_str Union [ str , None] String to be appended to node name None Returns: Type Description Sequence [ nx . Graph , dict , dict ] Sequence[nx.Graph, dict, dict]: Minimum spannnig tree, mapping between point and coordinates and customer to node mapping. Source code in shift\\utils.py 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 def triangulate_using_mesh ( customers : List [ List [ float ]], forbidden_areas : Union [ str , None ] = None , node_append_str : Union [ str , None ] = None , ) -> Sequence [ nx . Graph , dict , dict ]: \"\"\"Creates a minimum spanning graph connecting customers by avoiding forbidden region. Args: customers (List[List[float]]): List of points to be used to create graph forbidden_areas (Union[str, None]): Path to .shp file node_append_str (Union[str, None]): String to be appended to node name Returns: Sequence[nx.Graph, dict, dict]: Minimum spannnig tree, mapping between point and coordinates and customer to node mapping. \"\"\" # find the edge coordinates lats = [ x [ 1 ] for x in customers ] lons = [ x [ 0 ] for x in customers ] graph , points = create_rectangular_mesh_network ( ( min ( lons ), min ( lats )), ( max ( lons ), max ( lats )), forbidden_areas = forbidden_areas , node_append_str = node_append_str , ) graph_mst , customer_to_node_mapper = mesh_pruning ( graph , customers ) # graph, points = add_customer_nodes_and_edges(graph_mst, customer_to_node_mapper) return graph_mst , points , customer_to_node_mapper","title":"utils"},{"location":"utils/#shift.utils.create_rectangular_mesh_network","text":"Creates a rectangular mesh network from a given set of points. Parameters: Name Type Description Default lower_left tuple (longitude, latitude) representing lower left point required upper_right tuple (longitude, latitude) representing upper right point required vertical_space_meter float Vertical spacing in meter 32 horizontal_space_meter float Horizontal spacing in meter 32 forbidden_areas Union [ str , None] Shp file representing forbidden polygons None node_append_str Union [ str , None] String to be appended at the end of node name None Returns: Type Description Sequence [ nx . Graph , dict ] Sequence[nx.Graph, dict]: Graph and mapping between nodes and coordinates Source code in shift\\utils.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def create_rectangular_mesh_network ( lower_left : tuple , upper_right : tuple , vertical_space_meter : float = 32 , horizontal_space_meter : float = 32 , forbidden_areas : Union [ str , None ] = None , node_append_str : Union [ str , None ] = None , ) -> Sequence [ nx . Graph , dict ]: \"\"\"Creates a rectangular mesh network from a given set of points. Args: lower_left (tuple): (longitude, latitude) representing lower left point upper_right (tuple): (longitude, latitude) representing upper right point vertical_space_meter (float): Vertical spacing in meter horizontal_space_meter (float): Horizontal spacing in meter forbidden_areas (Union[str, None]): Shp file representing forbidden polygons node_append_str (Union[str, None]): String to be appended at the end of node name Returns: Sequence[nx.Graph, dict]: Graph and mapping between nodes and coordinates \"\"\" # Assuming tuples first element is longitude and second element is latitude # 50m is a common distance between low tension pole # First initialize the network graph = nx . Graph () # Find coordinates for four corners north_west = ( lower_left [ 0 ], upper_right [ 1 ]) north_east = upper_right south_west = lower_left south_east = ( upper_right [ 0 ], lower_left [ 1 ]) # Print some lengths horizontal_distance = get_distance ( south_west , south_east ) vertical_distance = get_distance ( south_west , north_west ) print ( f \"Vertical distance { vertical_distance } m, Horizontal distance { horizontal_distance } m\" ) # Compute number of sections required in horizontal (wet-east) and vertical (north-south) direction horizontal_sections = max ( int ( horizontal_distance / horizontal_space_meter ), 1 ) vertical_sections = max ( int ( vertical_distance / vertical_space_meter ), 1 ) print ( f \"Vertical sections: { vertical_sections } , horizontal sections: { horizontal_sections } \" ) # Let's create node and edges for the rectangular mesh vertical_edges , horizontal_edges = [], [] for lon in get_slices ( lower_left [ 0 ], upper_right [ 0 ], horizontal_sections ): vertical_node_list = [] for lat in get_slices ( lower_left [ 1 ], upper_right [ 1 ], vertical_sections ): node_name = f \" { lon } _ { lat } _ { node_append_str } _node\" graph . add_node ( node_name , pos = ( lon , lat )) vertical_node_list . append ( node_name ) vertical_edges . append ( vertical_node_list ) for lat in get_slices ( lower_left [ 1 ], upper_right [ 1 ], vertical_sections ): horizontal_node_list = [] for lon in get_slices ( lower_left [ 0 ], upper_right [ 0 ], horizontal_sections ): node_name = f \" { lon } _ { lat } _ { node_append_str } _node\" horizontal_node_list . append ( node_name ) horizontal_edges . append ( horizontal_node_list ) # Let's create edges for vertical_points in vertical_edges : for i in range ( len ( vertical_points ) - 1 ): graph . add_edge ( vertical_points [ i ], vertical_points [ i + 1 ]) for horizontal_points in horizontal_edges : for i in range ( len ( horizontal_points ) - 1 ): graph . add_edge ( horizontal_points [ i ], horizontal_points [ i + 1 ]) # Let's plot the mesh points = { key : val [ \"pos\" ] for key , val in dict ( graph . nodes ( data = True )) . items () } # Let's see if the road_network exists try : road_ = RoadNetworkFromPolygon ( [ north_west , north_east , south_east , south_west , north_west ] ) road_ . get_network ( node_append_str ) # Let's try to remove nodes that are near to the road network d_threshold = min ( horizontal_space_meter , vertical_space_meter ) # First we need to slice the road_edges to be no larger than d_threshold sliced_road = slice_up_network_edges ( road_ . updated_network , d_threshold ) sliced_road = nx . relabel_nodes ( sliced_road , { n : n + node_append_str for n in sliced_road . nodes ()} ) # Let's loop through sliced road nodes and remove closer nodes sliced_road_nodes = { key : val [ \"pos\" ] for key , val in dict ( sliced_road . nodes ( data = True )) . items () } for road_node , road_node_coords in sliced_road_nodes . items (): for node , node_coords in points . items (): if get_distance ( node_coords , road_node_coords ) < d_threshold : try : graph . remove_node ( node ) # print(f\"{node} node removed\") except nx . NetworkXError as e : # print(e) pass # Now let's connect the sliced road netowork to truncated mesh network # First step is to find the nearest node for each of the sliced road nodes to truncated mesh network # updated the node_coords points = { key : val [ \"pos\" ] for key , val in dict ( graph . nodes ( data = True )) . items () } nearest_nodes_meshed_network = {} for node , coords in sliced_road_nodes . items (): min_distance , nearest_node = None , None for mesh_node , mesh_node_coords in points . items (): distance = get_distance ( coords , mesh_node_coords ) if min_distance is None : min_distance = distance nearest_node = mesh_node else : if distance < min_distance : min_distance = distance nearest_node = mesh_node if min_distance < ( 1.5 * d_threshold ): nearest_nodes_meshed_network [ node ] = nearest_node # Second step is to add the sliced road edges to truncted mesh network for node , coords in sliced_road_nodes . items (): graph . add_node ( node , pos = coords ) for edge in sliced_road . edges (): graph . add_edge ( edge [ 0 ], edge [ 1 ]) # Add edges to connect the road to mesh network for node1 , node2 in nearest_nodes_meshed_network . items (): graph . add_edge ( node1 , node2 ) # updated the node_coords points = { key : val [ \"pos\" ] for key , val in dict ( graph . nodes ( data = True )) . items () } except ( nx . NetworkXPointlessConcept , ValueError ) as e : print ( e ) # Now let's try to fetch lakes and rives and try to a if forbidden_areas != None : # get all forbidden polygons forbidden_polygons = get_forbidden_polygons ( forbidden_areas ) # Let's create a polygon customer_polygon = shapely . geometry . Polygon ( [ north_west , north_east , south_east , south_west , north_west ] ) forbidden_polygon_subset = [] for polygon in forbidden_polygons : if polygon . intersects ( customer_polygon ): forbidden_polygon_subset . append ( polygon ) if forbidden_polygon_subset : for polygon in forbidden_polygon_subset : for node , coords in points . items (): node_point = shapely . geometry . Point ( coords ) if node_point . within ( polygon ): try : graph . remove_node ( node ) except nx . NetworkXError as e : # print(e) pass if not nx . is_connected ( graph ): largest_component = max ( nx . connected_components ( graph ), key = len ) graph = graph . subgraph ( largest_component ) points = { key : val [ \"pos\" ] for key , val in dict ( graph . nodes ( data = True )) . items () } return graph , points","title":"create_rectangular_mesh_network()"},{"location":"utils/#shift.utils.df_validator","text":"Validates the content of pandas dataframe. Uses cerberus for validation. So refer to cerberus documentation for scheme. Parameters: Name Type Description Default schema dict Schema for validating the content of pandas dataframe required df pd . DataFrame Pandas dataframe to be validated required Raises: Type Description ValidationError If error is found Returns bool: True if validation passes. Source code in shift\\utils.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def df_validator ( schema : dict , df : pd . DataFrame ) -> bool : \"\"\"Validates the content of pandas dataframe. Uses cerberus for validation. So refer to cerberus documentation for scheme. Args: schema (dict): Schema for validating the content of pandas dataframe df (pd.DataFrame): Pandas dataframe to be validated Raises: ValidationError: If error is found Returns bool: True if validation passes. \"\"\" errors = [] csv_validator = Validator () csv_validator . schema = schema csv_validator . require_all = True for idx , record in enumerate ( df . to_dict ( orient = \"records\" )): if not csv_validator . validate ( record ): errors . append ( f \"Item { idx } : { csv_validator . errors } , Record: { record } \" ) if errors : raise ValidationError ( errors ) return True","title":"df_validator()"},{"location":"utils/#shift.utils.get_distance","text":"Returns distance between two geopoints in meter assuming eliposoidal earth model. Parameters: Name Type Description Default point1 List [ float ] location coordinate for point 1 required point2 List [ float ] location coordinate for point 2 required latlon bool Specfies that latitude is first and longitude is second if true False Returns: Name Type Description float float distance in meter Source code in shift\\utils.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def get_distance ( point1 : List [ float ], point2 : List [ float ], latlon = False ) -> float : \"\"\"Returns distance between two geopoints in meter assuming eliposoidal earth model. Args: point1 (List[float]): location coordinate for point 1 point2 (List[float]): location coordinate for point 2 latlon (bool): Specfies that latitude is first and longitude is second if true Returns: float: distance in meter \"\"\" # Assuming point1 and point2 are tuples with first element representing longitude and # second element representing latitude # Geopy however requires (lat, lon) pair if not latlon : return ( geopy . distance . distance ( ( point1 [ 1 ], point1 [ 0 ]), ( point2 [ 1 ], point2 [ 0 ]) ) . km * 1000 ) else : return geopy . distance . distance ( point1 , point2 ) . km * 1000","title":"get_distance()"},{"location":"utils/#shift.utils.get_forbidden_polygons","text":"Get all the polygons from a shape file. Parameters: Name Type Description Default shp_file str Path to .shp file required Returns: Type Description List [ shapely . geometry . Polygon ] List[shapely.geometry.Polygon]: List of shapely polygons Source code in shift\\utils.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def get_forbidden_polygons ( shp_file : str ) -> List [ shapely . geometry . Polygon ]: \"\"\"Get all the polygons from a shape file. Args: shp_file (str): Path to .shp file Returns: List[shapely.geometry.Polygon]: List of shapely polygons \"\"\" shape = shapefile . Reader ( shp_file ) forbidden_polygons = [] for feature in shape . shapeRecords (): feature_object = feature . shape . __geo_interface__ if feature_object [ \"type\" ] == \"Polygon\" : forbidden_polygons . append ( shapely . geometry . Polygon ( feature_object [ \"coordinates\" ][ 0 ]) ) return forbidden_polygons","title":"get_forbidden_polygons()"},{"location":"utils/#shift.utils.get_nearest_points_in_the_network","text":"Retrieve nearest node from the graph for given points Parameters: Name Type Description Default graph nx . Graph Networkx graph instance required points List [ List [ float ]] List of points for which nearest nodes are to be found required Todo Fix the issue if returned nodes are same for two points. Returns: Name Type Description dict dict mapping between nearest node and point Source code in shift\\utils.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def get_nearest_points_in_the_network ( graph : nx . Graph , points : List [ List [ float ]] ) -> dict : \"\"\"Retrieve nearest node from the graph for given points Args: graph (nx.Graph): Networkx graph instance points (List[List[float]]): List of points for which nearest nodes are to be found Todo: * Fix the issue if returned nodes are same for two points. Returns: dict: mapping between nearest node and point \"\"\" nearest_points = {} graph_node_data = { key : val [ \"pos\" ] for key , val in dict ( graph . nodes ( data = True )) . items () } for point in points : min_distance , nearest_node = None , None for node , coords in graph_node_data . items (): distance = get_distance ( point , coords ) if min_distance is None : min_distance = distance nearest_node = node else : if distance < min_distance : min_distance = distance nearest_node = node nearest_points [ nearest_node ] = { \"centre\" : point , \"longitude\" : graph_node_data [ nearest_node ][ 0 ], \"latitude\" : graph_node_data [ nearest_node ][ 1 ], } return nearest_points","title":"get_nearest_points_in_the_network()"},{"location":"utils/#shift.utils.get_point_from_curve","text":"Returns a y coordinate for a given x coordinate by following piecewise linear function. Parameters: Name Type Description Default curve List [ List [ float ]] List of list containing two floats required x float x coordinate required Returns: Name Type Description float float y coordinate Source code in shift\\utils.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def get_point_from_curve ( curve : List [ List [ float ]], x : float ) -> float : \"\"\"Returns a y coordinate for a given x coordinate by following piecewise linear function. Args: curve (List[List[float]]): List of list containing two floats x (float): x coordinate Returns: float: y coordinate \"\"\" x_ = np . array ([ el [ 0 ] for el in curve ]) y_ = np . array ([ el [ 1 ] for el in curve ]) index = sum ( x_ <= x ) if index == len ( x_ ): y = ( y_ [ index - 1 ] - y_ [ index - 2 ]) * ( x - x_ [ index - 2 ]) / ( x_ [ index - 1 ] - x_ [ index - 2 ] ) + y_ [ index - 2 ] elif index == 0 : y = ( y_ [ index + 1 ] - y_ [ index ]) * ( x - x_ [ index ]) / ( x_ [ index + 1 ] - x_ [ index ] ) + y_ [ index ] else : y = ( y_ [ index ] - y_ [ index - 1 ]) * ( x - x_ [ index - 1 ]) / ( x_ [ index ] - x_ [ index - 1 ] ) + y_ [ index - 1 ] return y","title":"get_point_from_curve()"},{"location":"utils/#shift.utils.get_slices","text":"Get slices between two numbers Source code in shift\\utils.py 257 258 259 260 261 def get_slices ( start : float , end : float , num_steps : int ) -> List [ float ]: \"\"\"Get slices between two numbers\"\"\" return [ start + i * ( end - start ) / ( num_steps ) for i in range ( num_steps + 1 ) ]","title":"get_slices()"},{"location":"utils/#shift.utils.mesh_pruning","text":"Prunes the mesh graph by keeping the nodes specified. Parameters: Name Type Description Default mesh_graph nx . Graph Graph to be pruned required customers List [ List [ float ]] List[List[float]]: List of points to be used for pruning required Returns: Type Description Sequence [ nx . Graph , dict ] Sequence[nx.Graph, dict]: Pruned network and mapping between customer and node Source code in shift\\utils.py 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 def mesh_pruning ( mesh_graph : nx . Graph , customers : List [ List [ float ]] ) -> Sequence [ nx . Graph , dict ]: \"\"\"Prunes the mesh graph by keeping the nodes specified. Args: mesh_graph (nx.Graph): Graph to be pruned customers: List[List[float]]: List of points to be used for pruning Returns: Sequence[nx.Graph, dict]: Pruned network and mapping between customer and node \"\"\" # Let's find the nodes we absolutey need to keep points = { key : val [ \"pos\" ] for key , val in dict ( mesh_graph . nodes ( data = True )) . items () } nodes_to_keep = [] customer_to_node_mapper = {} for customer in customers : min_distance , nearest_node = None , None for point , coords in points . items (): distance = get_distance ( customer , coords ) if min_distance is None : min_distance = distance nearest_node = point else : if distance < min_distance : min_distance = distance nearest_node = point if nearest_node not in nodes_to_keep : nodes_to_keep . append ( nearest_node ) customer_to_node_mapper [ f \" { customer [ 0 ] } _ { customer [ 1 ] } _customer\" ] = nearest_node # Let's start pruning the network graph_mst = ax . steinertree . steiner_tree ( mesh_graph , nodes_to_keep ) return graph_mst , customer_to_node_mapper","title":"mesh_pruning()"},{"location":"utils/#shift.utils.set_node_edge_type","text":"Sets the type to node and edge. Parameters: Name Type Description Default network nx . Graph Networkx graph instance required Returns: Type Description nx . Graph nx.Graph: Updated graph Source code in shift\\utils.py 539 540 541 542 543 544 545 546 547 548 549 550 551 def set_node_edge_type ( network : nx . Graph ) -> nx . Graph : \"\"\"Sets the type to node and edge. Args: network (nx.Graph): Networkx graph instance Returns: nx.Graph: Updated graph \"\"\" nx . set_node_attributes ( network , \"node\" , name = \"type\" ) nx . set_node_attributes ( network , { \"type\" : \"node\" }, name = \"data\" ) nx . set_edge_attributes ( network , \"edge\" , name = \"type\" ) return network","title":"set_node_edge_type()"},{"location":"utils/#shift.utils.slice_up_network_edges","text":"Creates a new graph with edges sliced by given distance in meter. Parameters: Name Type Description Default graph nx . Graph Networkx graph instance required slice_in_meter float Maximum length of edge in meter for use in slicing required Returns: Type Description nx . Graph nx.Graph: Sliced network Source code in shift\\utils.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def slice_up_network_edges ( graph : nx . Graph , slice_in_meter : float ) -> nx . Graph : \"\"\"Creates a new graph with edges sliced by given distance in meter. Args: graph (nx.Graph): Networkx graph instance slice_in_meter (float): Maximum length of edge in meter for use in slicing Returns: nx.Graph: Sliced network \"\"\" sliced_graph = nx . Graph () graph_nodes = { x [ 0 ]: x [ 1 ][ \"pos\" ] if \"pos\" in x [ 1 ] else [ x [ 1 ][ \"x\" ], x [ 1 ][ \"y\" ]] for x in graph . nodes . data () } for edge in graph . edges (): edge_length = get_distance ( ( graph_nodes [ edge [ 0 ]][ 0 ], graph_nodes [ edge [ 0 ]][ 1 ]), ( graph_nodes [ edge [ 1 ]][ 0 ], graph_nodes [ edge [ 1 ]][ 1 ]), ) edge_slices = [ x / edge_length for x in np . arange ( 0 , edge_length , slice_in_meter ) ] + [ 1 ] x1 , y1 = ( graph_nodes [ edge [ 0 ]][ 0 ], graph_nodes [ edge [ 0 ]][ 1 ]) x2 , y2 = ( graph_nodes [ edge [ 1 ]][ 0 ], graph_nodes [ edge [ 1 ]][ 1 ]) sliced_nodes = [] for slice in edge_slices : new_x , new_y = x1 + ( x2 - x1 ) * slice , y1 + ( y2 - y1 ) * slice sliced_graph . add_node ( f \" { new_x } _ { new_y } _node\" , pos = ( new_x , new_y ), type = \"node\" , data = {}, ) sliced_nodes . append ( f \" { new_x } _ { new_y } _node\" ) for i in range ( len ( sliced_nodes ) - 1 ): sliced_graph . add_edge ( sliced_nodes [ i ], sliced_nodes [ i + 1 ], type = \"edge\" ) return sliced_graph","title":"slice_up_network_edges()"},{"location":"utils/#shift.utils.triangulate_using_mesh","text":"Creates a minimum spanning graph connecting customers by avoiding forbidden region. Parameters: Name Type Description Default customers List [ List [ float ]] List of points to be used to create graph required forbidden_areas Union [ str , None] Path to .shp file None node_append_str Union [ str , None] String to be appended to node name None Returns: Type Description Sequence [ nx . Graph , dict , dict ] Sequence[nx.Graph, dict, dict]: Minimum spannnig tree, mapping between point and coordinates and customer to node mapping. Source code in shift\\utils.py 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 def triangulate_using_mesh ( customers : List [ List [ float ]], forbidden_areas : Union [ str , None ] = None , node_append_str : Union [ str , None ] = None , ) -> Sequence [ nx . Graph , dict , dict ]: \"\"\"Creates a minimum spanning graph connecting customers by avoiding forbidden region. Args: customers (List[List[float]]): List of points to be used to create graph forbidden_areas (Union[str, None]): Path to .shp file node_append_str (Union[str, None]): String to be appended to node name Returns: Sequence[nx.Graph, dict, dict]: Minimum spannnig tree, mapping between point and coordinates and customer to node mapping. \"\"\" # find the edge coordinates lats = [ x [ 1 ] for x in customers ] lons = [ x [ 0 ] for x in customers ] graph , points = create_rectangular_mesh_network ( ( min ( lons ), min ( lats )), ( max ( lons ), max ( lats )), forbidden_areas = forbidden_areas , node_append_str = node_append_str , ) graph_mst , customer_to_node_mapper = mesh_pruning ( graph , customers ) # graph, points = add_customer_nodes_and_edges(graph_mst, customer_to_node_mapper) return graph_mst , points , customer_to_node_mapper","title":"triangulate_using_mesh()"}]}